Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/edid.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/include/linux/edid.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/edid.h	2014-08-07 11:51:55.306748557 -0600
@@ -48,8 +48,8 @@
 #define HDMI_EDID_H_SYNC_PW_OFFSET		9
 #define HDMI_EDID_V_SYNC_OFFSET			10
 #define HDMI_EDID_V_SYNC_PW_OFFSET		11
-#define HDMI_EDID_H_IMAGE_SIZE_OFFSET		12
-#define HDMI_EDID_V_IMAGE_SIZE_OFFSET		13
+#define HDMI_EDID_H_IMAGE_SIZE_OFFSET	12
+#define HDMI_EDID_V_IMAGE_SIZE_OFFSET	13
 #define HDMI_EDID_H_BORDER_OFFSET		15
 #define HDMI_EDID_V_BORDER_OFFSET		16
 #define HDMI_EDID_FLAGS_OFFSET			17
@@ -60,20 +60,24 @@
 #define HDMI_STATE_ON		2 /* HDMI monitor connected and powered on*/
 
 /* HDMI EDID Length */
-#define HDMI_EDID_MAX_LENGTH			512
+#define HDMI_EDID_MAX_LENGTH	512
 
 /* HDMI EDID DTDs */
-#define HDMI_EDID_MAX_DTDS			4
+#define HDMI_EDID_MAX_DTDS		4
 
 /* HDMI EDID DTD Tags */
-#define HDMI_EDID_DTD_TAG_MONITOR_NAME		0xFC
-#define HDMI_EDID_DTD_TAG_MONITOR_SERIALNUM	0xFF
-#define HDMI_EDID_DTD_TAG_MONITOR_LIMITS	0xFD
+#define HDMI_EDID_DTD_TAG_MONITOR_NAME			0xFC
+#define HDMI_EDID_DTD_TAG_MONITOR_SERIALNUM		0xFF
+#define HDMI_EDID_DTD_TAG_MONITOR_LIMITS		0xFD
 #define HDMI_EDID_DTD_TAG_STANDARD_TIMING_DATA	0xFA
-#define HDMI_EDID_DTD_TAG_COLOR_POINT_DATA	0xFB
-#define HDMI_EDID_DTD_TAG_ASCII_STRING		0xFE
+#define HDMI_EDID_DTD_TAG_COLOR_POINT_DATA		0xFB
+#define HDMI_EDID_DTD_TAG_ASCII_STRING			0xFE
 
-#define HDMI_IMG_FORMAT_MAX_LENGTH		20
+/* 5 bits describe the length, which is 32 bytes.
+	1 byte for each Video Data Block */
+#define HDMI_IMG_FORMAT_MAX_LENGTH			0x20
+/* 5 Bits describe the length, which is 32 bytes, we would require 3 bytes per
+	audio data block */
 #define HDMI_AUDIO_FORMAT_MAX_LENGTH		10
 
 /* HDMI EDID Extenion Data Block Values: Video */
@@ -148,6 +152,13 @@
 	DATABLOCK_SPEAKERS = 4,
 };
 
+/* Short Video Descriptor - Refer CEA 861 Spec
+ *	code indicates the Video Identification Code, that defines the
+ *	resolution.
+ *	pref - when set indicates resolution specified in code is native to the
+ *		sink. A native format is one, that a sink can support with any
+ *		processing.
+ */
 struct img_edid {
 	__u8 pref;
 	__u32 code;
@@ -159,8 +170,13 @@
 };
 
 struct audio_edid {
-	__u32 num_of_ch;
-	__u32 format;
+	__u32 num_of_ch; /* Number of channels */
+	__u32 format;	/* 1 - Linear PCM (IEC 60985) */
+	__u32 freq; /* Frequency / Sample rate
+			1 - 32 KHz, 2 - 44.1 KHz, 4 - 48 KHz,
+			8 - 88.2 KHz, 16 - 96 KHz, 32 - 176.4 KHz,
+			64 - 192 KHz */
+	__u32 width; /* Sample width 1 - 16 bits, 2 - 20 bits, 4 - 24 bits */
 };
 
 struct audio_format {
@@ -261,7 +277,22 @@
 	__u8	timing_1;		/* 35 */
 	__u8	timing_2;		/* 36 */
 	__u8	timing_3;		/* 37 */
+/* Refer
+ *	VESA ENHANCED EXTENDED DISPLAY
+ *	IDENTIFICATION DATA STANDARD
+ *	(Defines EDID Structure Version 1, Revision 4)
+ *	To decode values present in timing_1, timing_2 & timing_3
+ *	Table 3.18 - Established Timings I & II
+ */
+
 	__u8	std_timings[16];	/* 38-53 */
+/* Refer
+ *	VESA ENHANCED EXTENDED DISPLAY
+ *	IDENTIFICATION DATA STANDARD
+ *	(Defines EDID Structure Version 1, Revision 4)
+ *	To decode values present in std_timings
+ *	Table 3.19 - Standard Timings
+ */
 
 	union HDMI_EDID_DTD DTD[4];	/* 54-125 */
 
@@ -289,6 +320,6 @@
 void hdmi_get_av_delay(__u8 *edid, struct latency *lat);
 void hdmi_deep_color_support_info(__u8 *edid, struct deep_color *format);
 __u32 hdmi_tv_yuv_supported(__u8 *edid);
-bool hdmi_tv_hdmi_supported(__u8 *edid);
-bool hdmi_tv_cec_get_pa(__u8 *edid, __u8 *pa);
+_Bool hdmi_tv_hdmi_supported(__u8 *edid);
+_Bool hdmi_tv_cec_get_pa(__u8 *edid, __u8 *pa);
 #endif
Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/net_switch_config.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/include/linux/net_switch_config.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/net_switch_config.h	2014-08-07 11:51:55.322748556 -0600
@@ -116,7 +116,7 @@
 		struct net_switch_prio_cmd priocmd;
 		char buf[4096];		/* Buffer for Ale Dump */
 	} cmd_data;
-	unsigned int ret_type;   /* Return  Success/Failure */
+	int ret_type;   /* Return  Success/Failure */
 };
 
 #endif /* __NET_CONFIG_SWITCH_H__*/
Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/ti81xxhdmi.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/include/linux/ti81xxhdmi.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/ti81xxhdmi.h	2014-08-07 11:51:55.338748555 -0600
@@ -18,14 +18,29 @@
  * Author: Sujith Shivalingappa <sujith.s@ti.com>
  *	: Varada Bellary <varadab@ti.com>, modified for new version (Mar 2011)
  *			of driver.
- *	: Sujith Shivalingappa <sujith.s@ti.com>, added CEC support
+ *	: Sujith Shivalingappa <sujith.s@ti.com>, added CEC support.
+ *	: Sujith Shivalingappa <sujith.s@ti.com>, added HDCP support.
  */
 
 #ifndef __TI81XXHDMI_H__
 #define __TI81XXHDMI_H__
 
-
+#include <linux/types.h>
 #include <linux/ioctl.h>
+#include <linux/edid.h>
+
+/* HDCP state
+	When application query status of HDCP using IOCTL
+	TI81XXHDMI_HDCP_GET_STATUS, depending on state of HDCP, one of the
+	following values would be returned to applications. */
+#define HDCP_STATE_DISABLED			0
+#define HDCP_STATE_INIT				1
+#define HDCP_STATE_AUTH_1ST_STEP		2
+#define HDCP_STATE_AUTH_2ND_STEP		3
+#define HDCP_STATE_AUTH_3RD_STEP		4
+#define HDCP_STATE_AUTH_FAIL_RESTARTING		5
+#define HDCP_STATE_AUTH_FAILURE			6
+
 
 /* IOCTL definitions */
 #define TI81XXHDMI_MAGIC            'N'
@@ -39,10 +54,14 @@
 #define TI81XXHDMI_STOP			TI81XXHDMI_IO(1)
 #define TI81XXHDMI_GET_STATUS		TI81XXHDMI_IOR(2, unsigned char *)
 #define TI81XXHDMI_READ_EDID		TI81XXHDMI_IOR(3, unsigned char *)
-/*#define
- * TI81XXHDMI_READ_EDID TI81XXHDMI_IOR(3, struct ti81xxdhmi_edid_params)
- */
 
+/* Used get the parsed EDID information of the connected sink.
+ * Takes in a argument of type struct ti81xxhdmi_sink_edid_parsed.
+ *
+ * Ensure the sink EDID is explictly read by calling IOCTL TI81XXHDMI_READ_EDID
+ */
+#define TI81XXHDMI_GET_PARSED_EDID_INFO		TI81XXHDMI_IOWR(4, \
+					struct ti81xxhdmi_sink_edid_parsed *)
 /*
  * Used to enable the CEC block of HDMI.
  * Before CEC messages could be read / written OR registered, CEC block has to
@@ -58,7 +77,7 @@
 
 /* Used to read the received messages, for both unicast or broadcast messages
  * Takes in an argument of type struct ti81xxhdmi_cec_received_msg.
- * An return value of EAGAIN, indicates that are no messages received, try
+ * An error value of EAGAIN, indicates that are no messages received, try
  * later
  */
 #define TI81XXHDMI_CEC_RECEIVE_MSG	TI81XXHDMI_IOR(7, unsigned char *)
@@ -68,56 +87,155 @@
  */
 #define TI81XXHDMI_CEC_TRANSMIT_MSG	TI81XXHDMI_IOWR(8, unsigned char *)
 
-/* This ioctl waits till HPD event is detected. Once HPD event is detected,
-* application can re-negotiate audio and video format with new sink.
-*/
-#define TI81XXHDMI_WAIT_FOR_HPD_CHANGE TI81XXHDMI_IOR(15, unsigned char *)
+/* Used to enable HDCP.
+ * Takes in a argument of type ti81xxhdmi_hdcp_ena_ctrl. Note that all devices
+ * need not support HDCP. In case HDCP is not supported, an error value of
+ * ENODEV if returned.
+ *
+ * Use this command only when hdmi is streaming video to a sink
+ */
+#define TI81XXHDMI_HDCP_ENABLE		TI81XXHDMI_IOW(9, \
+					struct ti81xxhdmi_hdcp_ena_ctrl)
+
+/* Used to disable HDCP process.
+ * Applicable only when HDCP_ENABLE was called / HDCP autentication was in
+ * progress.
+ */
+#define TI81XXHDMI_HDCP_DISABLE		TI81XXHDMI_IOW(10, unsigned char *)
+
+/* Used to query the current step / status of HDCP process.
+ * Returns one of the values defined below under "HDCP State". Takes in a
+ * argument of type __u32
+ */
+#define TI81XXHDMI_HDCP_GET_STATUS	TI81XXHDMI_IOWR(11, __u32)
+
+/* Used by application to wait for a state of HDCP process.
+ *
+ * Used to wait until Step 1/2 is reached. The application are expected
+ * perform check BKSV / V` computation respectively and let the driver know,
+ * if it can proceed with the autentication.
+ *
+ * This is a blocking call, the caller will be blocked until step 2 is reached.
+ *
+ */
+#define TI81XXHDMI_HDCP_WAIT_EVENT	TI81XXHDMI_IOWR(12, \
+					struct ti81xxhdmi_hdcp_wait_ctrl)
+
+/* Used by application to let the driver know if it can proceed with the
+ * autentication process.
+ *
+ * The application let the driver know, when BKSV has been verified, as a
+ * to event TI81XXHDMI_HDCP_EVENT_STEP1 and V` has been computed for
+ * TI81XXHDMI_HDCP_EVENT_STEP2. This will enable the driver to proceed with
+ * autentication or not.
+ *
+ * The argument should be
+ * In case of success 0x0 | TI81XXHDMI_HDCP_EVENT_STEP2
+ * In case of failures -1 | TI81XXHDMI_HDCP_EVENT_STEP2
+ * In the case of error, the driver would try to re-autenticate. If the number
+ * of re-trys is exceeded. Autentication failure state would be entered.
+ *
+ * In case of success 0x0 | TI81XXHDMI_HDCP_EVENT_STEP1
+ * In case of failures -1 | TI81XXHDMI_HDCP_EVENT_STEP1
+ * In the case of error, the driver would try to re-autenticate. If the number
+ * of re-trys is exceeded. Autentication failure state would be entered.
+ */
+#define TI81XXHDMI_HDCP_EVENT_DONE	TI81XXHDMI_IOWR(14, __u32)
 
-/* Use this command only when hdmi is streaming video to a sink */
 /* TODO Not supported for now */
 #if 0
 #define TI81XX_HDMI_SET_MODE	TI81XX_HDMI_IOW(6, enum ti81xxhdmi_mode)
 #define TI81XX_HDMI_GET_MODE	TI81XX_HDMI_IOR(7, enum ti81xxhdmi_mode)
 #endif
 
-
-
+/* HDCP events
+ * Events that application could wait on and let the driver know if driver
+ * could proceed to next step of autentication.
+ */
+#define TI81XXHDMI_HDCP_EVENT_STEP1		(1 << 0x0)
+#define TI81XXHDMI_HDCP_EVENT_STEP2		(1 << 0x1)
+#define TI81XXHDMI_HDCP_EVENT_EXIT		(1 << 0x2)
+
+/*Local Macros */
+#define HDMI_MAX_DETAILED_TIMINGS	(EDID_SIZE_BLOCK0_TIMING_DESCRIPTOR + \
+					EDID_SIZE_BLOCK1_TIMING_DESCRIPTOR)
 struct ti81xxhdmi_status {
 	unsigned int is_hpd_detected;
 	unsigned int is_hdmi_streaming;
 };
 
-/* Below are various HPD status. */
-/* HPD status is modified */
-#define TI81XXHDMI_HPD_MODIFY		0x04
-/* First HPD detected after inserting HDMI */
-#define TI81XXHDMI_FIRST_HPD		0x08
-/* HPD modified to low */
-#define TI81XXHDMI_HPD_LOW		0x10
-/* Same as HPD_MODIFY but HPD_low and HPD high occured very fast. Sequence will
-be something like this.
-HPD_MODIFY
-HPD_LOW
-HPD_HIGH
-In above sequence MODIFY-->LOW-->HIGH occur in quick succession, like debouce
-effect */
-#define TI81XXHDMI_HPD_HIGH		0x20
-/* Below Two will not be seen by application */
-#define TI81XXHDMI_BCAP			0x40
-#define TI81XXHDMI_RI_ERR		0x80
-
-struct ti81xxhdmi_hpd_status {
-	/* This status says whether HPD occured or not. This is to
-	   protect against the debouce and first HDP We make sure
-	   here that debouce effect is nullified using some timer
-	   value Valid values are above defined HPD status*/
-	unsigned int hpd_status;
-	/* This is status of actual HPD pin, it will be 1 on HPD connect
-	   else 0 on HPD disconnect */
-	unsigned int hpd_pin_status;
-	unsigned int rsen_pin_status;
+struct ti81xxhdmi_sink_edid_parsed {
+
+	/* Specifies the sinks EDID version */
+	__u8 version;
+	/* Specifies the sinks EDID revision */
+	__u8 revision;
+
+	/* Specifies if the connected sink supports HDMI or DVI interface.
+		0 - Indicates DVI interface
+		1 - Indicates HDMI interface
+		In case of DVI mode num_dt, supported_cea_vic, audio_support &
+			is_yuv_supported of this strucutre is in-valid. */
+	__u8 is_hdmi_supported;
+
+	/* Estabilished Video Timings.
+			VESA ENHANCED EXTENDED DISPLAY
+			IDENTIFICATION DATA STANDARD
+			(Defines EDID Structure Version 1, Revision 4)
+			To decode values present in timing_1, timing_2 &
+			timing_3
+		Table 3.18 - Established Timings I & II
+	 */
+	__u8 established_timings[3];
+
+	/* Estabilished Video Timings.
+			VESA ENHANCED EXTENDED DISPLAY
+			IDENTIFICATION DATA STANDARD
+			(Defines EDID Structure Version 1, Revision 4)
+			To decode values present in timing_1, timing_2 &
+			timing_3
+		Table 3.18 - Established Timings I & II
+	 */
+	__u8 standard_timings[8];
+
+	/* Detailed Video Timings
+	 * 0 location is the preffered timing as declared by sink in block 0
+	 * 1 location is the next timing as declared by sink in block 0
+	 * 2 - 10 location - defined by detailed timings descriptor - defined in
+	 *			extended blocks
+	 *	EDID_SIZE_BLOCK0_TIMING_DESCRIPTOR + 8,
+	 *  EDID_SIZE_BLOCK0_TIMING_DESCRIPTOR = 4 detailed timings in block 0,
+	 *	2 are mandatory.
+	 *
+	 *	EDID_SIZE_BLOCK1_TIMING_DESCRIPTOR = maximum timings descriptors
+	 *	in block 1
+	 *
+	 *	video_timings is defined in \include\linux\edid.h
+	 */
+	struct video_timings detailed_timings[HDMI_MAX_DETAILED_TIMINGS];
+
+	/* Number of detailed timings descriptors parsed and number of valid
+		detailed_timings entries */
+	__u8 num_dt;
+
+	/* Specifies the video resolutions supported, identified by
+		Video Identification Code as defined in CEA 861 spec.
+
+		struct image_format is defined in \include\linux\edid.h
+	*/
+	struct image_format supported_cea_vic;
+
+	/* Specifies the various audio configurations supported
+		struct audio_format is defined in \include\linux\edid.h */
+	struct audio_format audio_support;
+
+	/* YCbCr is supported is this is non-zero.
+		A value of 1 - indicates YCbCr 422
+		A value of 2 - indicates YCbCr 444 */
+	__u32 is_yuv_supported;
 };
 
+
 /* The following lists the valid device types & logical address on the CEC n/w
 	0 = Logical Address for TV
 	1 = Logical Address for Recorder Device 1
@@ -295,4 +413,33 @@
 	__u32 errors;
 };
 
+/* HDCP Specifics */
+
+/* HDCP key size in 32-bit words */
+#define DESHDCP_KEY_SIZE 		160
+#define MAX_SHA_DATA_SIZE		645
+#define MAX_SHA_VPRIME_SIZE		20
+
+/* Passed as an argument when enabling HDCP (TI81XXHDMI_HDCP_ENABLE) */
+struct ti81xxhdmi_hdcp_ena_ctrl {
+	/* Specify the number of times autentication should be attempted,
+		before giving up autentication */
+	int nb_retry;
+};
+
+/* Used to receive data from driver, required for V` computation */
+struct hdcp_sha_in {
+	__u8 data[MAX_SHA_DATA_SIZE];
+	__u32 byte_counter;
+	__u8 vprime[MAX_SHA_VPRIME_SIZE];
+};
+
+/* Control strucutre that would be used by application to wait for events.
+	its expected that application initializes the event and
+	member "data" would point to valid memory */
+struct ti81xxhdmi_hdcp_wait_ctrl {
+	__u32 event;
+	struct hdcp_sha_in *data;
+};
+
 #endif /* End of #ifndef __TI81XX_HDMI_H__ */
Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/usb.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/include/linux/usb.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/usb.h	2014-08-07 11:51:55.346748555 -0600
@@ -1379,6 +1379,12 @@
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_free_coherent(struct usb_device *dev, size_t size,
 	void *addr, dma_addr_t dma);
+void *usb_buffer_alloc(struct usb_device *dev, size_t size,
+        gfp_t mem_flags, dma_addr_t *dma);
+void usb_buffer_free(struct usb_device *dev, size_t size,
+        void *addr, dma_addr_t dma);
+
+
 
 #if 0
 struct urb *usb_buffer_map(struct urb *urb);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci.c	2014-08-07 11:51:55.442748550 -0600
@@ -79,8 +79,6 @@
 };
 
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
-static int ahci_sb600_softreset(struct ata_link *link, unsigned int *class,
-			  unsigned long deadline);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
@@ -104,14 +102,6 @@
 	.hardreset		= ahci_p5wdh_hardreset,
 };
 
-static struct ata_port_operations ahci_sb600_ops = {
-	.inherits		= &ahci_ops,
-	.softreset		= ahci_sb600_softreset,
-	.pmp_softreset		= ahci_sb600_softreset,
-};
-
-#define AHCI_HFLAGS(flags)	.private_data	= (void *)(flags)
-
 static const struct ata_port_info ahci_port_info[] = {
 	/* by features */
 	[board_ahci] =
@@ -150,7 +140,7 @@
 	{
 		AHCI_HFLAGS	(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP |
 				 AHCI_HFLAG_YES_NCQ),
-		.flags		= AHCI_FLAG_COMMON,
+		.flags		= AHCI_FLAG_COMMON | ATA_FLAG_NO_DIPM,
 		.pio_mask	= ATA_PIO4,
 		.udma_mask	= ATA_UDMA6,
 		.port_ops	= &ahci_ops,
@@ -189,7 +179,7 @@
 		.flags		= AHCI_FLAG_COMMON,
 		.pio_mask	= ATA_PIO4,
 		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_sb600_ops,
+		.port_ops	= &ahci_pmp_retry_srst_ops,
 	},
 	[board_ahci_sb700] =	/* for SB700 and SB800 */
 	{
@@ -197,7 +187,7 @@
 		.flags		= AHCI_FLAG_COMMON,
 		.pio_mask	= ATA_PIO4,
 		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_sb600_ops,
+		.port_ops	= &ahci_pmp_retry_srst_ops,
 	},
 	[board_ahci_vt8251] =
 	{
@@ -489,55 +479,6 @@
 	ahci_init_controller(host);
 }
 
-static int ahci_sb600_check_ready(struct ata_link *link)
-{
-	void __iomem *port_mmio = ahci_port_base(link->ap);
-	u8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;
-	u32 irq_status = readl(port_mmio + PORT_IRQ_STAT);
-
-	/*
-	 * There is no need to check TFDATA if BAD PMP is found due to HW bug,
-	 * which can save timeout delay.
-	 */
-	if (irq_status & PORT_IRQ_BAD_PMP)
-		return -EIO;
-
-	return ata_check_ready(status);
-}
-
-static int ahci_sb600_softreset(struct ata_link *link, unsigned int *class,
-				unsigned long deadline)
-{
-	struct ata_port *ap = link->ap;
-	void __iomem *port_mmio = ahci_port_base(ap);
-	int pmp = sata_srst_pmp(link);
-	int rc;
-	u32 irq_sts;
-
-	DPRINTK("ENTER\n");
-
-	rc = ahci_do_softreset(link, class, pmp, deadline,
-			       ahci_sb600_check_ready);
-
-	/*
-	 * Soft reset fails on some ATI chips with IPMS set when PMP
-	 * is enabled but SATA HDD/ODD is connected to SATA port,
-	 * do soft reset again to port 0.
-	 */
-	if (rc == -EIO) {
-		irq_sts = readl(port_mmio + PORT_IRQ_STAT);
-		if (irq_sts & PORT_IRQ_BAD_PMP) {
-			ata_link_printk(link, KERN_WARNING,
-					"applying SB600 PMP SRST workaround "
-					"and retrying\n");
-			rc = ahci_do_softreset(link, class, 0, deadline,
-					       ahci_check_ready);
-		}
-	}
-
-	return rc;
-}
-
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline)
 {
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci.h	2014-08-07 11:51:55.446748550 -0600
@@ -195,6 +195,9 @@
 	PORT_FBS_EN		= (1 << 0), /* Enable FBS */
 
 	/* hpriv->flags bits */
+
+#define AHCI_HFLAGS(flags)		.private_data	= (void *)(flags)
+
 	AHCI_HFLAG_NO_NCQ		= (1 << 0),
 	AHCI_HFLAG_IGN_IRQ_IF_ERR	= (1 << 1), /* ignore IRQ_IF_ERR */
 	AHCI_HFLAG_IGN_SERR_INTERNAL	= (1 << 2), /* ignore SERR_INTERNAL */
@@ -210,6 +213,9 @@
 	AHCI_HFLAG_NO_SNTF		= (1 << 12), /* no sntf */
 	AHCI_HFLAG_NO_FPDMA_AA		= (1 << 13), /* no FPDMA AA */
 	AHCI_HFLAG_YES_FBS		= (1 << 14), /* force FBS cap on */
+	AHCI_HFLAG_DELAY_ENGINE		= (1 << 15), /* do not start engine on
+						        port start (wait until
+						        error-handling stage) */
 
 	/* ap->flags bits */
 
@@ -310,6 +316,7 @@
 	.sdev_attrs		= ahci_sdev_attrs
 
 extern struct ata_port_operations ahci_ops;
+extern struct ata_port_operations ahci_pmp_retry_srst_ops;
 
 void ahci_save_initial_config(struct device *dev,
 			      struct ahci_host_priv *hpriv,
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci_platform.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci_platform.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/ahci_platform.c	2014-08-07 11:51:55.450748550 -0600
@@ -23,6 +23,52 @@
 #include <linux/ahci_platform.h>
 #include "ahci.h"
 
+enum ahci_type {
+	AHCI,		/* standard platform ahci */
+	IMX53_AHCI,	/* ahci on i.mx53 */
+	STRICT_AHCI,	/* delayed DMA engine start */
+};
+
+static struct platform_device_id ahci_devtype[] = {
+	{
+		.name = "ahci",
+		.driver_data = AHCI,
+	}, {
+		.name = "imx53-ahci",
+		.driver_data = IMX53_AHCI,
+	}, {
+		.name = "strict-ahci",
+		.driver_data = STRICT_AHCI,
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(platform, ahci_devtype);
+
+
+static const struct ata_port_info ahci_port_info[] = {
+	/* by features */
+	[AHCI] = {
+		AHCI_HFLAGS	(AHCI_HFLAG_DELAY_ENGINE),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_pmp_retry_srst_ops,
+	},
+	[IMX53_AHCI] = {
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+	},
+	[STRICT_AHCI] = {
+		AHCI_HFLAGS	(AHCI_HFLAG_DELAY_ENGINE),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+};
+
 static struct scsi_host_template ahci_platform_sht = {
 	AHCI_SHT("ahci_platform"),
 };
@@ -31,12 +77,8 @@
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev->platform_data;
-	struct ata_port_info pi = {
-		.flags		= AHCI_FLAG_COMMON,
-		.pio_mask	= ATA_PIO4,
-		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_ops,
-	};
+	const struct platform_device_id *id = platform_get_device_id(pdev);
+	struct ata_port_info pi = ahci_port_info[id->driver_data];
 	const struct ata_port_info *ppi[] = { &pi, NULL };
 	struct ahci_host_priv *hpriv;
 	struct ata_host *host;
@@ -46,6 +88,8 @@
 	int i;
 	int rc;
 
+	printk("ahci probe: devid name is %s\n",id->name);
+
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem) {
 		dev_err(dev, "no mmio space\n");
@@ -177,6 +221,7 @@
 		.name = "ahci",
 		.owner = THIS_MODULE,
 	},
+	.id_table	= ahci_devtype,
 };
 
 static int __init ahci_init(void)
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/libahci.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/ata/libahci.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/libahci.c	2014-08-07 11:51:55.462748550 -0600
@@ -82,6 +82,8 @@
 static void ahci_pmp_detach(struct ata_port *ap);
 static int ahci_softreset(struct ata_link *link, unsigned int *class,
 			  unsigned long deadline);
+static int ahci_pmp_retry_softreset(struct ata_link *link, unsigned int *class,
+			  unsigned long deadline);
 static int ahci_hardreset(struct ata_link *link, unsigned int *class,
 			  unsigned long deadline);
 static void ahci_postreset(struct ata_link *link, unsigned int *class);
@@ -177,6 +179,12 @@
 };
 EXPORT_SYMBOL_GPL(ahci_ops);
 
+struct ata_port_operations ahci_pmp_retry_srst_ops = {
+	.inherits		= &ahci_ops,
+	.softreset		= ahci_pmp_retry_softreset,
+};
+EXPORT_SYMBOL_GPL(ahci_pmp_retry_srst_ops);
+
 int ahci_em_messages = 1;
 EXPORT_SYMBOL_GPL(ahci_em_messages);
 module_param(ahci_em_messages, int, 0444);
@@ -379,6 +387,13 @@
 	 * reset.  Values without are used for driver operation.
 	 */
 	hpriv->saved_cap = cap = readl(mmio + HOST_CAP);
+	printk("ahci CAP register dump =0x%x\n", cap);
+	cap |= (1 << 27);
+	writel(cap, mmio + HOST_CAP);
+
+	hpriv->saved_cap = cap = readl(mmio + HOST_CAP);
+	printk("Modified ahci CAP register dump =0x%x\n", cap);
+
 	hpriv->saved_port_map = port_map = readl(mmio + HOST_PORTS_IMPL);
 
 	/* CAP2 register is only defined for AHCI 1.2 and later */
@@ -717,6 +732,7 @@
 
 static void ahci_start_port(struct ata_port *ap)
 {
+	struct ahci_host_priv *hpriv = ap->host->private_data;
 	struct ahci_port_priv *pp = ap->private_data;
 	struct ata_link *link;
 	struct ahci_em_priv *emp;
@@ -729,6 +745,10 @@
 	/* enable DMA */
 	ahci_start_engine(ap);
 
+	/* enable DMA */
+	if (!(hpriv->flags & AHCI_HFLAG_DELAY_ENGINE))
+		ahci_start_engine(ap);
+
 	/* turn on LEDs */
 	if (ap->flags & ATA_FLAG_EM) {
 		ata_for_each_link(link, ap, EDGE) {
@@ -1322,6 +1342,55 @@
 }
 EXPORT_SYMBOL_GPL(ahci_do_softreset);
 
+static int ahci_bad_pmp_check_ready(struct ata_link *link)
+{
+	void __iomem *port_mmio = ahci_port_base(link->ap);
+	u8 status = readl(port_mmio + PORT_TFDATA) & 0xFF;
+	u32 irq_status = readl(port_mmio + PORT_IRQ_STAT);
+
+	/*
+	 * There is no need to check TFDATA if BAD PMP is found due to HW bug,
+	 * which can save timeout delay.
+	 */
+	if (irq_status & PORT_IRQ_BAD_PMP)
+		return -EIO;
+
+	return ata_check_ready(status);
+}
+
+int ahci_pmp_retry_softreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	void __iomem *port_mmio = ahci_port_base(ap);
+	int pmp = sata_srst_pmp(link);
+	int rc;
+	u32 irq_sts;
+
+	DPRINTK("ENTER\n");
+
+	rc = ahci_do_softreset(link, class, pmp, deadline,
+			       ahci_bad_pmp_check_ready);
+
+	/*
+	 * Soft reset fails with IPMS set when PMP is enabled but
+	 * SATA HDD/ODD is connected to SATA port, do soft reset
+	 * again to port 0.
+	 */
+	if (rc == -EIO) {
+		irq_sts = readl(port_mmio + PORT_IRQ_STAT);
+		if (irq_sts & PORT_IRQ_BAD_PMP) {
+			ata_link_printk(link, KERN_WARNING,
+					"applying PMP SRST workaround "
+					"and retrying\n");
+			rc = ahci_do_softreset(link, class, 0, deadline,
+					       ahci_check_ready);
+		}
+	}
+
+	return rc;
+}
+
 static int ahci_hardreset(struct ata_link *link, unsigned int *class,
 			  unsigned long deadline)
 {
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/libata-eh.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/ata/libata-eh.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/ata/libata-eh.c	2014-08-07 11:51:55.466748549 -0600
@@ -3276,6 +3276,7 @@
 	struct ata_eh_context *ehc = &link->eh_context;
 	struct ata_device *dev, *link_dev = NULL, *lpm_dev = NULL;
 	enum ata_lpm_policy old_policy = link->lpm_policy;
+	bool no_dipm = ap->flags & ATA_FLAG_NO_DIPM;
 	unsigned int hints = ATA_LPM_EMPTY | ATA_LPM_HIPM;
 	unsigned int err_mask;
 	int rc;
@@ -3292,7 +3293,7 @@
 	 */
 	ata_for_each_dev(dev, link, ENABLED) {
 		bool hipm = ata_id_has_hipm(dev->id);
-		bool dipm = ata_id_has_dipm(dev->id);
+		bool dipm = ata_id_has_dipm(dev->id) && !no_dipm;
 
 		/* find the first enabled and LPM enabled devices */
 		if (!link_dev)
@@ -3349,7 +3350,8 @@
 
 	/* host config updated, enable DIPM if transitioning to MIN_POWER */
 	ata_for_each_dev(dev, link, ENABLED) {
-		if (policy == ATA_LPM_MIN_POWER && ata_id_has_dipm(dev->id)) {
+		if (policy == ATA_LPM_MIN_POWER && !no_dipm &&
+		    ata_id_has_dipm(dev->id)) {
 			err_mask = ata_dev_set_feature(dev,
 					SETFEATURES_SATA_ENABLE, SATA_DIPM);
 			if (err_mask && err_mask != AC_ERR_DEV) {
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_bootdrv.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_bootdrv.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_bootdrv.c	2014-08-07 11:51:55.490748548 -0600
@@ -36,6 +36,20 @@
 
 #include "ti81xx_pcie_bootdrv.h"
 
+/*
+ * Set this flag to indicate the EP being booted is TI813X and requires PCIe
+ * boot errata of re-init PCIe on EP needs to be applied.
+ *
+ * --> Note that, since the TI813X device come up with same ID as TI814X
+ *  devices, the s/w on RC has no way to distingush between them and only this
+ *  flag will tell so to this boot driver.
+ *
+ *  In short: eprst=1 for TI813X device, else keep 0 (default).
+ */
+static int eprst;
+module_param(eprst, int, 0);
+MODULE_PARM_DESC(eprst, "--> 1 = Trigger reset on TI813X EP and reconfigure as per errata.");
+
 /* PCIe application registers virtual address (mapped to PCI window) */
 #define PCI_REGV(reg)           (reg_virt + reg)
 
@@ -50,19 +64,26 @@
  * TI81XX access ranges. Note that all the addresses below translate to PCIe
  * access.
  */
-static unsigned int reg_phys, reg_virt, reg_len;
-static unsigned int ocmc1_phys, ocmc1_virt, ocmc1_len;
-static unsigned int ddr_phys, ddr_virt, ddr_len;
+
+static unsigned long reg_phys, reg_virt, reg_len;
+static unsigned long ocmc1_phys, ocmc1_virt, ocmc1_len;
+static unsigned long ddr_phys, ddr_virt, ddr_len;
+
+static unsigned long  bar_start[6];
+static unsigned long  bar_len[6];
+static unsigned long  bar_flags[6];
 
 static int ti81xx_pci_major;
 static struct cdev ti81xx_pci_cdev;
 static struct class *ti81xx_pci_class;
 static dev_t ti81xx_dev;
+static unsigned int mode_64bit;
 
 /* List of TI81XX family devices supported by this driver */
 static unsigned int supported_dev_list[] = {
 	TI816X_PCI_DEVICE_ID,
 	TI814X_PCI_DEVICE_ID,
+	TI813X_PCI_DEVICE_ID,
 };
 
 /* These values change depending upon the actual TI81XX device detected */
@@ -83,6 +104,7 @@
  *
  * Returns pointer of pci device structure on success, NULL otherwise.
  */
+
 static struct pci_dev *ti81xx_ep_find_device(unsigned int device_id)
 {
 	struct pci_dev *dev = pci_get_device(TI81XX_PCI_VENDOR_ID,
@@ -116,22 +138,25 @@
  * On TI81XX, BAR0 is hrdwired and hence skipped for inbound configuration and a
  * maximum of 4 inbound translations are allowed for 32-bit BARs.
  *
- * TODO: Add 64-bit addressing support.
  */
-static int ti81xx_ep_setup_bar(u32 bar_num, u32 addr)
-{
-	u32 bar_val, ib_num;
 
-	if ((bar_num == 0) || (bar_num > 4))
-		return -1;
+static int ti81xx_ep_setup_bar(unsigned int bar_num, unsigned int addr)
+{
+	unsigned long bar_val, ib_num;
 
 	ib_num = bar_num - 1;
 
 	bar_val = pci_resource_start(ti81xx_pci_dev, bar_num);
 
 	__raw_writel(0, PCI_REGV(IB_BAR(ib_num)));
-	__raw_writel(bar_val, PCI_REGV(IB_START_LO(ib_num)));
-	__raw_writel(0, PCI_REGV(IB_START_HI(ib_num)));
+	__raw_writel((u32)(bar_val), PCI_REGV(IB_START_LO(ib_num)));
+
+	if (mode_64bit == 1)
+		__raw_writel((u32)(bar_val >> 16 >> 16),
+				PCI_REGV(IB_START_HI(ib_num)));
+	else if (mode_64bit == 0)
+		__raw_writel(0, PCI_REGV(IB_START_HI(ib_num)));
+
 	__raw_writel(addr, PCI_REGV(IB_OFFSET(ib_num)));
 	__raw_writel(bar_num, PCI_REGV(IB_BAR(ib_num)));
 
@@ -141,38 +166,45 @@
 /**
  * ti81xx_pci_get_resources() - Read BARs as set by Host and reserve resources
  *
- * Only reads first 3 BARs. Expects the BAR sizes are already set by the boot
- * ROM on TI81XX EP with minimum sizes as follows:
- * - BAR0 = 4KB
- * - BAR1 = 256KB
- * - BAR2 = 8MB
- *
- * FIXME: Presently this function maps all 3 BARs but in reality we only need to
- * map BAR0 and rest can be relied upon the application (mmap).
  */
 static int ti81xx_pci_get_resources(void)
 {
 	int index;
-	u32  bar_start[3];
-	u32  bar_len[3];
-	u32  bar_flags[3];
+	int i = 0;
+	int max_index = 0;
+	int index_inc = 0;
+	unsigned long  flag_mode = 0;
+
+	flag_mode = (unsigned long) pci_resource_flags(ti81xx_pci_dev, 0);
+	if (flag_mode & IORESOURCE_MEM_64) {
+		dev_info(&ti81xx_pci_dev->dev, "TI81XX working in 64 bit mode\n");
+		max_index = 6;
+		index_inc = 2;
+		mode_64bit = 1;
+	} else {
+		dev_info(&ti81xx_pci_dev->dev, "TI81XX working in 32 bit mode\n");
+		max_index = 3;
+		index_inc = 1;
+		mode_64bit = 0;
+	}
 
 	dev_info(&ti81xx_pci_dev->dev, "BAR Configuration -\n\t   "
 			"Start\t|\tLength\t|\tFlags\n");
-	for (index = 0; index < 3; index++) {
-		bar_start[index] = pci_resource_start(ti81xx_pci_dev, index);
-		bar_len[index] = pci_resource_len(ti81xx_pci_dev, index);
-		bar_flags[index] = pci_resource_flags(ti81xx_pci_dev, index);
 
-		if (bar_flags[index] & IORESOURCE_IO) {
+	for (index = 0, i = 0; index < max_index; index += index_inc, i++) {
+		bar_start[i] = pci_resource_start(ti81xx_pci_dev, index);
+		bar_len[i] = pci_resource_len(ti81xx_pci_dev, index);
+		bar_flags[i] = pci_resource_flags(ti81xx_pci_dev, index);
+
+		if (bar_flags[i] & IORESOURCE_IO) {
 			dev_err(&ti81xx_pci_dev->dev,
 				"This driver does not support PCI IO.\n");
 			return -1;
 		}
-
-		dev_info(&ti81xx_pci_dev->dev, "\t0x%08x\t|\t%d\t|\t0x%08x\n",
-				(int)bar_start[index], (int)bar_len[index],
-				(int)bar_flags[index]);
+		dev_info(&ti81xx_pci_dev->dev, "%d index %d bars\n", index, i);
+		dev_info(&ti81xx_pci_dev->dev, "\t0x%08lx\t|\t0x%08lx\t|\t0x%08lx\n",
+					bar_start[i], bar_len[i],
+								bar_flags[i]);
 	}
 
 	reg_phys = bar_start[0];
@@ -183,14 +215,14 @@
 		return -1;
 	}
 
-	reg_virt = (unsigned int)ioremap_nocache(reg_phys, reg_len);
+	reg_virt = (unsigned long)ioremap_nocache(reg_phys, reg_len);
 	if (!reg_virt) {
 		dev_err(&ti81xx_pci_dev->dev, "Failed remapping registers\n");
 		goto err_regremap;
 	}
 
-	dev_info(&ti81xx_pci_dev->dev, "TI81XX registers mapped to 0x%08x\n",
-			(int)reg_virt);
+	dev_info(&ti81xx_pci_dev->dev, "TI81XX registers mapped to 0x%08lx\n",
+			reg_virt);
 
 	ocmc1_phys = bar_start[1];
 	ocmc1_len = bar_len[1];
@@ -200,14 +232,14 @@
 		goto err_ocmc1res;
 	}
 
-	ocmc1_virt = (unsigned int)ioremap_nocache(ocmc1_phys, ocmc1_len);
+	ocmc1_virt = (unsigned long)ioremap_nocache(ocmc1_phys, ocmc1_len);
 	if (!ocmc1_virt) {
 		dev_err(&ti81xx_pci_dev->dev, "Failed remapping OCMC\n");
 		goto err_ocmc1remap;
 	}
 
-	dev_info(&ti81xx_pci_dev->dev, "TI81XX OCMC mapped to 0x%08x\n",
-			(int)ocmc1_virt);
+	dev_info(&ti81xx_pci_dev->dev, "TI81XX OCMC mapped to 0x%08lx\n",
+			ocmc1_virt);
 
 	ddr_phys = bar_start[2];
 	ddr_len = bar_len[2];
@@ -217,14 +249,14 @@
 		goto err_ramres;
 	}
 
-	ddr_virt = (unsigned int)ioremap_nocache(ddr_phys, ddr_len);
+	ddr_virt = (unsigned long)ioremap_nocache(ddr_phys, ddr_len);
 	if (!ddr_virt) {
 		dev_err(&ti81xx_pci_dev->dev, "Failed remapping RAM\n");
 		goto err_ramremap;
 	}
 
-	dev_info(&ti81xx_pci_dev->dev, "TI81XX DDR mapped to 0x%08x\n",
-			(int)ddr_virt);
+	dev_info(&ti81xx_pci_dev->dev, "TI81XX DDR mapped to 0x%08lx\n",
+			ddr_virt);
 
 	return 0;
 err_ramremap:
@@ -250,6 +282,7 @@
  * boot operation and this may be skipped. It is advisable to retain some of the
  * other configurations this function does though.
  */
+
 static void ti81xx_pci_set_master(void)
 {
 	s32   ret_val ;
@@ -279,6 +312,7 @@
  * Complete flag written/read in TI816X/TI814X device's OCMC RAM by this driver
  * as well as the boot ROM and U-Boot running on the EP device.
  */
+
 long ti81xx_pcie_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	int ret = 0 ;
@@ -333,16 +367,20 @@
 	{
 		struct ti81xx_bar_info *bar
 			= (struct ti81xx_bar_info *) arg;
-
 		bar->addr = pci_resource_start(ti81xx_pci_dev, bar->num);
 		bar->size = pci_resource_len(ti81xx_pci_dev, bar->num);
+		bar->mode = mode_64bit;
 	}
 
 	break;
 
 	case TI81XX_PCI_GET_DEVICE_ID:
 		*(unsigned int *) arg = pci_device_id;
-		break;
+	break;
+
+	case TI81XX_PCI_GET_BOOT_INFO:
+		*(unsigned int *) arg = __raw_readl(reg_virt + GPR0);
+	break;
 
 	default:
 		ret = -1;
@@ -372,17 +410,17 @@
  * the host code. One way to achieve this is to use ioctl
  * TI81XX_PCI_GET_BAR_INFO.
  */
+
 int ti81xx_ep_pcie_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	int ret = -EINVAL;
 	unsigned long sz = vma->vm_end - vma->vm_start;
-	unsigned int addr = (unsigned int)vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long addr = (unsigned long)vma->vm_pgoff << PAGE_SHIFT;
 
-	dev_info(&ti81xx_pci_dev->dev, "Mapping %#lx bytes from address %#x\n",
+	dev_info(&ti81xx_pci_dev->dev, "Mapping %#lx bytes from address %#lx\n",
 			sz, addr);
-
-	if (is_in_ocmc1(addr, (unsigned int)sz)
-		|| is_in_ddr(addr, (unsigned int)sz)) {
+	if (is_in_ocmc1(addr, sz)
+			|| is_in_ddr(addr, sz)) {
 		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
 		ret = remap_pfn_range(vma, vma->vm_start,
@@ -413,6 +451,7 @@
  * TI814X EP detected. The sequence is to first search for TI816X devices and if
  * none found, search for TI814X endpoint.
  */
+
 static int __init ti81xx_ep_pci_init(void)
 {
 	int ret, val, i;
@@ -439,6 +478,7 @@
 	/* Set up device related parameters for actual TI81XX device */
 	switch (pci_device_id) {
 	case TI814X_PCI_DEVICE_ID:
+	case TI813X_PCI_DEVICE_ID:
 		bootflag_offset = TI814X_EP_BOOTFLAG_OFFSET;
 		bar1_ib_offset = TI814X_EP_UBOOT_STG1_IB_OFFSET;
 		break;
@@ -506,14 +546,101 @@
 	}
 
 	/* Set up default inbound access windows */
-	ti81xx_ep_setup_bar(1, bar1_ib_offset);
-	ti81xx_ep_setup_bar(2, TI81XX_EP_KERNEL_IB_OFFSET);
+	/* decided at run time after query mode of operation 32/64 bit */
+	if (mode_64bit == 1) {
+		ti81xx_ep_setup_bar(2, bar1_ib_offset);
+		ti81xx_ep_setup_bar(4, TI81XX_EP_KERNEL_IB_OFFSET);
+	}
+	if (mode_64bit == 0) {
+		ti81xx_ep_setup_bar(1, bar1_ib_offset);
+		ti81xx_ep_setup_bar(2, TI81XX_EP_KERNEL_IB_OFFSET);
+	}
 
 	/* Enable inbound translation */
 	val = __raw_readl(PCI_REGV(CMD_STATUS));
 	val |= IB_XLAT_EN_VAL;
 	__raw_writel(val, PCI_REGV(CMD_STATUS));
 
+	/*
+	 * Actually, this should only be done for TI813X but due to a bug, the
+	 * device ID is same as TI814X so we force this even for TI814X.
+	 *
+	 * XXX: Some initialization is repeated below to account for reset and
+	 * it could look better by restructuring (moving to some functions) the
+	 * code above to avoid repeating blocks of code but it is for later as
+	 * this anyway is a hack only applicable for TI813X using PCIe ROM boot
+	 * method.
+	 *
+	 * Note that this block will be skipped for TI813X devices using PCIe
+	 * boot through U-Boot since it sets the device ID correctly for TI813X
+	 * device and the check below will fail.
+	 */
+	if ((eprst == 1) && (pci_device_id == TI814X_PCI_DEVICE_ID)) {
+		int i;
+		unsigned short devid;
+		unsigned int usec_loops = 100;
+
+		/* Do writes as per TI813X errata */
+		__raw_writel(0x22C3d, ocmc1_virt + 0x1CF84);
+		__raw_writel(0x12345678, ocmc1_virt + 0x1B7FC);
+
+		mdelay(10);
+
+		/* Allow EP to come up again */
+		do {
+			pci_read_config_word(ti81xx_pci_dev, PCI_DEVICE_ID,
+					&devid);
+			if (!usec_loops) {
+				dev_err(&ti81xx_pci_dev->dev, "TI813X device "
+						"access timed out, quit\n");
+				goto err_post_cdev;
+			}
+			usec_loops--;
+			udelay(1);
+		} while (devid != TI814X_PCI_DEVICE_ID);
+
+		ret = pci_enable_device(ti81xx_pci_dev);
+		if (ret) {
+			dev_err(&ti81xx_pci_dev->dev,
+					"Failed to enable device.\n");
+			goto err_post_cdev;
+		}
+
+		for (i = 0; i < 6; i++) {
+			pci_write_config_dword(ti81xx_pci_dev,
+					PCI_BASE_ADDRESS_0 + (4 * i),
+					bar_start[i]);
+
+			if (mode_64bit) {
+				unsigned int val = bar_start[i] >> 16 >> 16;
+				i++;
+				pci_write_config_dword(ti81xx_pci_dev,
+						PCI_BASE_ADDRESS_0 + (4 * i),
+						val);
+			}
+		}
+
+		ti81xx_pci_set_master();
+
+		/*
+		 * Set up default inbound access windows - decided at run time
+		 * after query mode of operation 32/64 bit
+		 */
+		if (mode_64bit == 1) {
+			ti81xx_ep_setup_bar(2, bar1_ib_offset);
+			ti81xx_ep_setup_bar(4, TI81XX_EP_KERNEL_IB_OFFSET);
+		}
+		if (mode_64bit == 0) {
+			ti81xx_ep_setup_bar(1, bar1_ib_offset);
+			ti81xx_ep_setup_bar(2, TI81XX_EP_KERNEL_IB_OFFSET);
+		}
+
+		/* Enable inbound translation */
+		val = __raw_readl(PCI_REGV(CMD_STATUS));
+		val |= IB_XLAT_EN_VAL;
+		__raw_writel(val, PCI_REGV(CMD_STATUS));
+	}
+
 	return 0 ;
 
 err_post_cdev:
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_bootdrv.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_bootdrv.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_bootdrv.h	2014-08-07 11:51:55.498748548 -0600
@@ -27,11 +27,12 @@
 /*
  * These are the default PCI IDs for TI816X/TI814X device. Update these as
  * applicable or add Subsystem IDs and corresponding check in the code if you
- * have multiple TI816X/TI814X based PCIe cards.
+ * have multiple TI816X/TI814X/TI813X based PCIe cards.
  */
 #define TI81XX_PCI_VENDOR_ID               0x104c
 #define TI816X_PCI_DEVICE_ID               0xb800
 #define TI814X_PCI_DEVICE_ID               0xb801
+#define TI813X_PCI_DEVICE_ID               0xb802
 
 /*
  * NOTE: Most of the addresses/offsets listed in subsequent sections are not
@@ -133,6 +134,7 @@
 #define IB_START_LO(x)			(0x304 + (0x10 * x))
 #define IB_START_HI(x)			(0x308 + (0x10 * x))
 #define IB_OFFSET(x)			(0x30c + (0x10 * x))
+#define GPR0				0x70
 
 /* Application command register values */
 #define DBI_CS2_EN_VAL			BIT(5)
@@ -145,13 +147,17 @@
  * @num: BAR register index - 0 to 5
  * @addr: For 'SET' operations, contains ti816x internal address to translate
  * @size: Size allocated for this BAR (only usd for GET operation)
+ * @mode: mode of operation of PCIE core in ti81xx i.e. 32/64 bit.
  * this BAR access to. For 'GET'' operations, contains the (host) physical
  * address assigned to this BAR.
+ * in case of 64 bit BARS.
+ * @num: 0, 2 or 4. ( region 0, region 2, region 4).
  */
 struct ti81xx_bar_info {
-	u32 num;
-	u32 addr;
+	u32  num;
+	unsigned long addr;
 	u32 size;
+	u32 mode;
 };
 
 /* IOCTLs defined for the application as well as driver */
@@ -159,5 +165,6 @@
 #define TI81XX_PCI_SET_BAR_WINDOW	_IOW('P', 2, unsigned int)
 #define TI81XX_PCI_GET_BAR_INFO		_IOWR('P', 3, unsigned int)
 #define TI81XX_PCI_GET_DEVICE_ID	_IOR('P', 4, unsigned int)
+#define TI81XX_PCI_GET_BOOT_INFO	_IOR('P', 5, unsigned int)
 
 #endif
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_epdrv.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_epdrv.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/char/ti81xx_pcie_epdrv.c	2014-08-07 11:51:55.498748548 -0600
@@ -855,7 +855,7 @@
 	int i = 0;
 	while (i <= 1500) {
 		if (__raw_readl(reg_vir + MSI0_IRQ_STATUS) != 0) {
-			if (device_id == 0xb801)
+			if (device_id >= 0xb801)
 				__raw_writel(0xFFFFFFFF,
 					reg_vir + MSI0_IRQ_STATUS);
 			if (device_id == 0xb800)
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/multicore_ipc/multiproc.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/multicore_ipc/multiproc.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/multicore_ipc/multiproc.c	2014-08-07 11:51:55.510748547 -0600
@@ -133,7 +133,8 @@
 		else if (cpu_is_omap443x())
 			src = &(omap4_multiproc_state.def_cfg);
 		else if (cpu_is_dm385())
-			src = &(ti813x_multiproc_state.def_cfg);
+			src = &(ti81xx_multiproc_state.def_cfg);
+//			src = &(ti813x_multiproc_state.def_cfg);
 		else if (cpu_is_ti816x() || cpu_is_ti814x())
 			src = &(ti81xx_multiproc_state.def_cfg);
 		else
@@ -164,7 +165,8 @@
 		else if	(cpu_is_omap443x())
 			multiproc_module = &omap4_multiproc_state;
 		else if (cpu_is_dm385())
-			multiproc_module = &ti813x_multiproc_state;
+			multiproc_module = &ti81xx_multiproc_state;
+//			multiproc_module = &ti813x_multiproc_state;
 		else if (cpu_is_ti816x() || cpu_is_ti814x())
 			multiproc_module = &ti81xx_multiproc_state;
 		else {
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/notify_shmdriver/notify_shm_drv.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/notify_shmdriver/notify_shm_drv.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/notify_shmdriver/notify_shm_drv.c	2014-08-07 11:51:55.514748547 -0600
@@ -186,7 +186,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_get_config failed! "
+		printk(KERN_DEBUG "notify_shm_drv_get_config failed! "
 			"status = 0x%x", status);
 	}
 	return;
@@ -246,7 +246,7 @@
 				omap_mbox_get("dsp", &omap_notify_nb);
 			if ((notify_shm_drv_state.mbox_handle[rproc_id] == \
 				NULL)) {
-				printk(KERN_ERR \
+				printk(KERN_DEBUG \
 					"Failed in omap_mbox_get(dsp)\n");
 				status = NOTIFY_E_INVALIDSTATE;
 				goto error_mailbox_get_failed;
@@ -274,7 +274,7 @@
 				== NULL)  \
 			    || (notify_shm_drv_state.mbox_handle[rproc_id] \
 				== NULL)) {
-				printk(KERN_ERR  \
+				printk(KERN_DEBUG  \
 					"Failed in omap_mbox_get(ducati)\n");
 				status = NOTIFY_E_INVALIDSTATE;
 				goto error_mailbox_get_failed;
@@ -295,7 +295,7 @@
 				omap_mbox_get("mailbox-1", &omap_notify_nb);
 
 			if (!notify_shm_drv_state.mbox_handle[rproc_id]) {
-				printk(KERN_ERR \
+				printk(KERN_DEBUG \
 					"Failed in omap_mbox_get(tesla)\n");
 				status = NOTIFY_E_INVALIDSTATE;
 				goto error_mailbox_get_failed;
@@ -309,24 +309,32 @@
 	} else if (cpu_is_ti81xx()) {
 		u16 rproc_id = multiproc_get_id("DSP");
 		/* Initialize the maibox module for dsp, videom3 and vpssm3 */
-		if ((notify_shm_drv_state.mbox_handle[rproc_id] == NULL)) {
-			notify_shm_drv_state.mbox_handle[rproc_id] = \
-				omap_mbox_get("mailbox-dsp",
-						&ti81xx_dsp_notify_nb);
-
-			if ((notify_shm_drv_state.mbox_handle[rproc_id] \
-				== NULL)) {
-				printk(KERN_ERR "Failed in omap_mbox_get"
-						"(mailbox-dsp)\n");
-				status = NOTIFY_E_INVALIDSTATE;
-				goto error_mailbox_get_failed;
-			}
+                if (rproc_id != MULTIPROC_INVALIDID) {
+			if (notify_shm_drv_state.mbox_handle[rproc_id]
+			    == NULL) {
+				notify_shm_drv_state.mbox_handle[rproc_id] =
+					omap_mbox_get("mailbox-dsp",
+					              &ti81xx_dsp_notify_nb);
+
+				if (notify_shm_drv_state.mbox_handle[rproc_id]
+				    == NULL) {
+					printk(KERN_DEBUG
+					       "Failed in omap_mbox_get"
+					       "(mailbox-dsp)\n");
+					status = NOTIFY_E_INVALIDSTATE;
+					goto error_mailbox_get_failed;
+				}
 
 #if 0
-			((struct omap_mbox *)notify_shm_drv_state. \
-				mbox_handle[rproc_id])->rxq->callback = \
-				(int (*)(void *))notify_shmdrv_dsp_isr;
+				((struct omap_mbox *)notify_shm_drv_state.
+					mbox_handle[rproc_id])->rxq->callback =
+					(int (*)(void *))notify_shmdrv_dsp_isr;
 #endif
+			}
+		}
+		else {
+			printk(KERN_INFO "notify_shm_drv: no DSP present "
+                               "(MULTIPROC_INVALIDID)\n");
 		}
 
 		rproc_id = multiproc_get_id("VIDEO-M3");
@@ -338,7 +346,7 @@
 
 			if ((notify_shm_drv_state.mbox_handle[rproc_id] \
 				== NULL)) {
-				printk(KERN_ERR  \
+				printk(KERN_DEBUG  \
 					"Failed in omap_mbox_get(" \
 					"mailbox-video)\n");
 				status = NOTIFY_E_INVALIDSTATE;
@@ -360,7 +368,7 @@
 
 			if ((notify_shm_drv_state.mbox_handle[rproc_id] \
 				== NULL)) {
-				printk(KERN_ERR  \
+				printk(KERN_DEBUG  \
 					"Failed in omap_mbox_get(" \
 					"mailbox-vpss)\n");
 				status = NOTIFY_E_INVALIDSTATE;
@@ -383,7 +391,7 @@
 error_exit:
 	atomic_set(&(notify_shm_drv_state.ref_count),
 			NOTIFYSHMDRIVER_MAKE_MAGICSTAMP(0));
-	printk(KERN_ERR "notify_shm_drv_setup failed! status = 0x%x", status);
+	printk(KERN_DEBUG "notify_shm_drv_setup failed! status = 0x%x", status);
 	return status;
 }
 EXPORT_SYMBOL(notify_shm_drv_setup);
@@ -449,9 +457,11 @@
 	} else if (cpu_is_ti81xx()) {
 		/* Finalize the maibox module for DSP */
 		rproc_id =  multiproc_get_id("DSP");
-		omap_mbox_put(((struct omap_mbox *)notify_shm_drv_state. \
-			mbox_handle[rproc_id]), &ti81xx_dsp_notify_nb);
-		notify_shm_drv_state.mbox_handle[rproc_id] = NULL;
+		if (rproc_id != MULTIPROC_INVALIDID) {
+			omap_mbox_put((struct omap_mbox *)notify_shm_drv_state.
+				mbox_handle[rproc_id], &ti81xx_dsp_notify_nb);
+			notify_shm_drv_state.mbox_handle[rproc_id] = NULL;
+		}
 
 		/* Finalize the maibox module for Video m3*/
 		rproc_id =  multiproc_get_id("VIDEO-M3");
@@ -472,7 +482,7 @@
 	}
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_destroy failed! "
+		printk(KERN_DEBUG "notify_shm_drv_destroy failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -502,7 +512,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_params_init failed! "
+		printk(KERN_DEBUG "notify_shm_drv_params_init failed! "
 			"status = 0x%x", status);
 	}
 	return;
@@ -725,7 +735,7 @@
 	/* Leave critical section protection. */
 	mutex_unlock(notify_shm_drv_state.gate_handle);
 exit:
-	printk(KERN_ERR "notify_shm_drv_create failed! status = 0x%x",
+	printk(KERN_DEBUG "notify_shm_drv_create failed! status = 0x%x",
 		status);
 	return NULL;
 }
@@ -796,7 +806,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_delete failed! "
+		printk(KERN_DEBUG "notify_shm_drv_delete failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -896,7 +906,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_register_event failed! "
+		printk(KERN_DEBUG "notify_shm_drv_register_event failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -991,7 +1001,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_unregister_event failed! "
+		printk(KERN_DEBUG "notify_shm_drv_unregister_event failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -1144,7 +1154,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_sendevent failed! "
+		printk(KERN_DEBUG "notify_shm_drv_sendevent failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -1191,7 +1201,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_disable failed! "
+		printk(KERN_DEBUG "notify_shm_drv_disable failed! "
 			"status = 0x%x", status);
 	}
 	/*No flags to be returned. */
@@ -1240,7 +1250,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_enable failed! "
+		printk(KERN_DEBUG "notify_shm_drv_enable failed! "
 			"status = 0x%x", status);
 	}
 	return;
@@ -1347,7 +1357,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_disable_event failed! "
+		printk(KERN_DEBUG "notify_shm_drv_disable_event failed! "
 			"status = 0x%x", status);
 	}
 	return;
@@ -1405,7 +1415,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_enable_event failed! "
+		printk(KERN_DEBUG "notify_shm_drv_enable_event failed! "
 			"status = 0x%x", status);
 	}
 	return;
@@ -1444,7 +1454,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_shm_drv_shared_mem_req failed!"
+		printk(KERN_DEBUG "notify_shm_drv_shared_mem_req failed!"
 			" status = 0x%x", status);
 	}
 	return mem_req;
@@ -1483,11 +1493,13 @@
 								void *ntfy_msg)
 {
 	/* Decode the msg to identify the processor that has sent the message */
-	u32 proc_id;
+	u16 proc_id;
 	proc_id = multiproc_get_id("DSP");
-	/* Call the corresponding prpc_id callback */
-	notify_shmdrv_isr_callback(notify_shm_drv_state.driver_handles
-		[proc_id][0], ntfy_msg);
+	if (proc_id != MULTIPROC_INVALIDID) {
+		/* Call the corresponding prpc_id callback */
+		notify_shmdrv_isr_callback(notify_shm_drv_state.driver_handles
+			[proc_id][0], ntfy_msg);
+	}
 	return 0;
 }
 EXPORT_SYMBOL(notify_shmdrv_dsp_isr);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/omap_notify/notify.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/omap_notify/notify.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/omap_notify/notify.c	2014-08-07 11:51:55.514748547 -0600
@@ -71,7 +71,7 @@
 
 exit:
 	if (retval < 0) {
-		printk(KERN_ERR "notify_get_config failed! status = 0x%x",
+		printk(KERN_DEBUG "notify_get_config failed! status = 0x%x",
 			retval);
 	}
 	return;
@@ -140,7 +140,7 @@
 	kfree(notify_state.gate_handle);
 exit:
 	atomic_set(&notify_state.ref_count, NOTIFY_MAKE_MAGICSTAMP(0));
-	printk(KERN_ERR "notify_setup failed! status = 0x%x", status);
+	printk(KERN_DEBUG "notify_setup failed! status = 0x%x", status);
 	return status;
 }
 EXPORT_SYMBOL(notify_setup);
@@ -179,7 +179,8 @@
 
 exit:
 	if (status < 0)
-		printk(KERN_ERR "notify_destroy failed! status = 0x%x", status);
+		printk(KERN_DEBUG "notify_destroy failed! status = 0x%x",
+			status);
 	return status;
 }
 EXPORT_SYMBOL(notify_destroy);
@@ -245,7 +246,8 @@
 	obj = NULL;
 exit:
 	if (status < 0)
-		printk(KERN_ERR "notify_create failed! status = 0x%x", status);
+		printk(KERN_DEBUG "notify_create failed! status = 0x%x",
+			status);
 	return obj;
 }
 
@@ -289,7 +291,8 @@
 
 exit:
 	if (status < 0)
-		printk(KERN_ERR "notify_delete failed! status = 0x%x", status);
+		printk(KERN_DEBUG "notify_delete failed! status = 0x%x",
+			status);
 	return status;
 }
 
@@ -471,7 +474,7 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_register_event failed! "
+		printk(KERN_DEBUG "notify_register_event failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -552,7 +555,7 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_register_event_single failed! "
+		printk(KERN_DEBUG "notify_register_event_single failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -654,7 +657,7 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_unregister_event failed! "
+		printk(KERN_DEBUG "notify_unregister_event failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -730,7 +733,7 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_unregister_event_single failed! "
+		printk(KERN_DEBUG "notify_unregister_event_single failed! "
 			"status = 0x%x", status);
 	}
 	return status;
@@ -822,7 +825,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_send_event failed! status = 0x%x",
+		printk(KERN_DEBUG "notify_send_event failed! status = 0x%x",
 			status);
 	}
 	return status;
@@ -886,7 +889,8 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0)
-		printk(KERN_ERR "notify_disable failed! status = 0x%x", status);
+		printk(KERN_DEBUG "notify_disable failed! status = 0x%x",
+			status);
 	return key;
 }
 EXPORT_SYMBOL(notify_disable);
@@ -952,7 +956,8 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0)
-		printk(KERN_ERR "notify_restore failed! status = 0x%x", status);
+		printk(KERN_DEBUG "notify_restore failed! status = 0x%x",
+			status);
 	return;
 }
 EXPORT_SYMBOL(notify_restore);
@@ -1022,7 +1027,7 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_disable_event failed! status = 0x%x",
+		printk(KERN_DEBUG "notify_disable_event failed! status = 0x%x",
 			status);
 	}
 	return;
@@ -1094,7 +1099,7 @@
 	mutex_unlock(notify_state.gate_handle);
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_enable_event failed! status = 0x%x",
+		printk(KERN_DEBUG "notify_enable_event failed! status = 0x%x",
 			status);
 	}
 	return;
@@ -1129,7 +1134,7 @@
 
 exit:
 	if (status < 0) {
-		printk(KERN_ERR "notify_intline_registered failed! status = 0x%x",
+		printk(KERN_DEBUG "notify_intline_registered failed! status = 0x%x",
 			status);
 	}
 	return is_registered;
@@ -1196,7 +1201,7 @@
 	WARN_ON(obj == NULL);
 	if (WARN_ON((event_id >= notify_state.cfg.num_events) ||
 		(event_id >= NOTIFY_MAXEVENTS))) {
-		printk(KERN_ERR "Invalid event_id %d\n", event_id);
+		printk(KERN_DEBUG "Invalid event_id %d\n", event_id);
 	} else {
 		callback = &(obj->callbacks[event_id]);
 		WARN_ON(callback->fn_notify_cbck == NULL);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/omap_notify/notify_init.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/omap_notify/notify_init.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/dsp/syslink/omap_notify/notify_init.c	2014-08-07 11:51:55.518748547 -0600
@@ -384,16 +384,22 @@
 
 	if (dsp_notify_va != 0) {
 		i = multiproc_get_id("DSP");
-		list[0]->map_index = i;
-		notify_map_info[i].actualAddress = dsp_notify_va;
-		memreq = notify_shared_mem_req(i, (void *)
-				notify_map_info[i].actualAddress);
-		notify_map_info[i].size = memreq;
+		if (i != MULTIPROC_INVALIDID) {
+			list[0]->map_index = i;
+			notify_map_info[i].actualAddress = dsp_notify_va;
+			memreq = notify_shared_mem_req(i, (void *)
+					notify_map_info[i].actualAddress);
+			notify_map_info[i].size = memreq;
 
-		if (cpu_is_omap343x()) {
-			notify_add_mmu_entry(list[0]->mmu_handle,
+			if (cpu_is_omap343x()) {
+				notify_add_mmu_entry(list[0]->mmu_handle,
 					notify_map_info[i].actualAddress,
 					notify_map_info[i].size);
+			}
+		}
+		else {
+			printk(KERN_ERR "notify_init: dsp_notify_va was "
+			       "specified but no DSP found\n");
 		}
 	}
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/gpio/pca953x.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/gpio/pca953x.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/gpio/pca953x.c	2014-08-07 11:51:55.558748545 -0600
@@ -24,6 +24,7 @@
 #include <linux/of_gpio.h>
 #endif
 
+
 #define PCA953X_INPUT          0
 #define PCA953X_OUTPUT         1
 #define PCA953X_INVERT         2
@@ -551,6 +552,15 @@
 	}
 
 	i2c_set_clientdata(client, chip);
+
+/*	  ret = gpio_request(GPIO_WLAN_EN, "wlan_en");
+       if (ret) {
+               pr_err("Error requesting wlan enable gpio: %d\n", ret);
+               return;
+       }
+
+        gpio_direction_output(GPIO_WLAN_EN,0);*/
+
 	return 0;
 
 out_failed:
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d.c	2014-08-07 11:51:55.566748545 -0600
@@ -19,7 +19,7 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
-
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/dmi.h>
@@ -36,9 +36,18 @@
 #include <linux/uaccess.h>
 #include <linux/miscdevice.h>
 #include <linux/pm_runtime.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
+#include <linux/gpio.h>
 #include "lis3lv02d.h"
 
+#include <asm/siginfo.h>        //siginfo			//vishwa
+#include <linux/rcupdate.h>     //rcu_read_lock			//vishwa
+#include <linux/sched.h>        //find_task_by_pid_type		//vishwa
+#include <linux/debugfs.h>					//vishwa
+#include <linux/uaccess.h>					//vishwa
+
+#define SIG_TEST 44	// we choose 44 as our signal number (real-time signals are in the range of 33 to 64)		//vishwa
+
 #define DRIVER_NAME     "lis3lv02d"
 
 /* joystick device poll interval in milliseconds */
@@ -78,15 +87,42 @@
 #define LIS3_SENSITIVITY_12B		((LIS3_ACCURACY * 1000) / 1024)
 #define LIS3_SENSITIVITY_8B		(18 * LIS3_ACCURACY)
 
+/*
+   * LIS331DLH spec says 1LSBs corresponds 4G/4096 -> 1LSB is 1000/1024 mG.
+   * Below macros defines sensitivity values for +/-2G. Dataout bits for
+   * +/-2G range is 12 bits so 4 bits adjustment must be done to get 12bit
+   * data from 16bit value. Currently this driver supports only 2G range.
+   */
+
+/* Sensitivity values for -2G, -4G, -8G and +2G, +4G, +8G scale */
+#define LIS3DLH_SENSITIVITY_2G          ((LIS3_ACCURACY * 1000) / 1024)
+//#define LIS3DLH_SENSITIVITY_2G		(LIS3_ACCURACY * 1)
+#define LIS3DLH_SENSITIVITY_4G		(LIS3_ACCURACY * 2)
+#define LIS3DLH_SENSITIVITY_8G		((LIS3_ACCURACY * 39)/10)
+
+
+#define SHIFT_ADJ_2G                    4
+#define SHIFT_ADJ_4G			3
+#define SHIFT_ADJ_8G			2
+
+#define FS_MASK				(0x3 << 4)
+
 #define LIS3_DEFAULT_FUZZ_12B		3
 #define LIS3_DEFAULT_FLAT_12B		3
 #define LIS3_DEFAULT_FUZZ_8B		1
 #define LIS3_DEFAULT_FLAT_8B		1
 
+static int pid = 0;							//vishwa
+struct siginfo info;							//vishwa
+struct task_struct *t;							//vishwa
+int ret=0;								//vishwa
+//static char kDataArrived=0;						//vishwa
+//static char kbuffer=0;							//vishwa
+
+ static inline void lis302dl_data_ready(struct lis3lv02d *, int );
 struct lis3lv02d lis3_dev = {
 	.misc_wait   = __WAIT_QUEUE_HEAD_INITIALIZER(lis3_dev.misc_wait),
 };
-
 EXPORT_SYMBOL_GPL(lis3_dev);
 
 /* just like param_set_int() but does sanity-check so that it won't point
@@ -132,6 +168,19 @@
 	return (s16)((hi << 8) | lo);
 }
 
+/* 12bits for 2G range, 13 bits for 4G range and 14 bits for 8G range */
+static s16 lis331dlh_read_data(struct lis3lv02d *lis3, int reg)
+{
+	u8 lo, hi;
+	int v;
+
+	lis3->read(lis3, reg - 1, &lo);
+	lis3->read(lis3, reg, &hi);
+	v = (int) ((hi << 8) | lo);
+
+	return (s16) v >> lis3->shift_adj;
+}
+
 /**
  * lis3lv02d_get_axis - For the given axis, give the value converted
  * @axis:      1,2,3 - can also be negative
@@ -147,6 +196,12 @@
 		return -hw_values[-axis - 1];
 }
 
+static int lis3lv02d_decode(u8 pl, u8 ph, int adj)
+{
+	s16 v = pl | ph << 8;
+	return (int) v >> adj;
+}
+
 /**
  * lis3lv02d_get_xyz - Get X, Y and Z axis values from the accelerometer
  * @lis3: pointer to the device struct
@@ -162,7 +217,7 @@
 	int i;
 
 	if (lis3->blkread) {
-		if (lis3_dev.whoami == WAI_12B) {
+		if (lis3->whoami == WAI_12B) {
 			u16 data[3];
 			lis3->blkread(lis3, OUTX_L, 6, (u8 *)data);
 			for (i = 0; i < 3; i++)
@@ -175,9 +230,24 @@
 				position[i] = (s8)data[i * 2];
 		}
 	} else {
-		position[0] = lis3->read_data(lis3, OUTX);
-		position[1] = lis3->read_data(lis3, OUTY);
-		position[2] = lis3->read_data(lis3, OUTZ);
+		if (lis3_dev.whoami == WAI_3DLH) {
+			position[0] =
+				lis3lv02d_decode(lis3->read_data(lis3, OUTX_L),
+				lis3->read_data(lis3, OUTX_H),
+				lis3_dev.shift_adj);
+			position[1] =
+				lis3lv02d_decode(lis3->read_data(lis3, OUTY_L),
+				lis3->read_data(lis3, OUTY_H),
+				lis3_dev.shift_adj);
+			position[2] =
+				lis3lv02d_decode(lis3->read_data(lis3, OUTZ_L),
+				lis3->read_data(lis3, OUTZ_H),
+				lis3_dev.shift_adj);
+		} else {
+			position[0] = lis3->read_data(lis3, OUTX);
+			position[1] = lis3->read_data(lis3, OUTY);
+			position[2] = lis3->read_data(lis3, OUTZ);
+		}
 	}
 
 	for (i = 0; i < 3; i++)
@@ -192,20 +262,33 @@
 static int lis3_12_rates[4] = {40, 160, 640, 2560};
 static int lis3_8_rates[2] = {100, 400};
 static int lis3_3dc_rates[16] = {0, 1, 10, 25, 50, 100, 200, 400, 1600, 5000};
+static int lis3_3dlh_rates[4] = {50, 100, 400, 1000};
 
 /* ODR is Output Data Rate */
-static int lis3lv02d_get_odr(void)
+static int lis3lv02d_get_odr(struct lis3lv02d *lis3)
 {
 	u8 ctrl;
 	int shift;
 
-	lis3_dev.read(&lis3_dev, CTRL_REG1, &ctrl);
-	ctrl &= lis3_dev.odr_mask;
-	shift = ffs(lis3_dev.odr_mask) - 1;
-	return lis3_dev.odrs[(ctrl >> shift)];
+	lis3->read(lis3, CTRL_REG1, &ctrl);
+	ctrl &= lis3->odr_mask;
+	shift = ffs(lis3->odr_mask) - 1;
+	return lis3->odrs[(ctrl >> shift)];
 }
 
-static int lis3lv02d_set_odr(int rate)
+static int lis3lv02d_get_pwron_wait(struct lis3lv02d *lis3)
+{
+	int div = lis3lv02d_get_odr(lis3);
+
+	if (WARN_ONCE(div == 0, "device returned spurious data"))
+		return -ENXIO;
+
+	/* LIS3 power on delay is quite long */
+	msleep(lis3->pwron_delay / div);
+	return 0;
+}
+
+static int lis3lv02d_set_odr(struct lis3lv02d *lis3, int rate)
 {
 	u8 ctrl;
 	int i, len, shift;
@@ -213,14 +296,14 @@
 	if (!rate)
 		return -EINVAL;
 
-	lis3_dev.read(&lis3_dev, CTRL_REG1, &ctrl);
-	ctrl &= ~lis3_dev.odr_mask;
-	len = 1 << hweight_long(lis3_dev.odr_mask); /* # of possible values */
-	shift = ffs(lis3_dev.odr_mask) - 1;
+	lis3->read(lis3, CTRL_REG1, &ctrl);
+	ctrl &= ~lis3->odr_mask;
+	len = 1 << hweight_long(lis3->odr_mask); /* # of possible values */
+	shift = ffs(lis3->odr_mask) - 1;
 
 	for (i = 0; i < len; i++)
-		if (lis3_dev.odrs[i] == rate) {
-			lis3_dev.write(&lis3_dev, CTRL_REG1,
+		if (lis3->odrs[i] == rate) {
+			lis3->write(lis3, CTRL_REG1,
 					ctrl | (i << shift));
 			return 0;
 		}
@@ -239,12 +322,12 @@
 	mutex_lock(&lis3->mutex);
 
 	irq_cfg = lis3->irq_cfg;
-	if (lis3_dev.whoami == WAI_8B) {
+	if (lis3->whoami == WAI_8B) {
 		lis3->data_ready_count[IRQ_LINE0] = 0;
 		lis3->data_ready_count[IRQ_LINE1] = 0;
 
 		/* Change interrupt cfg to data ready for selftest */
-		atomic_inc(&lis3_dev.wake_thread);
+		atomic_inc(&lis3->wake_thread);
 		lis3->irq_cfg = LIS3_IRQ1_DATA_READY | LIS3_IRQ2_DATA_READY;
 		lis3->read(lis3, CTRL_REG3, &ctrl_reg_data);
 		lis3->write(lis3, CTRL_REG3, (ctrl_reg_data &
@@ -252,12 +335,12 @@
 				(LIS3_IRQ1_DATA_READY | LIS3_IRQ2_DATA_READY));
 	}
 
-	if (lis3_dev.whoami == WAI_3DC) {
+	if ((lis3_dev.whoami == WAI_3DC) || (lis3_dev.whoami == WAI_3DLH)) {
 		ctlreg = CTRL_REG4;
 		selftest = CTRL4_ST0;
 	} else {
 		ctlreg = CTRL_REG1;
-		if (lis3_dev.whoami == WAI_12B)
+		if (lis3->whoami == WAI_12B)
 			selftest = CTRL1_ST;
 		else
 			selftest = CTRL1_STP;
@@ -265,7 +348,9 @@
 
 	lis3->read(lis3, ctlreg, &reg);
 	lis3->write(lis3, ctlreg, (reg | selftest));
-	msleep(lis3->pwron_delay / lis3lv02d_get_odr());
+	ret = lis3lv02d_get_pwron_wait(lis3);
+	if (ret)
+		goto fail;
 
 	/* Read directly to avoid axis remap */
 	x = lis3->read_data(lis3, OUTX);
@@ -274,7 +359,9 @@
 
 	/* back to normal settings */
 	lis3->write(lis3, ctlreg, reg);
-	msleep(lis3->pwron_delay / lis3lv02d_get_odr());
+	ret = lis3lv02d_get_pwron_wait(lis3);
+	if (ret)
+		goto fail;
 
 	results[0] = x - lis3->read_data(lis3, OUTX);
 	results[1] = y - lis3->read_data(lis3, OUTY);
@@ -282,9 +369,9 @@
 
 	ret = 0;
 
-	if (lis3_dev.whoami == WAI_8B) {
+	if (lis3->whoami == WAI_8B) {
 		/* Restore original interrupt configuration */
-		atomic_dec(&lis3_dev.wake_thread);
+		atomic_dec(&lis3->wake_thread);
 		lis3->write(lis3, CTRL_REG3, ctrl_reg_data);
 		lis3->irq_cfg = irq_cfg;
 
@@ -362,8 +449,9 @@
 }
 EXPORT_SYMBOL_GPL(lis3lv02d_poweroff);
 
-void lis3lv02d_poweron(struct lis3lv02d *lis3)
+int lis3lv02d_poweron(struct lis3lv02d *lis3)
 {
+	int err;
 	u8 reg;
 
 	lis3->init(lis3);
@@ -374,42 +462,57 @@
 	 *      both have been read. So the value read will always be correct.
 	 * Set BOOT bit to refresh factory tuning values.
 	 */
-	lis3->read(lis3, CTRL_REG2, &reg);
-	if (lis3->whoami ==  WAI_12B)
-		reg |= CTRL2_BDU | CTRL2_BOOT;
-	else
-		reg |= CTRL2_BOOT_8B;
-	lis3->write(lis3, CTRL_REG2, reg);
+	if (lis3->pdata) {
+		lis3->read(lis3, CTRL_REG2, &reg);
+		if (lis3->whoami ==  WAI_12B)
+			reg |= CTRL2_BDU | CTRL2_BOOT;
+		else if (lis3->whoami ==  WAI_3DLH)
+			reg |= CTRL2_BOOT_3DLH;
+		else
+			reg |= CTRL2_BOOT_8B;
+		lis3->write(lis3, CTRL_REG2, reg);
+		if (lis3->whoami ==  WAI_3DLH) { 	                       	//Omji
+			lis3->read(lis3, CTRL_REG4, &reg);			//Omji
+			reg |= CTRL4_BDU;					//Omji
+			lis3->write(lis3, CTRL_REG4, reg);			//Omji
+		}								//Omji
+	}
 
-	/* LIS3 power on delay is quite long */
-	msleep(lis3->pwron_delay / lis3lv02d_get_odr());
+	err = lis3lv02d_get_pwron_wait(lis3);
+	if (err)
+		return err;
 
 	if (lis3->reg_ctrl)
 		lis3_context_restore(lis3);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(lis3lv02d_poweron);
 
 
 static void lis3lv02d_joystick_poll(struct input_polled_dev *pidev)
 {
+	struct lis3lv02d *lis3 = pidev->private;
 	int x, y, z;
 
-	mutex_lock(&lis3_dev.mutex);
-	lis3lv02d_get_xyz(&lis3_dev, &x, &y, &z);
+	mutex_lock(&lis3->mutex);
+	lis3lv02d_get_xyz(lis3, &x, &y, &z);
 	input_report_abs(pidev->input, ABS_X, x);
 	input_report_abs(pidev->input, ABS_Y, y);
 	input_report_abs(pidev->input, ABS_Z, z);
 	input_sync(pidev->input);
-	mutex_unlock(&lis3_dev.mutex);
+	mutex_unlock(&lis3->mutex);
 }
 
 static void lis3lv02d_joystick_open(struct input_polled_dev *pidev)
 {
-	if (lis3_dev.pm_dev)
-		pm_runtime_get_sync(lis3_dev.pm_dev);
+	struct lis3lv02d *lis3 = pidev->private;
 
-	if (lis3_dev.pdata && lis3_dev.whoami == WAI_8B && lis3_dev.idev)
-		atomic_set(&lis3_dev.wake_thread, 1);
+	if (lis3->pm_dev)
+		pm_runtime_get_sync(lis3->pm_dev);
+
+	if (lis3->pdata && lis3->whoami == WAI_8B && lis3->idev)
+		atomic_set(&lis3->wake_thread, 1);
 	/*
 	 * Update coordinates for the case where poll interval is 0 and
 	 * the chip in running purely under interrupt control
@@ -419,28 +522,34 @@
 
 static void lis3lv02d_joystick_close(struct input_polled_dev *pidev)
 {
-	atomic_set(&lis3_dev.wake_thread, 0);
-	if (lis3_dev.pm_dev)
-		pm_runtime_put(lis3_dev.pm_dev);
-}
+	struct lis3lv02d *lis3 = pidev->private;
 
-static irqreturn_t lis302dl_interrupt(int irq, void *dummy)
+	atomic_set(&lis3->wake_thread, 0);
+	if (lis3->pm_dev)
+		pm_runtime_put(lis3->pm_dev);
+}
+static irqreturn_t lis302dl_interrupt(int irq, void *data)
 {
-	if (!test_bit(0, &lis3_dev.misc_opened))
-		goto out;
+	struct lis3lv02d *lis3 = data;
+
 
+	if (!test_bit(0, &lis3->misc_opened))
+		goto out;
 	/*
 	 * Be careful: on some HP laptops the bios force DD when on battery and
 	 * the lid is closed. This leads to interrupts as soon as a little move
 	 * is done.
 	 */
-	atomic_inc(&lis3_dev.count);
+	atomic_inc(&lis3->count);
 
-	wake_up_interruptible(&lis3_dev.misc_wait);
-	kill_fasync(&lis3_dev.async_queue, SIGIO, POLL_IN);
+	wake_up_interruptible(&lis3->misc_wait);
+	kill_fasync(&lis3->async_queue, SIGIO, POLL_IN);
 out:
-	if (atomic_read(&lis3_dev.wake_thread))
-		return IRQ_WAKE_THREAD;
+	if (atomic_read(&lis3->wake_thread))
+	{
+		return IRQ_WAKE_THREAD;				//Omji
+	}
+
 	return IRQ_HANDLED;
 }
 
@@ -483,22 +592,50 @@
 {
 	struct lis3lv02d *lis3 = data;
 	u8 irq_cfg = lis3->irq_cfg & LIS3_IRQ1_MASK;
+	pr_info(" %s %d \n" ,__FUNCTION__, __LINE__);
+
+	if(pid)
+	{
+		memset(&info, 0, sizeof(struct siginfo));
+		info.si_signo = SIG_TEST;
+		info.si_code = SI_QUEUE;
+
+
+		rcu_read_lock();
+		//find the task_struct associated with this pid
+		t = pid_task(find_vpid(pid),PIDTYPE_PID);
+		if(t == NULL){
+			printk("no such pid\n");
+			rcu_read_unlock();
+			return -ENODEV;
+		}
+		rcu_read_unlock();
+
+		ret = send_sig_info(SIG_TEST, &info, t);    //send the signal
+		if (ret < 0)
+		{
+			printk("error sending signal\n");
+			return ret;
+		}
+	}
 
 	if (irq_cfg == LIS3_IRQ1_CLICK)
 		lis302dl_interrupt_handle_click(lis3);
-	else if (unlikely(irq_cfg == LIS3_IRQ1_DATA_READY))
-		lis302dl_data_ready(lis3, IRQ_LINE0);
+	else if (unlikely(irq_cfg == LIS3_IRQ1_DATA_READY))		//Omji
+	{								//Omji
+		lis302dl_data_ready(lis3, IRQ_LINE0);			//Omji
+	}								//Omji
 	else
 		lis3lv02d_joystick_poll(lis3->idev);
 
-	return IRQ_HANDLED;
+	return IRQ_HANDLED;					//Omji
 }
 
 static irqreturn_t lis302dl_interrupt_thread2_8b(int irq, void *data)
 {
 	struct lis3lv02d *lis3 = data;
 	u8 irq_cfg = lis3->irq_cfg & LIS3_IRQ2_MASK;
-
+	pr_info(" %s %d " ,__FUNCTION__, __LINE__);
 	if (irq_cfg == LIS3_IRQ2_CLICK)
 		lis302dl_interrupt_handle_click(lis3);
 	else if (unlikely(irq_cfg == LIS3_IRQ2_DATA_READY))
@@ -511,28 +648,37 @@
 
 static int lis3lv02d_misc_open(struct inode *inode, struct file *file)
 {
-	if (test_and_set_bit(0, &lis3_dev.misc_opened))
+	struct lis3lv02d *lis3 = container_of(file->private_data,
+			struct lis3lv02d, miscdev);
+
+	if (test_and_set_bit(0, &lis3->misc_opened))
 		return -EBUSY; /* already open */
 
-	if (lis3_dev.pm_dev)
-		pm_runtime_get_sync(lis3_dev.pm_dev);
+	if (lis3->pm_dev)
+		pm_runtime_get_sync(lis3->pm_dev);
 
-	atomic_set(&lis3_dev.count, 0);
+	atomic_set(&lis3->count, 0);
 	return 0;
 }
 
 static int lis3lv02d_misc_release(struct inode *inode, struct file *file)
 {
-	fasync_helper(-1, file, 0, &lis3_dev.async_queue);
-	clear_bit(0, &lis3_dev.misc_opened); /* release the device */
-	if (lis3_dev.pm_dev)
-		pm_runtime_put(lis3_dev.pm_dev);
+	struct lis3lv02d *lis3 = container_of(file->private_data,
+			struct lis3lv02d, miscdev);
+
+	fasync_helper(-1, file, 0, &lis3->async_queue);
+	clear_bit(0, &lis3->misc_opened); /* release the device */
+	if (lis3->pm_dev)
+		pm_runtime_put(lis3->pm_dev);
 	return 0;
 }
 
 static ssize_t lis3lv02d_misc_read(struct file *file, char __user *buf,
-				size_t count, loff_t *pos)
+		size_t count, loff_t *pos)
 {
+	struct lis3lv02d *lis3 = container_of(file->private_data,
+			struct lis3lv02d, miscdev);
+
 	DECLARE_WAITQUEUE(wait, current);
 	u32 data;
 	unsigned char byte_data;
@@ -541,10 +687,10 @@
 	if (count < 1)
 		return -EINVAL;
 
-	add_wait_queue(&lis3_dev.misc_wait, &wait);
+	add_wait_queue(&lis3->misc_wait, &wait);
 	while (true) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		data = atomic_xchg(&lis3_dev.count, 0);
+		data = atomic_xchg(&lis3->count, 0);
 		if (data)
 			break;
 
@@ -574,23 +720,47 @@
 
 out:
 	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&lis3_dev.misc_wait, &wait);
+	remove_wait_queue(&lis3->misc_wait, &wait);
 
 	return retval;
 }
 
 static unsigned int lis3lv02d_misc_poll(struct file *file, poll_table *wait)
 {
-	poll_wait(file, &lis3_dev.misc_wait, wait);
-	if (atomic_read(&lis3_dev.count))
+	struct lis3lv02d *lis3 = container_of(file->private_data,
+			struct lis3lv02d, miscdev);
+
+	poll_wait(file, &lis3->misc_wait, wait);
+	if (atomic_read(&lis3->count))
 		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
 static int lis3lv02d_misc_fasync(int fd, struct file *file, int on)
 {
-	return fasync_helper(fd, file, on, &lis3_dev.async_queue);
+	struct lis3lv02d *lis3 = container_of(file->private_data,
+			struct lis3lv02d, miscdev);
+
+	return fasync_helper(fd, file, on, &lis3->async_queue);
+}
+/***********************************************Omji***********************************************/
+static ssize_t lis3lv02d_write(struct file *filp, const char __user *buffer, size_t length, loff_t * offset)
+{
+
+	char mybuf[10];
+	if(length > 10)
+		return -EINVAL;
+	if(copy_from_user( mybuf, buffer , length ))
+	{
+		return -EFAULT;
+	}
+
+	sscanf(mybuf, "%d", &pid);
+
+	return length;
 }
+/****************************************************************************************************/
+
 
 static const struct file_operations lis3lv02d_misc_fops = {
 	.owner   = THIS_MODULE,
@@ -600,90 +770,125 @@
 	.release = lis3lv02d_misc_release,
 	.poll    = lis3lv02d_misc_poll,
 	.fasync  = lis3lv02d_misc_fasync,
+	.write	=  lis3lv02d_write                                     //Omji
 };
 
-static struct miscdevice lis3lv02d_misc_device = {
-	.minor   = MISC_DYNAMIC_MINOR,
-	.name    = "freefall",
-	.fops    = &lis3lv02d_misc_fops,
-};
-
-int lis3lv02d_joystick_enable(void)
+int lis3lv02d_joystick_enable(struct lis3lv02d *lis3)
 {
 	struct input_dev *input_dev;
 	int err;
 	int max_val, fuzz, flat;
 	int btns[] = {BTN_X, BTN_Y, BTN_Z};
 
-	if (lis3_dev.idev)
+	if (lis3->idev)
 		return -EINVAL;
 
-	lis3_dev.idev = input_allocate_polled_device();
-	if (!lis3_dev.idev)
+	lis3->idev = input_allocate_polled_device();
+	if (!lis3->idev)
 		return -ENOMEM;
 
-	lis3_dev.idev->poll = lis3lv02d_joystick_poll;
-	lis3_dev.idev->open = lis3lv02d_joystick_open;
-	lis3_dev.idev->close = lis3lv02d_joystick_close;
-	lis3_dev.idev->poll_interval = MDPS_POLL_INTERVAL;
-	lis3_dev.idev->poll_interval_min = MDPS_POLL_MIN;
-	lis3_dev.idev->poll_interval_max = MDPS_POLL_MAX;
-	input_dev = lis3_dev.idev->input;
+	lis3->idev->poll = lis3lv02d_joystick_poll;
+	lis3->idev->open = lis3lv02d_joystick_open;
+	lis3->idev->close = lis3lv02d_joystick_close;
+	lis3->idev->poll_interval = MDPS_POLL_INTERVAL;
+	lis3->idev->poll_interval_min = MDPS_POLL_MIN;
+	lis3->idev->poll_interval_max = MDPS_POLL_MAX;
+	lis3->idev->private = lis3;
+	input_dev = lis3->idev->input;
 
 	input_dev->name       = "ST LIS3LV02DL Accelerometer";
 	input_dev->phys       = DRIVER_NAME "/input0";
 	input_dev->id.bustype = BUS_HOST;
 	input_dev->id.vendor  = 0;
-	input_dev->dev.parent = &lis3_dev.pdev->dev;
+	input_dev->dev.parent = &lis3->pdev->dev;
 
 	set_bit(EV_ABS, input_dev->evbit);
-	max_val = (lis3_dev.mdps_max_val * lis3_dev.scale) / LIS3_ACCURACY;
-	if (lis3_dev.whoami == WAI_12B) {
+	max_val = (lis3->mdps_max_val * lis3->scale) / LIS3_ACCURACY;
+	if (lis3->whoami == WAI_12B) {
 		fuzz = LIS3_DEFAULT_FUZZ_12B;
 		flat = LIS3_DEFAULT_FLAT_12B;
 	} else {
 		fuzz = LIS3_DEFAULT_FUZZ_8B;
 		flat = LIS3_DEFAULT_FLAT_8B;
 	}
-	fuzz = (fuzz * lis3_dev.scale) / LIS3_ACCURACY;
-	flat = (flat * lis3_dev.scale) / LIS3_ACCURACY;
+	fuzz = (fuzz * lis3->scale) / LIS3_ACCURACY;
+	flat = (flat * lis3->scale) / LIS3_ACCURACY;
 
 	input_set_abs_params(input_dev, ABS_X, -max_val, max_val, fuzz, flat);
 	input_set_abs_params(input_dev, ABS_Y, -max_val, max_val, fuzz, flat);
 	input_set_abs_params(input_dev, ABS_Z, -max_val, max_val, fuzz, flat);
 
-	lis3_dev.mapped_btns[0] = lis3lv02d_get_axis(abs(lis3_dev.ac.x), btns);
-	lis3_dev.mapped_btns[1] = lis3lv02d_get_axis(abs(lis3_dev.ac.y), btns);
-	lis3_dev.mapped_btns[2] = lis3lv02d_get_axis(abs(lis3_dev.ac.z), btns);
+	lis3->mapped_btns[0] = lis3lv02d_get_axis(abs(lis3->ac.x), btns);
+	lis3->mapped_btns[1] = lis3lv02d_get_axis(abs(lis3->ac.y), btns);
+	lis3->mapped_btns[2] = lis3lv02d_get_axis(abs(lis3->ac.z), btns);
 
-	err = input_register_polled_device(lis3_dev.idev);
+	err = input_register_polled_device(lis3->idev);
 	if (err) {
-		input_free_polled_device(lis3_dev.idev);
-		lis3_dev.idev = NULL;
+		input_free_polled_device(lis3->idev);
+		lis3->idev = NULL;
 	}
 
 	return err;
 }
 EXPORT_SYMBOL_GPL(lis3lv02d_joystick_enable);
 
-void lis3lv02d_joystick_disable(void)
+void lis3lv02d_joystick_disable(struct lis3lv02d *lis3)
 {
-	if (lis3_dev.irq)
-		free_irq(lis3_dev.irq, &lis3_dev);
-	if (lis3_dev.pdata && lis3_dev.pdata->irq2)
-		free_irq(lis3_dev.pdata->irq2, &lis3_dev);
+	if (lis3->irq)
+		free_irq(lis3->irq, lis3);
+	if (lis3->pdata && lis3->pdata->irq2)
+		free_irq(lis3->pdata->irq2, lis3);
 
-	if (!lis3_dev.idev)
+	if (!lis3->idev)
 		return;
 
-	if (lis3_dev.irq)
-		misc_deregister(&lis3lv02d_misc_device);
-	input_unregister_polled_device(lis3_dev.idev);
-	input_free_polled_device(lis3_dev.idev);
-	lis3_dev.idev = NULL;
+	if (lis3->irq)
+		misc_deregister(&lis3->miscdev);
+	input_unregister_polled_device(lis3->idev);
+	input_free_polled_device(lis3->idev);
+	lis3->idev = NULL;
 }
 EXPORT_SYMBOL_GPL(lis3lv02d_joystick_disable);
 
+static void lis3lv02d_update_enable(struct lis3lv02d *lis3)
+{
+
+	if(lis3->enable)
+		lis3->write(lis3, CTRL_REG1, 0xB7);
+	else
+
+		lis3->write(lis3, CTRL_REG1, 0x00);
+}
+static void lis3lv02d_update_g_range(struct lis3lv02d *lis3)
+{
+	u8 reg;
+	u8 val;
+	u8 shift;
+
+	switch (lis3->g_range) {
+		case 8:
+			val = FS_8G_REGVAL;
+			shift = SHIFT_ADJ_8G;
+			lis3->scale = LIS3DLH_SENSITIVITY_8G;
+			break;
+		case 4:
+			val = FS_4G_REGVAL;
+			shift = SHIFT_ADJ_4G;
+			lis3->scale = LIS3DLH_SENSITIVITY_4G;
+			break;
+		case 2:
+		default:
+			val = FS_2G_REGVAL;
+			shift = SHIFT_ADJ_2G;
+			lis3->scale = LIS3DLH_SENSITIVITY_2G;
+			break;
+	}
+
+	lis3->shift_adj = shift;
+	lis3->read(lis3, CTRL_REG4, &reg);
+	lis3->write(lis3, CTRL_REG4, ((reg & ~FS_MASK) | val));
+}
+
 /* Sysfs stuff */
 static void lis3lv02d_sysfs_poweron(struct lis3lv02d *lis3)
 {
@@ -703,8 +908,9 @@
 }
 
 static ssize_t lis3lv02d_selftest_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+		struct device_attribute *attr, char *buf)
 {
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
 	s16 values[3];
 
 	static const char ok[] = "OK";
@@ -712,67 +918,275 @@
 	static const char irq[] = "FAIL_IRQ";
 	const char *res;
 
-	lis3lv02d_sysfs_poweron(&lis3_dev);
-	switch (lis3lv02d_selftest(&lis3_dev, values)) {
-	case SELFTEST_FAIL:
-		res = fail;
-		break;
-	case SELFTEST_IRQ:
-		res = irq;
-		break;
-	case SELFTEST_OK:
-	default:
-		res = ok;
-		break;
+	lis3lv02d_sysfs_poweron(lis3);
+	switch (lis3lv02d_selftest(lis3, values)) {
+		case SELFTEST_FAIL:
+			res = fail;
+			break;
+		case SELFTEST_IRQ:
+			res = irq;
+			break;
+		case SELFTEST_OK:
+		default:
+			res = ok;
+			break;
 	}
 	return sprintf(buf, "%s %d %d %d\n", res,
-		values[0], values[1], values[2]);
+			values[0], values[1], values[2]);
 }
 
 static ssize_t lis3lv02d_position_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+		struct device_attribute *attr, char *buf)
 {
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
 	int x, y, z;
 
-	lis3lv02d_sysfs_poweron(&lis3_dev);
-	mutex_lock(&lis3_dev.mutex);
-	lis3lv02d_get_xyz(&lis3_dev, &x, &y, &z);
-	mutex_unlock(&lis3_dev.mutex);
+	lis3lv02d_sysfs_poweron(lis3);
+	mutex_lock(&lis3->mutex);
+	lis3lv02d_get_xyz(lis3, &x, &y, &z);
+	mutex_unlock(&lis3->mutex);
 	return sprintf(buf, "(%d,%d,%d)\n", x, y, z);
 }
 
 static ssize_t lis3lv02d_rate_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
+		struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+
+	lis3lv02d_sysfs_poweron(lis3);
+	return sprintf(buf, "%d\n", lis3lv02d_get_odr(lis3));
+}
+
+static ssize_t lis3lv02d_range_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	lis3lv02d_sysfs_poweron(&lis3_dev);
-	return sprintf(buf, "%d\n", lis3lv02d_get_odr());
+	return sprintf(buf, "%d\n", lis3_dev.g_range);
 }
 
+static ssize_t lis3lv02d_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	int en;
+	lis3lv02d_sysfs_poweron(&lis3_dev);
+	en = lis3lv02d_read_8(lis3, CTRL_REG1);
+	if(en)
+		lis3_dev.enable = 1;
+	else
+		lis3_dev.enable = 0;
+
+	return sprintf(buf, "%d\n", lis3_dev.enable);
+}
 static ssize_t lis3lv02d_rate_set(struct device *dev,
-				struct device_attribute *attr, const char *buf,
-				size_t count)
+		struct device_attribute *attr, const char *buf,
+		size_t count)
 {
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
 	unsigned long rate;
 
 	if (strict_strtoul(buf, 0, &rate))
 		return -EINVAL;
 
-	lis3lv02d_sysfs_poweron(&lis3_dev);
-	if (lis3lv02d_set_odr(rate))
+	lis3lv02d_sysfs_poweron(lis3);
+	if (lis3lv02d_set_odr(lis3, rate))
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t lis3lv02d_range_set(struct device *dev,
+		struct device_attribute *attr, const char *buf,
+		size_t count)
+{
+	unsigned long range;
+
+	if (strict_strtoul(buf, 0, &range))
+		return -EINVAL;
+
+	lis3_dev.g_range = range;
+	lis3lv02d_update_g_range(&lis3_dev);
+
+	return count;
+}
+
+static ssize_t lis3lv02d_enable_set(struct device *dev,
+		struct device_attribute *attr, const char *buf,
+		size_t count)
+{
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 0, &enable))
+		return -EINVAL;
+
+	lis3_dev.enable = enable;
+	lis3lv02d_update_enable(&lis3_dev);
+
+	return count;
+}
+
+/********************************** Omji **********************************************/
+static ssize_t get_reg_20(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned char read_val;
+	read_val = lis3lv02d_read_8(lis3, 0x20);
+	return sprintf(buf, "%x\n", read_val);
+}
+static ssize_t set_reg_20(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if(strict_strtoul(buf,16,&val))
+		return -EINVAL;
+
+	lis3->write(lis3, 0x20, (u8) val);
+	return count;
+}
+
+static ssize_t get_reg_21(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned char read_val;
+	read_val = lis3lv02d_read_8(lis3, 0x21);
+	return sprintf(buf, "%x\n", read_val);
+}
+static ssize_t set_reg_21(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if(strict_strtoul(buf,16,&val))
+		return -EINVAL;
+
+	lis3->write(lis3, 0x21, (u8) val);
+	return count;
+}
+
+static ssize_t get_reg_22(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned char read_val;
+	read_val = lis3lv02d_read_8(lis3, 0x22);
+	return sprintf(buf, "%x\n", read_val);
+}
+static ssize_t set_reg_22(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if(strict_strtoul(buf,16,&val))
+		return -EINVAL;
+
+	lis3->write(lis3, 0x22, (u8) val);
+	return count;
+}
+
+static ssize_t get_reg_23(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned char read_val;
+	read_val = lis3lv02d_read_8(lis3, 0x23);
+	return sprintf(buf, "%x\n", read_val);
+}
+static ssize_t set_reg_23(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if(strict_strtoul(buf,16,&val))
+		return -EINVAL;
+
+	lis3->write(lis3, 0x23, (u8) val);
+	return count;
+}
+
+static ssize_t get_reg_24(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned char read_val;
+	read_val = lis3lv02d_read_8(lis3, 0x24);
+	return sprintf(buf, "%x\n", read_val);
+}
+static ssize_t set_reg_24(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if(strict_strtoul(buf,16,&val))
+		return -EINVAL;
+
+	lis3->write(lis3, 0x24, (u8) val);
+	return count;
+}
+
+static ssize_t get_reg_32(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned char read_val;
+	read_val = lis3lv02d_read_8(lis3, 0x32);
+	return sprintf(buf, "%x\n", read_val);
+}
+static ssize_t set_reg_32(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if(strict_strtoul(buf,16,&val))
 		return -EINVAL;
 
+	lis3->write(lis3, 0x32, (u8) val);
 	return count;
 }
 
+static ssize_t get_reg_33(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned char read_val;
+	read_val = lis3lv02d_read_8(lis3, 0x33);
+	return sprintf(buf, "%x\n", read_val);
+}
+
+static ssize_t set_reg_33(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis3lv02d *lis3 = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if(strict_strtoul(buf,16,&val))
+		return -EINVAL;
+
+	lis3->write(lis3, 0x33, (u8) val);
+	return count;
+}
+/***************************************************************************************/
+
 static DEVICE_ATTR(selftest, S_IRUSR, lis3lv02d_selftest_show, NULL);
 static DEVICE_ATTR(position, S_IRUGO, lis3lv02d_position_show, NULL);
-static DEVICE_ATTR(rate, S_IRUGO | S_IWUSR, lis3lv02d_rate_show,
-					    lis3lv02d_rate_set);
+static DEVICE_ATTR(rate, S_IRUGO | S_IWUSR, lis3lv02d_rate_show, lis3lv02d_rate_set);
+static DEVICE_ATTR(range, S_IRUGO | S_IWUSR, lis3lv02d_range_show, lis3lv02d_range_set);
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, lis3lv02d_enable_show, lis3lv02d_enable_set);
+static DEVICE_ATTR(ctrl1, S_IRUGO | S_IWUSR, get_reg_20, set_reg_20);				//Omji
+static DEVICE_ATTR(ctrl2, S_IRUGO | S_IWUSR, get_reg_21, set_reg_21);				//Omji
+static DEVICE_ATTR(ctrl3, S_IRUGO | S_IWUSR, get_reg_22, set_reg_22);				//Omji
+static DEVICE_ATTR(ctrl4, S_IRUGO | S_IWUSR, get_reg_23, set_reg_23);				//Omji
+static DEVICE_ATTR(ctrl5, S_IRUGO | S_IWUSR, get_reg_24, set_reg_24);				//Omji
+static DEVICE_ATTR(interrupt_threshold, S_IRUGO | S_IWUSR, get_reg_32, set_reg_32);		//Omji
+static DEVICE_ATTR(interrupt_duration, S_IRUGO | S_IWUSR, get_reg_33, set_reg_33);		//Omji
 
 static struct attribute *lis3lv02d_attributes[] = {
 	&dev_attr_selftest.attr,
 	&dev_attr_position.attr,
 	&dev_attr_rate.attr,
+	&dev_attr_range.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_ctrl1.attr,							//Omji
+	&dev_attr_ctrl2.attr,							//Omji
+	&dev_attr_ctrl3.attr,							//Omji
+	&dev_attr_ctrl4.attr,							//Omji
+	&dev_attr_ctrl5.attr,							//Omji
+	&dev_attr_interrupt_threshold.attr,					//Omji
+	&dev_attr_interrupt_duration.attr,					//Omji
 	NULL
 };
 
@@ -787,6 +1201,7 @@
 	if (IS_ERR(lis3->pdev))
 		return PTR_ERR(lis3->pdev);
 
+	platform_set_drvdata(lis3->pdev, lis3);
 	return sysfs_create_group(&lis3->pdev->dev.kobj, &lis3lv02d_attribute_group);
 }
 
@@ -800,7 +1215,7 @@
 
 		/* SYSFS may have left chip running. Turn off if necessary */
 		if (!pm_runtime_suspended(lis3->pm_dev))
-			lis3lv02d_poweroff(&lis3_dev);
+			lis3lv02d_poweroff(lis3);
 
 		pm_runtime_disable(lis3->pm_dev);
 		pm_runtime_set_suspended(lis3->pm_dev);
@@ -810,24 +1225,25 @@
 }
 EXPORT_SYMBOL_GPL(lis3lv02d_remove_fs);
 
-static void lis3lv02d_8b_configure(struct lis3lv02d *dev,
-				struct lis3lv02d_platform_data *p)
+static void lis3lv02d_8b_configure(struct lis3lv02d *lis3,
+		struct lis3lv02d_platform_data *p)
 {
 	int err;
 	int ctrl2 = p->hipass_ctrl;
 
+	pr_info("lis3lv02d_8b_configure\n");
 	if (p->click_flags) {
-		dev->write(dev, CLICK_CFG, p->click_flags);
-		dev->write(dev, CLICK_TIMELIMIT, p->click_time_limit);
-		dev->write(dev, CLICK_LATENCY, p->click_latency);
-		dev->write(dev, CLICK_WINDOW, p->click_window);
-		dev->write(dev, CLICK_THSZ, p->click_thresh_z & 0xf);
-		dev->write(dev, CLICK_THSY_X,
-			(p->click_thresh_x & 0xf) |
-			(p->click_thresh_y << 4));
+		lis3->write(lis3, CLICK_CFG, p->click_flags);
+		lis3->write(lis3, CLICK_TIMELIMIT, p->click_time_limit);
+		lis3->write(lis3, CLICK_LATENCY, p->click_latency);
+		lis3->write(lis3, CLICK_WINDOW, p->click_window);
+		lis3->write(lis3, CLICK_THSZ, p->click_thresh_z & 0xf);
+		lis3->write(lis3, CLICK_THSY_X,
+				(p->click_thresh_x & 0xf) |
+				(p->click_thresh_y << 4));
 
-		if (dev->idev) {
-			struct input_dev *input_dev = lis3_dev.idev->input;
+		if (lis3->idev) {
+			struct input_dev *input_dev = lis3->idev->input;
 			input_set_capability(input_dev, EV_KEY, BTN_X);
 			input_set_capability(input_dev, EV_KEY, BTN_Y);
 			input_set_capability(input_dev, EV_KEY, BTN_Z);
@@ -835,130 +1251,163 @@
 	}
 
 	if (p->wakeup_flags) {
-		dev->write(dev, FF_WU_CFG_1, p->wakeup_flags);
-		dev->write(dev, FF_WU_THS_1, p->wakeup_thresh & 0x7f);
+		lis3->write(lis3, FF_WU_CFG_1, p->wakeup_flags);
+		lis3->write(lis3, FF_WU_THS_1, p->wakeup_thresh & 0x7f);
 		/* pdata value + 1 to keep this backward compatible*/
-		dev->write(dev, FF_WU_DURATION_1, p->duration1 + 1);
+		lis3->write(lis3, FF_WU_DURATION_1, p->duration1 + 1);
 		ctrl2 ^= HP_FF_WU1; /* Xor to keep compatible with old pdata*/
 	}
 
 	if (p->wakeup_flags2) {
-		dev->write(dev, FF_WU_CFG_2, p->wakeup_flags2);
-		dev->write(dev, FF_WU_THS_2, p->wakeup_thresh2 & 0x7f);
+		lis3->write(lis3, FF_WU_CFG_2, p->wakeup_flags2);
+		lis3->write(lis3, FF_WU_THS_2, p->wakeup_thresh2 & 0x7f);
 		/* pdata value + 1 to keep this backward compatible*/
-		dev->write(dev, FF_WU_DURATION_2, p->duration2 + 1);
+		lis3->write(lis3, FF_WU_DURATION_2, p->duration2 + 1);
 		ctrl2 ^= HP_FF_WU2; /* Xor to keep compatible with old pdata*/
 	}
 	/* Configure hipass filters */
-	dev->write(dev, CTRL_REG2, ctrl2);
+	lis3->write(lis3, CTRL_REG2, ctrl2);
 
+	pr_info("lis3lv02d_8b_configure %d \n", p->irq2);
 	if (p->irq2) {
 		err = request_threaded_irq(p->irq2,
-					NULL,
-					lis302dl_interrupt_thread2_8b,
-					IRQF_TRIGGER_RISING | IRQF_ONESHOT |
-					(p->irq_flags2 & IRQF_TRIGGER_MASK),
-					DRIVER_NAME, &lis3_dev);
+				NULL,
+				lis302dl_interrupt_thread2_8b,
+				IRQF_TRIGGER_RISING | IRQF_ONESHOT |
+				(p->irq_flags2 & IRQF_TRIGGER_MASK),
+				DRIVER_NAME, lis3);
+
 		if (err < 0)
-			printk(KERN_ERR DRIVER_NAME
-				"No second IRQ. Limited functionality\n");
+			pr_err("No second IRQ. Limited functionality\n");
 	}
 }
-
+/****************Default Configuration : Omji**************************/
+static void accel(struct lis3lv02d *lis3)
+{
+	lis3->write(lis3, 0x30, 0x0a);
+	lis3->write(lis3, 0x32, 0x10);
+	lis3->write(lis3, 0x20, 0x2f);
+	lis3->write(lis3, 0x21, 0x00);
+	lis3->write(lis3, 0x22, 0x00);
+	lis3->write(lis3, 0x23, 0x00);
+	lis3->write(lis3, 0x24, 0x00);
+	lis3->write(lis3, 0x25, 0x00);
+	lis3->write(lis3, 0x26, 0x00);
+	lis3->write(lis3, 0x27, 0x00);
+	lis3->write(lis3, 0x28, 0x00);
+	lis3->write(lis3, 0x29, 0x00);
+	lis3->write(lis3, 0x31, 0x00);
+	lis3->write(lis3, 0x33, 0x00);
+	lis3->write(lis3, 0x34, 0x00);
+	lis3->write(lis3, 0x35, 0x00);
+	lis3->write(lis3, 0x36, 0x00);
+	lis3->write(lis3, 0x37, 0x00);
+}
+/**********************************************************************/
 /*
  * Initialise the accelerometer and the various subsystems.
  * Should be rather independent of the bus system.
  */
-int lis3lv02d_init_device(struct lis3lv02d *dev)
+int lis3lv02d_init_device(struct lis3lv02d *lis3)
 {
 	int err;
 	irq_handler_t thread_fn;
 	int irq_flags = 0;
 
-	dev->whoami = lis3lv02d_read_8(dev, WHO_AM_I);
+	lis3->whoami = lis3lv02d_read_8(lis3, WHO_AM_I);
+	switch (lis3->whoami) {
+		case WAI_12B:
+			pr_info("12 bits sensor found\n");
+			lis3->read_data = lis3lv02d_read_12;
+			lis3->mdps_max_val = 2048;
+			lis3->pwron_delay = LIS3_PWRON_DELAY_WAI_12B;
+			lis3->odrs = lis3_12_rates;
+			lis3->odr_mask = CTRL1_DF0 | CTRL1_DF1;
+			lis3->scale = LIS3_SENSITIVITY_12B;
+			lis3->regs = lis3_wai12_regs;
+			lis3->regs_size = ARRAY_SIZE(lis3_wai12_regs);
+			break;
+		case WAI_8B:
+			pr_info("8 bits sensor found\n");
+			lis3->read_data = lis3lv02d_read_8;
+			lis3->mdps_max_val = 128;
+			lis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;
+			lis3->odrs = lis3_8_rates;
+			lis3->odr_mask = CTRL1_DR;
+			lis3->scale = LIS3_SENSITIVITY_8B;
+			lis3->regs = lis3_wai8_regs;
+			lis3->regs_size = ARRAY_SIZE(lis3_wai8_regs);
+			break;
+		case WAI_3DC:
+			pr_info("8 bits 3DC sensor found\n");
+			lis3->read_data = lis3lv02d_read_8;
+			lis3->mdps_max_val = 128;
+			lis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;
+			lis3->odrs = lis3_3dc_rates;
+			lis3->odr_mask = CTRL1_ODR0|CTRL1_ODR1|CTRL1_ODR2|CTRL1_ODR3;
+			lis3->scale = LIS3_SENSITIVITY_8B;
+			break;
+		case WAI_3DLH:                                                          //Using
+			pr_info("16 bits lis331dlh sensor found\n");
+			lis3->read_data = lis331dlh_read_data;
+			lis3->mdps_max_val = 2048; /* 12 bits for 2G */
+			lis3->shift_adj = SHIFT_ADJ_2G;
+			lis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;
+			lis3->odrs = lis3_3dlh_rates;
+			lis3->odr_mask = CTRL1_DR0 | CTRL1_DR1;
+			lis3->scale = LIS3DLH_SENSITIVITY_2G;
+			break;
 
-	switch (dev->whoami) {
-	case WAI_12B:
-		printk(KERN_INFO DRIVER_NAME ": 12 bits sensor found\n");
-		dev->read_data = lis3lv02d_read_12;
-		dev->mdps_max_val = 2048;
-		dev->pwron_delay = LIS3_PWRON_DELAY_WAI_12B;
-		dev->odrs = lis3_12_rates;
-		dev->odr_mask = CTRL1_DF0 | CTRL1_DF1;
-		dev->scale = LIS3_SENSITIVITY_12B;
-		dev->regs = lis3_wai12_regs;
-		dev->regs_size = ARRAY_SIZE(lis3_wai12_regs);
-		break;
-	case WAI_8B:
-		printk(KERN_INFO DRIVER_NAME ": 8 bits sensor found\n");
-		dev->read_data = lis3lv02d_read_8;
-		dev->mdps_max_val = 128;
-		dev->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;
-		dev->odrs = lis3_8_rates;
-		dev->odr_mask = CTRL1_DR;
-		dev->scale = LIS3_SENSITIVITY_8B;
-		dev->regs = lis3_wai8_regs;
-		dev->regs_size = ARRAY_SIZE(lis3_wai8_regs);
-		break;
-	case WAI_3DC:
-		printk(KERN_INFO DRIVER_NAME ": 8 bits 3DC sensor found\n");
-		dev->read_data = lis3lv02d_read_8;
-		dev->mdps_max_val = 128;
-		dev->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;
-		dev->odrs = lis3_3dc_rates;
-		dev->odr_mask = CTRL1_ODR0|CTRL1_ODR1|CTRL1_ODR2|CTRL1_ODR3;
-		dev->scale = LIS3_SENSITIVITY_8B;
-		break;
-	default:
-		printk(KERN_ERR DRIVER_NAME
-			": unknown sensor type 0x%X\n", dev->whoami);
-		return -EINVAL;
+		default:
+			pr_err("unknown sensor type 0x%X\n", lis3->whoami);
+			return -EINVAL;
 	}
 
-	dev->reg_cache = kzalloc(max(sizeof(lis3_wai8_regs),
-				     sizeof(lis3_wai12_regs)), GFP_KERNEL);
 
-	if (dev->reg_cache == NULL) {
+	lis3->reg_cache = kzalloc(max(sizeof(lis3_wai8_regs),
+				sizeof(lis3_wai12_regs)), GFP_KERNEL);
+
+	if (lis3->reg_cache == NULL) {
 		printk(KERN_ERR DRIVER_NAME "out of memory\n");
 		return -ENOMEM;
 	}
 
-	mutex_init(&dev->mutex);
-	atomic_set(&dev->wake_thread, 0);
+	mutex_init(&lis3->mutex);
+	atomic_set(&lis3->wake_thread, 1);				//Omji
 
-	lis3lv02d_add_fs(dev);
-	lis3lv02d_poweron(dev);
+	lis3lv02d_add_fs(lis3);
+	err = lis3lv02d_poweron(lis3);
+	if (err) {
+		lis3lv02d_remove_fs(lis3);
+		return err;
+	}
 
-	if (dev->pm_dev) {
-		pm_runtime_set_active(dev->pm_dev);
-		pm_runtime_enable(dev->pm_dev);
+	if (lis3->pm_dev) {
+		pm_runtime_set_active(lis3->pm_dev);
+		pm_runtime_enable(lis3->pm_dev);
 	}
 
-	if (lis3lv02d_joystick_enable())
-		printk(KERN_ERR DRIVER_NAME ": joystick initialization failed\n");
 
 	/* passing in platform specific data is purely optional and only
 	 * used by the SPI transport layer at the moment */
-	if (dev->pdata) {
-		struct lis3lv02d_platform_data *p = dev->pdata;
+	if (lis3->pdata) {
+		struct lis3lv02d_platform_data *p = lis3->pdata;
 
-		if (dev->whoami == WAI_8B)
-			lis3lv02d_8b_configure(dev, p);
+		if (lis3->whoami == WAI_8B)
+			lis3lv02d_8b_configure(lis3, p);
 
 		irq_flags = p->irq_flags1 & IRQF_TRIGGER_MASK;
 
-		dev->irq_cfg = p->irq_cfg;
+		lis3->irq_cfg = p->irq_cfg;
 		if (p->irq_cfg)
-			dev->write(dev, CTRL_REG3, p->irq_cfg);
-
+			accel(lis3);
 		if (p->default_rate)
-			lis3lv02d_set_odr(p->default_rate);
+			lis3lv02d_set_odr(lis3, p->default_rate);
 	}
 
 	/* bail if we did not get an IRQ from the bus layer */
-	if (!dev->irq) {
-		printk(KERN_ERR DRIVER_NAME
-			": No IRQ. Disabling /dev/freefall\n");
+	if (!lis3->irq) {
+		pr_debug("No IRQ. Disabling /dev/freefall\n");
 		goto out;
 	}
 
@@ -973,29 +1422,28 @@
 	 * io-apic is not configurable (and generates a warning) but I keep it
 	 * in case of support for other hardware.
 	 */
-	if (dev->pdata && dev->whoami == WAI_8B)
-		thread_fn = lis302dl_interrupt_thread1_8b;
-	else
-		thread_fn = NULL;
-
-	err = request_threaded_irq(dev->irq, lis302dl_interrupt,
-				thread_fn,
-				IRQF_TRIGGER_RISING | IRQF_ONESHOT |
-				irq_flags,
-				DRIVER_NAME, &lis3_dev);
+	thread_fn = lis302dl_interrupt_thread1_8b;					//Omji
+	err = request_threaded_irq(lis3->irq, lis302dl_interrupt,
+			thread_fn,
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT | irq_flags,
+			DRIVER_NAME, lis3);
 
 	if (err < 0) {
-		printk(KERN_ERR DRIVER_NAME "Cannot get IRQ\n");
+		pr_err("Cannot get IRQ\n");
 		goto out;
 	}
 
-	if (misc_register(&lis3lv02d_misc_device))
-		printk(KERN_ERR DRIVER_NAME ": misc_register failed\n");
+	lis3->miscdev.minor	= MISC_DYNAMIC_MINOR;
+	lis3->miscdev.name	= "freefall";
+	lis3->miscdev.fops	= &lis3lv02d_misc_fops;
+
+	if (misc_register(&lis3->miscdev))
+		pr_err("misc_register failed\n");
 out:
 	return 0;
 }
 EXPORT_SYMBOL_GPL(lis3lv02d_init_device);
 
 MODULE_DESCRIPTION("ST LIS3LV02Dx three-axis digital accelerometer driver");
-MODULE_AUTHOR("Yan Burman, Eric Piel, Pavel Machek");
+MODULE_AUTHOR("Yan Burman, Eric Piel, Pavel Machek, Omji Mishra");
 MODULE_LICENSE("GPL");
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d.h	2014-08-07 11:51:55.570748545 -0600
@@ -21,6 +21,7 @@
 #include <linux/platform_device.h>
 #include <linux/input-polldev.h>
 #include <linux/regulator/consumer.h>
+#include <linux/miscdevice.h>
 
 /*
  * This driver tries to support the "digital" accelerometer chips from
@@ -94,13 +95,29 @@
 	DD_THSE_H	= 0x3F,
 };
 
+enum lis331dlh_reg {
+	CTRL_REG5	= 0x24,
+	HP_FILTER_RESET_3DLH	= 0x25,
+	REFERENCE	= 0x26,
+};
+
 enum lis3_who_am_i {
+	WAI_3DLH	= 0x32,	/* 8 bits: LIS331DLH */
 	WAI_3DC		= 0x33,	/* 8 bits: LIS3DC, HP3DC */
 	WAI_12B		= 0x3A, /* 12 bits: LIS3LV02D[LQ]... */
 	WAI_8B		= 0x3B, /* 8 bits: LIS[23]02D[LQ]... */
 	WAI_6B		= 0x52, /* 6 bits: LIS331DLF - not supported */
 };
 
+enum lis3_type {
+	LIS3DC,
+	HP3DC,
+	LIS3LV02D,
+	LIS2302D,
+	LIS331DLF,
+	LIS331DLH,
+};
+
 enum lis3lv02d_ctrl1_12b {
 	CTRL1_Xen	= 0x01,
 	CTRL1_Yen	= 0x02,
@@ -128,6 +145,32 @@
 	CTRL1_ODR3	= 0x80,
 };
 
+enum lis331dlh_ctrl1 {
+	CTRL1_DR0	= 0x08,
+	CTRL1_DR1	= 0x10,
+	CTRL1_PM0	= 0x20,
+	CTRL1_PM1	= 0x40,
+	CTRL1_PM2	= 0x80,
+};
+
+enum lis331dlh_ctrl2 {
+	CTRL2_HPEN1	= 0x04,
+	CTRL2_HPEN2	= 0x08,
+	CTRL2_FDS_3DLH	= 0x10,
+	CTRL2_BOOT_3DLH	= 0x80,
+};
+
+enum lis331dlh_ctrl4 {
+	CTRL4_STSIGN	= 0x08,
+	CTRL4_BLE	= 0x40,
+	CTRL4_BDU	= 0x80,
+};
+
+enum lis331dlh_ctrl5 {
+	CTRL5_TURNON0	= 0x01,
+	CTRL5_TURNON1	= 0x20,
+};
+
 enum lis3lv02d_ctrl2 {
 	CTRL2_DAS	= 0x01,
 	CTRL2_SIM	= 0x02,
@@ -147,6 +190,13 @@
 	CTRL4_FS1	= 0x20,
 };
 
+/* Measurement Range */
+enum lis3lv02d_fs {
+	FS_2G_REGVAL = 0x00,
+	FS_4G_REGVAL = 0x10,
+	FS_8G_REGVAL = 0x30,
+};
+
 enum lis302d_ctrl2 {
 	HP_FF_WU2	= 0x08,
 	HP_FF_WU1	= 0x04,
@@ -184,6 +234,10 @@
 	FF_WU_CFG_AOI	= 0x80,
 };
 
+enum lis331dlh_ff_wu_cfg {
+	FF_WU_CFG_6D	= 0x40,
+};
+
 enum lis3lv02d_ff_wu_src {
 	FF_WU_SRC_XL	= 0x01,
 	FF_WU_SRC_XH	= 0x02,
@@ -205,6 +259,10 @@
 	DD_CFG_IEND	= 0x80,
 };
 
+enum lis331dlh_dd_cfg {
+	DD_CFG_6D	= 0x40,
+};
+
 enum lis3lv02d_dd_src {
 	DD_SRC_XL	= 0x01,
 	DD_SRC_XH	= 0x02,
@@ -273,19 +331,24 @@
 	struct fasync_struct	*async_queue; /* queue for the misc device */
 	wait_queue_head_t	misc_wait; /* Wait queue for the misc device */
 	unsigned long		misc_opened; /* bit0: whether the device is open */
+	struct miscdevice	miscdev;
+
 	int                     data_ready_count[2];
 	atomic_t		wake_thread;
 	unsigned char           irq_cfg;
 
 	struct lis3lv02d_platform_data *pdata;	/* for passing board config */
 	struct mutex		mutex;     /* Serialize poll and selftest */
+	u8			g_range; /* Hold the g range */
+	u8			shift_adj;
+	u8 			enable;
 };
 
 int lis3lv02d_init_device(struct lis3lv02d *lis3);
-int lis3lv02d_joystick_enable(void);
-void lis3lv02d_joystick_disable(void);
+int lis3lv02d_joystick_enable(struct lis3lv02d *lis3);
+void lis3lv02d_joystick_disable(struct lis3lv02d *lis3);
 void lis3lv02d_poweroff(struct lis3lv02d *lis3);
-void lis3lv02d_poweron(struct lis3lv02d *lis3);
+int lis3lv02d_poweron(struct lis3lv02d *lis3);
 int lis3lv02d_remove_fs(struct lis3lv02d *lis3);
 
 extern struct lis3lv02d lis3_dev;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d_i2c.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d_i2c.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d_i2c.c	2014-08-07 11:51:55.570748545 -0600
@@ -33,7 +33,7 @@
 #include <linux/delay.h>
 #include "lis3lv02d.h"
 
-#define DRV_NAME 	"lis3lv02d_i2c"
+#define DRV_NAME	"lis3lv02d_i2c"
 
 static const char reg_vdd[]    = "Vdd";
 static const char reg_vdd_io[] = "Vdd_IO";
@@ -79,8 +79,7 @@
 	u8 reg;
 	int ret;
 
-	if (lis3->reg_ctrl)
-		lis3_reg_ctrl(lis3, LIS3_REG_ON);
+	lis3_reg_ctrl(lis3, LIS3_REG_ON);
 
 	lis3->read(lis3, WHO_AM_I, &reg);
 	if (reg != lis3->whoami)
@@ -91,7 +90,10 @@
 	if (ret < 0)
 		return ret;
 
-	reg |= CTRL1_PD0 | CTRL1_Xen | CTRL1_Yen | CTRL1_Zen;
+	if (lis3->whoami == WAI_3DLH)
+		reg |= CTRL1_PM0 | CTRL1_Xen | CTRL1_Yen | CTRL1_Zen;
+	else
+		reg |= CTRL1_PD0 | CTRL1_Xen | CTRL1_Yen | CTRL1_Zen;
 	return lis3->write(lis3, CTRL_REG1, reg);
 }
 
@@ -106,10 +108,6 @@
 	struct lis3lv02d_platform_data *pdata = client->dev.platform_data;
 
 	if (pdata) {
-		/* Regulator control is optional */
-		if (pdata->driver_features & LIS3_USE_REGULATOR_CTRL)
-			lis3_dev.reg_ctrl = lis3_reg_ctrl;
-
 		if ((pdata->driver_features & LIS3_USE_BLOCK_READ) &&
 			(i2c_check_functionality(client->adapter,
 						I2C_FUNC_SMBUS_I2C_BLOCK)))
@@ -131,15 +129,13 @@
 			goto fail;
 	}
 
-	if (lis3_dev.reg_ctrl) {
-		lis3_dev.regulators[0].supply = reg_vdd;
-		lis3_dev.regulators[1].supply = reg_vdd_io;
-		ret = regulator_bulk_get(&client->dev,
-					ARRAY_SIZE(lis3_dev.regulators),
-					lis3_dev.regulators);
-		if (ret < 0)
-			goto fail;
-	}
+	lis3_dev.regulators[0].supply = reg_vdd;
+	lis3_dev.regulators[1].supply = reg_vdd_io;
+	ret = regulator_bulk_get(&client->dev,
+				 ARRAY_SIZE(lis3_dev.regulators),
+				 lis3_dev.regulators);
+	if (ret < 0)
+		goto fail;
 
 	lis3_dev.pdata	  = pdata;
 	lis3_dev.bus_priv = client;
@@ -153,16 +149,19 @@
 	i2c_set_clientdata(client, &lis3_dev);
 
 	/* Provide power over the init call */
-	if (lis3_dev.reg_ctrl)
-		lis3_reg_ctrl(&lis3_dev, LIS3_REG_ON);
+	lis3_reg_ctrl(&lis3_dev, LIS3_REG_ON);
 
 	ret = lis3lv02d_init_device(&lis3_dev);
 
-	if (lis3_dev.reg_ctrl)
-		lis3_reg_ctrl(&lis3_dev, LIS3_REG_OFF);
+	lis3_reg_ctrl(&lis3_dev, LIS3_REG_OFF);
 
-	if (ret == 0)
-		return 0;
+	if (ret)
+		goto fail2;
+	return 0;
+
+fail2:
+	regulator_bulk_free(ARRAY_SIZE(lis3_dev.regulators),
+				lis3_dev.regulators);
 fail:
 	if (pdata && pdata->release_resources)
 		pdata->release_resources();
@@ -177,12 +176,11 @@
 	if (pdata && pdata->release_resources)
 		pdata->release_resources();
 
-	lis3lv02d_joystick_disable();
+	lis3lv02d_joystick_disable(lis3);
 	lis3lv02d_remove_fs(&lis3_dev);
 
-	if (lis3_dev.reg_ctrl)
-		regulator_bulk_free(ARRAY_SIZE(lis3->regulators),
-				lis3_dev.regulators);
+	regulator_bulk_free(ARRAY_SIZE(lis3->regulators),
+			    lis3_dev.regulators);
 	return 0;
 }
 
@@ -237,6 +235,7 @@
 
 static const struct i2c_device_id lis3lv02d_id[] = {
 	{"lis3lv02d", 0 },
+	{"lis331dlh", LIS331DLH},
 	{}
 };
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d_spi.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d_spi.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/hwmon/lis3lv02d_spi.c	2014-08-07 11:51:55.582748544 -0600
@@ -16,6 +16,7 @@
 #include <linux/interrupt.h>
 #include <linux/workqueue.h>
 #include <linux/spi/spi.h>
+#include <linux/pm.h>
 
 #include "lis3lv02d.h"
 
@@ -82,15 +83,16 @@
 static int __devexit lis302dl_spi_remove(struct spi_device *spi)
 {
 	struct lis3lv02d *lis3 = spi_get_drvdata(spi);
-	lis3lv02d_joystick_disable();
+	lis3lv02d_joystick_disable(lis3);
 	lis3lv02d_poweroff(lis3);
 
 	return lis3lv02d_remove_fs(&lis3_dev);
 }
 
-#ifdef CONFIG_PM
-static int lis3lv02d_spi_suspend(struct spi_device *spi, pm_message_t mesg)
+#ifdef CONFIG_PM_SLEEP
+static int lis3lv02d_spi_suspend(struct device *dev)
 {
+	struct spi_device *spi = to_spi_device(dev);
 	struct lis3lv02d *lis3 = spi_get_drvdata(spi);
 
 	if (!lis3->pdata || !lis3->pdata->wakeup_flags)
@@ -99,8 +101,9 @@
 	return 0;
 }
 
-static int lis3lv02d_spi_resume(struct spi_device *spi)
+static int lis3lv02d_spi_resume(struct device *dev)
 {
+	struct spi_device *spi = to_spi_device(dev);
 	struct lis3lv02d *lis3 = spi_get_drvdata(spi);
 
 	if (!lis3->pdata || !lis3->pdata->wakeup_flags)
@@ -108,21 +111,19 @@
 
 	return 0;
 }
-
-#else
-#define lis3lv02d_spi_suspend	NULL
-#define lis3lv02d_spi_resume	NULL
 #endif
 
+static SIMPLE_DEV_PM_OPS(lis3lv02d_spi_pm, lis3lv02d_spi_suspend,
+			 lis3lv02d_spi_resume);
+
 static struct spi_driver lis302dl_spi_driver = {
 	.driver	 = {
 		.name   = DRV_NAME,
 		.owner  = THIS_MODULE,
+		.pm	= &lis3lv02d_spi_pm,
 	},
 	.probe	= lis302dl_spi_probe,
 	.remove	= __devexit_p(lis302dl_spi_remove),
-	.suspend = lis3lv02d_spi_suspend,
-	.resume  = lis3lv02d_spi_resume,
 };
 
 static int __init lis302dl_init(void)
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/leds/Kconfig	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/Kconfig	2014-08-07 11:51:55.594748544 -0600
@@ -152,6 +152,16 @@
 	  LED controller. It is generally only useful
 	  as a platform driver
 
+config LEDS_PCA9634
+        tristate "FS LED driver for PCA9634 dimmer"
+        depends on LEDS_CLASS
+        depends on I2C && EXPERIMENTAL
+        help
+          This option enables support for NXP pca9532
+          LED controller. It is generally only useful
+          as a platform driver
+
+
 config LEDS_GPIO
 	tristate "LED Support for GPIO connected LEDs"
 	depends on LEDS_CLASS
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/Makefile
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/leds/Makefile	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/Makefile	2014-08-07 11:51:55.598748543 -0600
@@ -21,6 +21,7 @@
 obj-$(CONFIG_LEDS_COBALT_RAQ)		+= leds-cobalt-raq.o
 obj-$(CONFIG_LEDS_SUNFIRE)		+= leds-sunfire.o
 obj-$(CONFIG_LEDS_PCA9532)		+= leds-pca9532.o
+obj-$(CONFIG_LEDS_PCA9634)		+= pca9634.o
 obj-$(CONFIG_LEDS_GPIO)			+= leds-gpio.o
 obj-$(CONFIG_LEDS_LP3944)		+= leds-lp3944.o
 obj-$(CONFIG_LEDS_LP5521)		+= leds-lp5521.o
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/leds-pca955x.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/leds/leds-pca955x.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/leds-pca955x.c	2014-08-07 11:51:55.602748543 -0600
@@ -58,7 +58,7 @@
 
 enum pca955x_type {
 	pca9550,
-	pca9551,
+	pca9634,
 	pca9552,
 	pca9553,
 };
@@ -75,10 +75,10 @@
 		.slv_addr	= /* 110000x */ 0x60,
 		.slv_addr_shift	= 1,
 	},
-	[pca9551] = {
+	[pca9634] = {
 		.bits		= 8,
-		.slv_addr	= /* 1100xxx */ 0x60,
-		.slv_addr_shift	= 3,
+		.slv_addr	= /* 1100xxx */ 0x05,
+	//	.slv_addr_shift	= 3,
 	},
 	[pca9552] = {
 		.bits		= 16,
@@ -94,7 +94,7 @@
 
 static const struct i2c_device_id pca955x_id[] = {
 	{ "pca9550", pca9550 },
-	{ "pca9551", pca9551 },
+	{ "pca9634", pca9634 },
 	{ "pca9552", pca9552 },
 	{ "pca9553", pca9553 },
 	{ }
@@ -259,12 +259,12 @@
 	pdata = client->dev.platform_data;
 
 	/* Make sure the slave address / chip type combo given is possible */
-	if ((client->addr & ~((1 << chip->slv_addr_shift) - 1)) !=
-	    chip->slv_addr) {
-		dev_err(&client->dev, "invalid slave address %02x\n",
+//	if ((client->addr & ~((1 << chip->slv_addr_shift) - 1)) !=
+//	    chip->slv_addr) {
+		printk("Valid slave address %02x\n",
 				client->addr);
-		return -ENODEV;
-	}
+//	return -ENODEV;
+//	}
 
 	printk(KERN_INFO "leds-pca955x: Using %s %d-bit LED driver at "
 			"slave address 0x%02x\n",
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/pca9634.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/pca9634.c	2014-08-07 11:51:55.602748543 -0600
@@ -0,0 +1,225 @@
+ /*
+  *  FOSSIL SHALE PWM DRIVER
+  *  Copyright (C) 2013
+  *
+  *  This program is free software; you can redistribute it and/or modify
+  *  it under the terms of the GNU General Public License as published by
+  *  the Free Software Foundation; version 2 of the License.
+  *
+  *  DONE:
+  *      This driver is basically for controlling brightness ( pwm output )
+  *      through sysfs entry . The brightness or duty cycle can be set to
+  *      any of the value from 0 , 20 , 40 , 60 , 80 or 100.
+  *
+  *      Also the current duty cycle can be read and displayed from sysfs
+  *      entry
+  *
+  *      Default duty cycle of all pwm output is set to 50 percent
+  *
+  */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/leds.h>
+
+#include "pca9634.h"
+
+struct pca9634_data {
+	struct i2c_client *client;
+	struct mutex lock;
+};
+
+static struct i2c_driver pca9634_driver;
+
+static int pca9634_probe(struct i2c_client *client, const struct i2c_device_id *id);
+
+static int pca9634_remove(struct i2c_client *client);
+
+
+static int __reg_write(struct i2c_client *client, u_int8_t reg, u_int8_t val)
+{
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static int32_t __reg_read(struct i2c_client *client, u_int8_t reg)
+{
+	int32_t ret;
+	ret = i2c_smbus_read_byte_data(client, reg);
+
+	return ret;
+}
+
+static inline int calc_dc(uint8_t idc)
+{
+	return ((256 - idc) * 100) / 256;
+}
+
+static int reg_id_by_name(const char *name)
+{
+	int reg_id = -1;
+
+	if (!strncmp(name, "led0", 4))
+		reg_id = PCA9634_REG_PWM0;
+	return reg_id;
+}
+
+
+/*
+ * Individual brightness control
+ */
+static ssize_t show_brightness(struct device *dev, struct device_attribute
+		*attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ldrx;
+
+	ldrx = reg_id_by_name(attr->attr.name);
+	return sprintf(buf, "%d%% \n", calc_dc(__reg_read(client, ldrx)));
+}
+
+static ssize_t set_brightness(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	unsigned long int pwm = simple_strtoul(buf, NULL, 10);
+	int ldrx;
+
+	ldrx = reg_id_by_name(attr->attr.name);
+	__reg_write(client, ldrx , pwm);
+
+	return count;
+}
+
+static
+DEVICE_ATTR(led0_pwm , S_IRUGO | S_IWUSR, show_brightness, set_brightness);
+
+
+static struct attribute *pca_sysfs_entries[] = {
+	&dev_attr_led0_pwm.attr,
+	NULL
+};
+
+static struct attribute_group pca_attr_group = {
+	.name   = NULL,                 /* put in device directory */
+	.attrs  = pca_sysfs_entries,
+};
+
+#ifdef CONFIG_PM
+static int pca9634_suspend(struct device *dev, pm_message_t state)
+{
+	/* FIXME: Not implemented */
+	return 0;
+}
+
+static int pca9634_resume(struct device *dev)
+{
+	/* FIXME: Not implemented */
+	return 0;
+}
+#else
+#define pca9634_suspend NULL
+#define pca9634_resume NULL
+#endif
+
+static void set_pca9634_default(struct i2c_client *client)
+{
+	i2c_smbus_write_byte_data(client, PCA9634_REG_MODE1 , 0x01);
+	/* low power mode. oscillator on */
+	i2c_smbus_write_byte_data(client, PCA9634_REG_MODE2 , 0x05);
+	/* set group duty cycle control to default 50 percent */
+
+	i2c_smbus_write_byte_data(client, PCA9634_REG_GRPPWM , 0xff);
+	/* set group frequency to default */
+	i2c_smbus_write_byte_data(client, PCA9634_REG_GRPFREQ , 0x00);
+	/*
+	 * set LEDx individual brightness and group dimming/blinking
+	 * can be controlled by * its PWMx register and GRPPWM registers.
+	 */
+	i2c_smbus_write_byte_data(client, PCA9634_REG_LEDOUT0 , 0xff);
+	i2c_smbus_write_byte_data(client, PCA9634_REG_LEDOUT1 , 0xff);
+
+	i2c_smbus_write_byte_data(client, PCA9634_REG_PWM0 , 0xff);
+	i2c_smbus_write_byte_data(client, PCA9634_REG_PWM4 , 0x00);
+	mdelay(500);
+	i2c_smbus_write_byte_data(client, PCA9634_REG_PWM3 , 0x00);
+	mdelay(100);
+	i2c_smbus_write_byte_data(client, PCA9634_REG_PWM7 , 0x00);
+	mdelay(100);
+	i2c_smbus_write_byte_data(client, PCA9634_REG_PWM0 , 0x66);
+}
+
+static int pca9634_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+	struct pca9634_data *pca;
+	int err;
+	pca = kzalloc(sizeof(*pca), GFP_KERNEL);
+	if (!pca)
+		return -ENOMEM;
+
+
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE_DATA))
+		return -ENODEV;
+
+	err = sysfs_create_group(&client->dev.kobj, &pca_attr_group);
+	if(err)
+	{
+		printk("SOM : ERROR in creating the sysfs in probe\n");
+	}
+	i2c_set_clientdata(client, pca);
+	set_pca9634_default(client);
+	return 0;
+
+};
+
+static int pca9634_remove(struct i2c_client *client)
+{
+
+	struct pca9634_data *pca= i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &pca_attr_group);
+	kfree(pca);
+	return 0;
+};
+
+
+static const struct i2c_device_id pca9634_id[] = {
+	{ "pca9634", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, pca9634_id);
+
+static struct i2c_driver pca9634_driver = {
+	.driver = {
+		.name = "pca9634",
+		.suspend = pca9634_suspend,
+		.resume  = pca9634_resume,
+
+	},
+	.probe = pca9634_probe,
+	.remove = pca9634_remove,
+	.id_table = pca9634_id,
+};
+
+
+static int __init pca9634_init(void)
+{
+	return i2c_add_driver(&pca9634_driver);
+}
+
+static void __exit pca9634_exit(void)
+{
+	i2c_del_driver(&pca9634_driver);
+}
+
+MODULE_AUTHOR("OMJI MISHRA & ROHIT Y SHANBHAG");
+MODULE_DESCRIPTION("FS PCA9634 driver");
+MODULE_LICENSE("GPL");
+
+module_init(pca9634_init);
+module_exit(pca9634_exit);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/pca9634.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/leds/pca9634.h	2014-08-07 11:51:55.602748543 -0600
@@ -0,0 +1,36 @@
+//  Changes are done on basis of PCA964 datasheet page 10
+//  Can be verified
+
+#ifndef _PCA9634_H
+#define _PCA9634_H
+
+
+enum pca9634_regs{
+
+        PCA9634_REG_MODE1       = 0x00,			//Mode register 1
+	PCA9634_REG_MODE2       = 0x01,			//Mode Register 2
+
+	PCA9634_REG_PWM0        = 0x02,			//brightness control LED0
+	PCA9634_REG_PWM1        = 0x03,			//brightness control LED1
+	PCA9634_REG_PWM2        = 0x04,			//brightness control LED2
+	PCA9634_REG_PWM3        = 0x05,			//brightness control LED3
+	PCA9634_REG_PWM4        = 0x06,			//OMJI : brightness control LED4
+	PCA9634_REG_PWM5        = 0x07,			//OMJI : brightness control LED5
+	PCA9634_REG_PWM6        = 0x08,			//OMJI : brightness control LED6
+	PCA9634_REG_PWM7        = 0x09,			//OMJI : brightness control LED7
+
+	PCA9634_REG_GRPPWM      = 0x0a,			//group duty cycle control
+	PCA9634_REG_GRPFREQ     = 0x0b,			//group frequency
+
+	PCA9634_REG_LEDOUT0     = 0x0c,			//LED output state 0
+	PCA9634_REG_LEDOUT1     = 0x0d,			//OMJI : LED output state 1
+
+	PCA9634_REG_SUBADDR1    = 0x0e,
+	PCA9634_REG_SUBADDR2    = 0x0f,
+	PCA9634_REG_SUBADDR3    = 0x10,
+	PCA9634_REG_ALLCALLADR1 = 0x11,
+};
+
+#define PCA9634_DMBLNK_SHIFT    5			//check
+
+#endif /* _PCA9634_H */
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/ti81xx/ti81xxvid.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/ti81xx/ti81xxvid.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/ti81xx/ti81xxvid.h	2014-08-07 14:42:24.000000000 -0600
@@ -71,6 +71,10 @@
 	enum v4l2_buf_type type;
 	struct videobuf_queue vbq;
 
+	/*Scalar parameters*/
+	struct ti81xxvid_scalarparam scalar_prms;
+	unsigned long scoutbuf; /* temporary buffer for scalar o/p*/
+
 };
 
 struct ti81xxvideo_device {
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/tvp5150.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/tvp5150.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/tvp5150.c	2014-08-07 11:51:55.654748541 -0600
@@ -1075,13 +1075,32 @@
 		 c->addr << 1, c->adapter->name);
 
 	core->norm = V4L2_STD_ALL;	/* Default is autodetect */
-	core->input = TVP5150_COMPOSITE1;
+	core->input = TVP5150_COMPOSITE0;
 	core->enable = 1;
-	core->bright = 128;
-	core->contrast = 128;
+	core->bright = 100;
+	core->contrast = 100;
 	core->hue = 0;
-	core->sat = 128;
+	core->sat = 170;
 
+
+	tvp5150_write_inittab(sd, tvp5150_init_enable);
+//	tvp5150_write(sd, TVP5150_VD_IN_SRC_SEL_1, 0x00);
+	tvp5150_write(sd, TVP5150_MISC_CTL, 0x09);
+/*	tvp5150_write(sd, TVP5150_OP_MODE_CTL, 0x30);
+	tvp5150_write(sd, TVP5150_AUTOSW_MSK, 0xec);
+	tvp5150_write(sd, TVP5150_CONF_SHARED_PIN, 0x00);
+	tvp5150_write(sd, TVP5150_DATA_RATE_SEL, 0x47); //40 - discrete sync, 47 - embeded sync.
+	tvp5150_write(sd, TVP5150_VIDEO_STD, 0x00);*/
+
+//	tvp5150_write_inittab(sd, tvp5150_init_enable);
+
+	/* Initialize image preferences */
+	tvp5150_write(sd, TVP5150_BRIGHT_CTL, core->bright);
+	tvp5150_write(sd, TVP5150_CONTRAST_CTL, core->contrast);
+	tvp5150_write(sd, TVP5150_SATURATION_CTL, core->contrast);
+	tvp5150_write(sd, TVP5150_HUE_CTL, core->hue);
+
+	tvp5150_vdp_init(sd, vbi_ram_default);
 	if (debug > 1)
 		tvp5150_log_status(sd);
 	return 0;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_driver.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_driver.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_driver.c	2014-08-07 11:51:55.678748540 -0600
@@ -1264,6 +1264,14 @@
 
 		break;
 
+	case UVC_OTT_VENDOR_SPECIFIC:
+	case UVC_OTT_DISPLAY:
+	case UVC_OTT_MEDIA_TRANSPORT_OUTPUT:
+		if (uvc_trace_param & UVC_TRACE_PROBE)
+			printk(" OT %d", entity->id);
+
+		break;
+
 	case UVC_TT_STREAMING:
 		if (UVC_ENTITY_IS_ITERM(entity)) {
 			if (uvc_trace_param & UVC_TRACE_PROBE)
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_queue.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_queue.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_queue.c	2014-08-07 11:51:55.682748540 -0600
@@ -104,6 +104,8 @@
 	}
 
 	if (queue->count) {
+		uvc_queue_cancel(queue, 0);
+		INIT_LIST_HEAD(&queue->mainqueue);
 		vfree(queue->mem);
 		queue->count = 0;
 	}
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_v4l2.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_v4l2.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_v4l2.c	2014-08-07 11:51:55.690748539 -0600
@@ -1035,11 +1035,8 @@
 		return uvc_xu_ctrl_query(chain, arg, 1);
 
 	default:
-		if ((ret = v4l_compat_translate_ioctl(file, cmd, arg,
-			uvc_v4l2_do_ioctl)) == -ENOIOCTLCMD)
-			uvc_trace(UVC_TRACE_IOCTL, "Unknown ioctl 0x%08x\n",
-				  cmd);
-		return ret;
+		uvc_trace(UVC_TRACE_IOCTL, "Unknown ioctl 0x%08x\n", cmd);
+		return -EINVAL;
 	}
 
 	return ret;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_video.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_video.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/uvc/uvc_video.c	2014-08-07 11:51:55.690748539 -0600
@@ -89,15 +89,19 @@
 static void uvc_fixup_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl)
 {
-	struct uvc_format *format;
+	struct uvc_format *format = NULL;
 	struct uvc_frame *frame = NULL;
 	unsigned int i;
 
-	if (ctrl->bFormatIndex <= 0 ||
-	    ctrl->bFormatIndex > stream->nformats)
-		return;
+	for (i = 0; i < stream->nformats; ++i) {
+		if (stream->format[i].index == ctrl->bFormatIndex) {
+			format = &stream->format[i];
+			break;
+		}
+	}
 
-	format = &stream->format[ctrl->bFormatIndex - 1];
+	if (format == NULL)
+		return;
 
 	for (i = 0; i < format->nframes; ++i) {
 		if (format->frame[i].bFrameIndex == ctrl->bFrameIndex) {
@@ -390,11 +394,11 @@
  *
  * uvc_video_decode_end is called with header data at the end of a bulk or
  * isochronous payload. It performs any additional header data processing and
- * returns 0 or a negative error code if an error occured. As header data have
+ * returns 0 or a negative error code if an error occurred. As header data have
  * already been processed by uvc_video_decode_start, this functions isn't
  * required to perform sanity checks a second time.
  *
- * For isochronous transfers where a payload is always transfered in a single
+ * For isochronous transfers where a payload is always transferred in a single
  * URB, the three functions will be called in a row.
  *
  * To let the decoder process header data and update its internal state even
@@ -654,7 +658,7 @@
 							    buf);
 		} while (ret == -EAGAIN);
 
-		/* If an error occured skip the rest of the payload. */
+		/* If an error occurred skip the rest of the payload. */
 		if (ret < 0 || buf == NULL) {
 			stream->bulk.skip_payload = 1;
 		} else {
@@ -817,7 +821,7 @@
 		return stream->urb_size / psize;
 
 	/* Compute the number of packets. Bulk endpoints might transfer UVC
-	 * payloads accross multiple URBs.
+	 * payloads across multiple URBs.
 	 */
 	npackets = DIV_ROUND_UP(size, psize);
 	if (npackets > UVC_MAX_PACKETS)
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/net/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/net/Kconfig	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/net/Kconfig	2014-08-07 11:51:55.706748538 -0600
@@ -2078,7 +2078,7 @@
 	  will be called davinci_mdio.  This is recommended.
 
 config TI_DAVINCI_CPDMA
-	bool "TI DaVinci CPDMA Support"
+	tristate "TI DaVinci CPDMA Support"
 	depends on TI_DAVINCI_EMAC || TI_CPSW
 	help
 	  This driver supports TI's DaVinci CPDMA dma engine.
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/net/cpsw.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/net/cpsw.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/net/cpsw.c	2014-08-07 11:51:55.714748538 -0600
@@ -54,14 +54,7 @@
 #define CPSW_USE_DEFAULT	0x0afbdce1  /**< Flag to indicate use of a
 						default */
 
-#define CPSW_PRIMAP_PRI0(_x_)	(_x_ << 0)
-#define CPSW_PRIMAP_PRI1(_x_)	(_x_ << 4)
-#define CPSW_PRIMAP_PRI2(_x_)	(_x_ << 8)
-#define CPSW_PRIMAP_PRI3(_x_)	(_x_ << 12)
-#define CPSW_PRIMAP_PRI4(_x_)	(_x_ << 16)
-#define CPSW_PRIMAP_PRI5(_x_)	(_x_ << 20)
-#define CPSW_PRIMAP_PRI6(_x_)	(_x_ << 24)
-#define CPSW_PRIMAP_PRI7(_x_)	(_x_ << 28)
+#define CPSW_PRIMAP(shift, priority)    (priority << (shift * 4))
 
 #define CPSW_IRQ_QUIRK
 #ifdef CPSW_IRQ_QUIRK
@@ -82,6 +75,13 @@
 #define cpsw_disable_irq(priv) do { } while (0);
 #endif
 
+#define CPSW_VER_1		0x19010a
+#define CPSW_VER_2		0x19010c
+#define cpsw_slave_reg(priv, slave, reg)				\
+	(((priv)->cpsw_version == CPSW_VER_1) ?				\
+	&(((struct cpsw_slave_regs_v1 *)((slave)->regs))->reg) :	\
+	&(((struct cpsw_slave_regs_v2 *)((slave)->regs))->reg))
+
 #if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
 #define VLAN_SUPPORT
 #endif
@@ -98,6 +98,21 @@
 #define CPTS_TS_HW_PUSH			(0x3 << 20)
 #define CPTS_TS_ETH_RX			(0x4 << 20)
 #define CPTS_TS_ETH_TX			(0x5 << 20)
+#define CPSW_MSG_TYPE_EN		0xffff
+#define CPSW_801_1Q_LTYPE		0x88f7
+#define CPSW_SEQ_ID_OFS			0x1e
+
+#define CPSW_V1_TS_RX_EN		BIT(0)
+#define CPSW_V1_TS_TX_EN		BIT(4)
+#define CPSW_V1_MSG_TYPE_OFS		16
+#define CPSW_V1_SEQ_ID_OFS_SHIFT	16
+
+#define CPSW_V2_TS_RX_EN		BIT(0)
+#define CPSW_V2_TS_TX_EN		BIT(1)
+#define CPSW_V2_TS_LTYPE_1_EN		BIT(2)
+#define CPSW_V2_TS_LTYPE_2_EN		BIT(3)
+#define CPSW_V2_TS_ANNEX_D_EN		BIT(4)
+#define CPSW_V2_SEQ_ID_OFS_SHIFT	16
 
 #define CPTS_FIFO_SIZE			32
 #define CPTS_READ_TS_MAX_TRY		20
@@ -115,9 +130,15 @@
 #define CPSW_CMINTMAX_INTVL	(1000 / CPSW_CMINTMIN_CNT)
 #define CPSW_CMINTMIN_INTVL	((1000 / CPSW_CMINTMAX_CNT) + 1)
 
-#define switchcmd(__xx__)	__xx__.cmd_data.switchcmd
-#define portcmd(__xx__)		__xx__.cmd_data.portcmd
-#define priocmd(__xx__)		__xx__.cmd_data.priocmd
+#define switchcmd(__cmd__)	((__cmd__)->cmd_data.switchcmd)
+#define portcmd(__cmd__)	((__cmd__)->cmd_data.portcmd)
+#define priocmd(__cmd__)	((__cmd__)->cmd_data.priocmd)
+
+#ifdef CONFIG_TI_CPSW_DUAL_EMAC
+#define cpsw_slave_phy_index(priv)	((priv)->emac_port)
+#else
+#define cpsw_slave_phy_index(priv)	0
+#endif
 
 static int debug_level;
 module_param(debug_level, int, 0);
@@ -161,9 +182,11 @@
 	u32	gap_thresh;
 	u32	tx_start_wds;
 	u32	flow_control;
+	u32	vlan_ltype;
+	u32	ts_ltype;
 };
 
-struct cpsw_slave_regs {
+struct cpsw_slave_regs_v1 {
 	u32	max_blks;
 	u32	blk_cnt;
 	u32	flow_thresh;
@@ -174,6 +197,27 @@
 	u32	ts_vlan;
 	u32	sa_lo;
 	u32	sa_hi;
+	/* Dummy resigters */
+	u32	port_control;
+	u32	ts_control;
+	u32	ts_seq_mtype;
+};
+
+struct cpsw_slave_regs_v2 {
+	u32	port_control;
+	u32	ts_control;
+	u32	max_blks;
+	u32	blk_cnt;
+	u32	flow_thresh;
+	u32	port_vlan;
+	u32	tx_pri_map;
+	u32	ts_seq_mtype;
+	u32	sa_lo;
+	u32	sa_hi;
+	/* Dummy resigters */
+	u32	ts_ctl;
+	u32	ts_seq_ltype;
+	u32	ts_vlan;
 };
 
 struct cpsw_host_regs {
@@ -238,7 +282,7 @@
 };
 
 struct cpsw_slave {
-	struct cpsw_slave_regs __iomem	*regs;
+	void __iomem			*regs;
 	struct cpsw_sliver_regs __iomem	*sliver;
 	int				slave_num;
 	u32				mac_control;
@@ -314,6 +358,7 @@
 	struct cpts_time_handle		*cpts_time;
 
 	u8				port_state[3];
+	u32				cpsw_version;
 	u32				msg_enable;
 	u32				coal_intvl;
 	u32				bus_freq_mhz;
@@ -351,7 +396,8 @@
 static int cpsw_set_coalesce(struct net_device *ndev,
 			struct ethtool_coalesce *coal);
 
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+	defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 DEFINE_SPINLOCK(cpts_time_lock);
 static struct cpsw_priv *gpriv;
 static u64 time_push;
@@ -367,13 +413,21 @@
 	if (fifo->tail >= CPTS_FIFO_SIZE)
 		fifo->tail = 0;
 
+	if (fifo->head == fifo->tail) {
+		fifo->fifo[fifo->tail].event_high = 0;
+		fifo->fifo[fifo->tail].ts = 0;
+		fifo->head++;
+		if (fifo->head >= CPTS_FIFO_SIZE)
+			fifo->head = 0;
+	}
+
 	return 0;
 }
 
 static int cpts_time_evts_fifo_pop(struct cpts_evts_fifo *fifo,
 				u32 evt_high, struct cpts_time_evts *evt)
 {
-	u32 i;
+	u32 i, ev_found = 0;
 
 	if (fifo->head == fifo->tail)
 		return -1;
@@ -386,16 +440,21 @@
 
 			fifo->fifo[i].event_high = 0;
 			fifo->fifo[i].ts = 0;
-
+			ev_found = 1;
+		}
+		if (fifo->fifo[i].event_high == 0 && i == fifo->head) {
 			fifo->head++;
 			if (fifo->head >= CPTS_FIFO_SIZE)
 				fifo->head = 0;
-			return 0;
 		}
+		if (ev_found)
+			return 0;
 		i++;
 		if (i >= CPTS_FIFO_SIZE)
 			i = 0;
 	}
+	printk(KERN_DEBUG "cpts_time_evts_fifo_pop() evt %05x not found\n",
+			evt_high);
 	return 0;
 }
 
@@ -410,17 +469,20 @@
 
 		event_high = __raw_readl(&priv->cpts_reg->event_high);
 		event_tslo = __raw_readl(&priv->cpts_reg->event_low);
+		__raw_writel(0x01, &priv->cpts_reg->event_pop);
+
+		if (priv->cpts_time->first_half &&
+				event_tslo & 0x80000000) {
+			/* this is misaligned ts */
+			ts = (u64)(priv->cpts_time->tshi - 1);
+		} else {
+			ts = (u64)(priv->cpts_time->tshi);
+		}
+		ts = (ts << 32) | event_tslo;
 
 		if ((event_high & 0xf00000) == CPTS_TS_PUSH) {
 			/*Push TS to Read */
-			if (priv->cpts_time->first_half &&
-					event_tslo & 0x80000000) {
-				/* this is misaligned ts */
-				ts = (u64)(priv->cpts_time->tshi - 1);
-			} else {
-				ts = (u64)(priv->cpts_time->tshi);
-			}
-			time_push = (ts << 32) | event_tslo;
+			time_push = ts;
 		} else if ((event_high & 0xf00000) == CPTS_TS_ROLLOVER) {
 			/* Roll over */
 			spin_lock_irqsave(&cpts_time_lock, flags);
@@ -443,14 +505,7 @@
 			evt.event_high = event_high & 0xfffff;
 			evt.ts = event_tslo;
 
-			if (priv->cpts_time->first_half &&
-					event_tslo & 0x80000000) {
-				/* this is misaligned ts */
-				ts = (u64)(priv->cpts_time->tshi - 1);
-			} else {
-				ts = (u64)(priv->cpts_time->tshi);
-			}
-			evt.ts |= ts << 32;
+			evt.ts = ts;
 			if (priv->cpts_time->enable_timestamping) {
 				spin_lock_irqsave(&cpts_time_lock, flags);
 				cpts_time_evts_fifo_push(
@@ -463,14 +518,8 @@
 
 			evt.event_high = event_high & 0xfffff;
 			evt.ts = event_tslo;
-			if (priv->cpts_time->first_half &&
-					event_tslo & 0x80000000) {
-				/* this is misaligned ts */
-				ts = (u64)(priv->cpts_time->tshi - 1);
-			} else {
-				ts = (u64)(priv->cpts_time->tshi);
-			}
-			evt.ts |= ts << 32;
+
+			evt.ts = ts;
 			if (priv->cpts_time->enable_timestamping) {
 				spin_lock_irqsave(&cpts_time_lock, flags);
 				cpts_time_evts_fifo_push(
@@ -481,7 +530,6 @@
 			printk(KERN_ERR "Invalid CPTS Event type...\n");
 		}
 
-		__raw_writel(0x01, &priv->cpts_reg->event_pop);
 		cpdma_ctlr_eoi_statistics(priv->dma);
 	}
 	return 0;
@@ -500,6 +548,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(cpts_systime_write);
 
 int cpts_systime_read(u64 *ns)
 {
@@ -511,6 +560,7 @@
 		return -ENODEV;
 	}
 
+	time_push = 0;
 	__raw_writel(0x1, &gpriv->cpts_reg->ts_push);
 	for (i = 0; i < 20; i++) {
 		cpts_isr(gpriv);
@@ -525,14 +575,18 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(cpts_systime_read);
 
 static void cpts_rx_timestamp(struct cpsw_priv *priv,
 			struct sk_buff *skb, u32 evt_high)
 {
 	struct cpts_time_evts evt = {0, 0};
 	struct skb_shared_hwtstamps *shhwtstamps;
+	unsigned long flags;
 
+	spin_lock_irqsave(&cpts_time_lock, flags);
 	cpts_time_evts_fifo_pop(&(priv->cpts_time->rx_fifo), evt_high, &evt);
+	spin_unlock_irqrestore(&cpts_time_lock, flags);
 
 	shhwtstamps = skb_hwtstamps(skb);
 	memset(shhwtstamps, 0, sizeof(*shhwtstamps));
@@ -544,8 +598,11 @@
 {
 	struct cpts_time_evts evt = {0, 0};
 	struct skb_shared_hwtstamps shhwtstamps;
+	unsigned long flags;
 
+	spin_lock_irqsave(&cpts_time_lock, flags);
 	cpts_time_evts_fifo_pop(&(priv->cpts_time->tx_fifo), evt_high, &evt);
+	spin_unlock_irqrestore(&cpts_time_lock, flags);
 
 	memset(&shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));
 	shhwtstamps.hwtstamp = ns_to_ktime(evt.ts);
@@ -576,20 +633,23 @@
 	struct sk_buff		*skb = token;
 	struct net_device	*ndev = skb->dev;
 	struct cpsw_priv	*priv = netdev_priv(ndev);
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+		defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 	u32			evt_high = 0;
 #endif
 
 	if (unlikely(netif_queue_stopped(ndev)))
 		netif_start_queue(ndev);
 
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+		defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 	if ((priv->cpts_time->enable_timestamping) &&
 			((htons(*((unsigned short *)&skb->data[12]))) ==
 			PTP_ETHER_TYPE)) {
 		evt_high = (skb->data[14] & 0xf) << 16;
 		evt_high |= htons(*((unsigned short *)&skb->data[44]));
-		cpts_isr(priv);
+		if (unlikely(__raw_readl(&priv->cpts_reg->intstat_raw) & 0x01))
+			cpts_isr(priv);
 		cpts_tx_timestamp(priv, skb, evt_high);
 	}
 #endif
@@ -605,7 +665,8 @@
 	struct net_device	*ndev = skb->dev;
 	struct cpsw_priv	*priv = netdev_priv(ndev);
 	int			ret = 0;
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+		defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 	u32			evt_high = 0;
 #endif
 
@@ -631,12 +692,16 @@
 	if (likely(status >= 0)) {
 		skb_put(skb, len);
 
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+	defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 		if ((priv->cpts_time->enable_timestamping) &&
 				((htons(*((unsigned short *)&skb->data[12])))
 				== PTP_ETHER_TYPE)) {
 			evt_high = (skb->data[14] & 0xf) << 16;
 			evt_high |= htons(*((unsigned short *)&skb->data[44]));
+			if (unlikely(__raw_readl(&priv->cpts_reg->intstat_raw)
+						 & 0x01))
+				cpts_isr(priv);
 			cpts_rx_timestamp(priv, skb, evt_high);
 		}
 #endif
@@ -672,7 +737,8 @@
 {
 	struct cpsw_priv *priv = dev_id;
 
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+		defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 	cpts_isr(priv);
 #endif /* CONFIG_PTP_1588_CLOCK_CPTS */
 
@@ -734,8 +800,8 @@
 static void cpsw_set_slave_mac(struct cpsw_slave *slave,
 			       struct cpsw_priv *priv)
 {
-	__raw_writel(mac_hi(priv->mac_addr), &slave->regs->sa_hi);
-	__raw_writel(mac_lo(priv->mac_addr), &slave->regs->sa_lo);
+	writel(mac_hi(priv->mac_addr), cpsw_slave_reg(priv, slave, sa_hi));
+	writel(mac_lo(priv->mac_addr), cpsw_slave_reg(priv, slave, sa_lo));
 }
 
 static inline u32 cpsw_get_slave_port(struct cpsw_priv *priv, u32 slave_num)
@@ -769,6 +835,8 @@
 
 		if (phy->speed == 10)
 			mac_control |= BIT(18);
+		else if (phy->speed == 100)
+			mac_control |= BIT(15);
 		else if (phy->speed == 1000)
 			mac_control |= BIT(7);	/* GIGABITEN	*/
 		if (phy->duplex)
@@ -950,11 +1018,11 @@
 	soft_reset(name, &slave->sliver->soft_reset);
 
 	/* setup priority mapping */
-	__raw_writel(0x76543210, &slave->sliver->rx_pri_map);
-	__raw_writel(0x33221100, &slave->regs->tx_pri_map);
+	writel(0x76543210, &slave->sliver->rx_pri_map);
+	writel(0x33221100, cpsw_slave_reg(priv, slave, tx_pri_map));
 
 	/* setup max packet size, and mac address */
-	__raw_writel(priv->rx_packet_max, &slave->sliver->rx_maxlen);
+	writel(priv->rx_packet_max, &slave->sliver->rx_maxlen);
 	cpsw_set_slave_mac(slave, priv);
 
 	slave->mac_control = 0;	/* no link yet */
@@ -962,7 +1030,7 @@
 	slave_port = cpsw_get_slave_port(priv, slave->slave_num);
 
 #ifdef CONFIG_TI_CPSW_DUAL_EMAC
-	__raw_writel(slave->port_vlan, &slave->regs->port_vlan);
+	writel(slave->port_vlan, cpsw_slave_reg(priv, slave, port_vlan));
 	cpsw_ale_add_vlan(priv->ale, slave->port_vlan,
 			1 << slave_port | 1 << priv->host_port, 0,
 			1 << slave_port | 1 << priv->host_port, 0);
@@ -1056,7 +1124,8 @@
 	if (priv->data.phy_control)
 		(*priv->data.phy_control)(true);
 
-	reg = __raw_readl(&priv->regs->id_ver);
+	reg = readl(&priv->regs->id_ver);
+	priv->cpsw_version = reg;
 
 	msg(info, ifup, "initializing cpsw version %d.%d (%d)\n",
 	    (reg >> 8 & 0x7), reg & 0xff, (reg >> 11) & 0x1f);
@@ -1071,6 +1140,18 @@
 	for_each_slave(priv, cpsw_slave_open, priv);
 #endif /* CONFIG_TI_CPSW_DUAL_EMAC */
 
+#if defined(VLAN_SUPPORT) && !defined(CONFIG_TI_CPSW_DUAL_EMAC)
+	writel(priv->data.default_vlan, &priv->host_port_regs->port_vlan);
+	writel(priv->data.default_vlan, cpsw_slave_reg(priv,
+						&priv->slaves[0], port_vlan));
+	writel(priv->data.default_vlan, cpsw_slave_reg(priv,
+						&priv->slaves[0], port_vlan));
+	cpsw_ale_add_vlan(priv->ale, priv->data.default_vlan,
+			ALE_ALL_PORTS << priv->host_port,
+			ALE_ALL_PORTS << priv->host_port,
+			ALE_ALL_PORTS << priv->host_port, 0);
+#endif
+
 #ifdef CONFIG_TI_CPSW_DUAL_EMAC
 	if (!cpsw_common_res_usage_stat(priv)) {
 #endif /* CONFIG_TI_CPSW_DUAL_EMAC */
@@ -1123,7 +1204,8 @@
 	napi_enable(&priv->napi);
 	cpdma_ctlr_eoi(priv->dma);
 
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+		defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 	reg = __raw_readl(&priv->cpts_reg->id_ver);
 	if (reg == CPTS_VERSION) {
 		printk(KERN_ERR "Found CPTS and initializing...\n");
@@ -1314,7 +1396,136 @@
 }
 #endif /* VLAN_SUPPORT */
 
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+		defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
+
+#ifdef CONFIG_TI_CPSW_DUAL_EMAC
+
+static int cpts_enable_l2_ts(struct cpsw_priv *priv, bool state)
+{
+	u32 val = 0;
+
+	if (priv->cpsw_version == CPSW_VER_1) {
+		if (state) {
+			/* Enable TS */
+			val = CPSW_V1_TS_RX_EN | CPSW_V1_TS_TX_EN |
+				(CPSW_MSG_TYPE_EN << CPSW_V1_MSG_TYPE_OFS);
+			writel(val, cpsw_slave_reg(priv,
+					&priv->slaves[priv->emac_port],
+					ts_ctl));
+
+			val = (CPSW_SEQ_ID_OFS << CPSW_V1_SEQ_ID_OFS_SHIFT) |
+				CPSW_801_1Q_LTYPE;
+			writel(val, cpsw_slave_reg(priv,
+					&priv->slaves[priv->emac_port],
+					ts_seq_ltype));
+		} else {
+			/* Disable TS */
+			writel(0, cpsw_slave_reg(priv,
+					&priv->slaves[priv->emac_port],
+					ts_ctl));
+		}
+	} else {
+		if (state) {
+			/* Enable TS */
+			val = CPSW_V2_TS_ANNEX_D_EN | CPSW_V2_TS_LTYPE_1_EN
+				| CPSW_V2_TS_RX_EN | CPSW_V2_TS_TX_EN;
+
+			writel(val, cpsw_slave_reg(priv,
+					&priv->slaves[priv->emac_port],
+					port_control));
+
+			val = (CPSW_SEQ_ID_OFS << CPSW_V2_SEQ_ID_OFS_SHIFT) |
+				CPSW_MSG_TYPE_EN;
+			writel(val, cpsw_slave_reg(priv,
+					&priv->slaves[priv->emac_port],
+					ts_seq_mtype));
+
+			writel(CPSW_801_1Q_LTYPE, &priv->regs->ts_ltype);
+		} else {
+			/* Disable TS */
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[0],
+						 port_control));
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[1],
+						 port_control));
+
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[0],
+						 ts_seq_mtype));
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[1],
+						 ts_seq_mtype));
+		}
+	}
+
+	return 0;
+}
+
+#else
+
+static int cpts_enable_l2_ts(struct cpsw_priv *priv, bool state)
+{
+	u32 val = 0;
+
+	if (priv->cpsw_version == CPSW_VER_1) {
+		if (state) {
+			/* Enable TS */
+			val = CPSW_V1_TS_RX_EN | CPSW_V1_TS_TX_EN |
+				(CPSW_MSG_TYPE_EN << CPSW_V1_MSG_TYPE_OFS);
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[0],
+						   ts_ctl));
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[1],
+						   ts_ctl));
+
+			val = (CPSW_SEQ_ID_OFS << CPSW_V1_SEQ_ID_OFS_SHIFT) |
+				CPSW_801_1Q_LTYPE;
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[0],
+						   ts_seq_ltype));
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[1],
+						   ts_seq_ltype));
+		} else {
+			/* Disable TS */
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[0],
+						 ts_ctl));
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[1],
+						 ts_ctl));
+		}
+	} else {
+		if (state) {
+			/* Enable TS */
+			val = CPSW_V2_TS_ANNEX_D_EN | CPSW_V2_TS_LTYPE_1_EN
+				| CPSW_V2_TS_RX_EN | CPSW_V2_TS_TX_EN;
+
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[0],
+						   port_control));
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[1],
+						   port_control));
+
+			val = (CPSW_SEQ_ID_OFS << CPSW_V2_SEQ_ID_OFS_SHIFT) |
+				CPSW_MSG_TYPE_EN;
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[0],
+						   ts_seq_mtype));
+			writel(val, cpsw_slave_reg(priv, &priv->slaves[1],
+						   ts_seq_mtype));
+
+			writel(CPSW_801_1Q_LTYPE, &priv->regs->ts_ltype);
+		} else {
+			/* Disable TS */
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[0],
+						 port_control));
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[1],
+						 port_control));
+
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[0],
+						 ts_seq_mtype));
+			writel(0, cpsw_slave_reg(priv, &priv->slaves[1],
+						 ts_seq_mtype));
+		}
+	}
+
+	return 0;
+}
+
+#endif
+
 static int cpsw_hwtstamp_ioctl(struct net_device *ndev,
 		struct ifreq *ifr, int cmd)
 {
@@ -1371,6 +1582,9 @@
 
 		/* Enabling All PTP v2/802.1AS Event time stamping */
 		config.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;
+		cpts_enable_l2_ts(priv, true);
+		priv->cpts_time->enable_timestamping = true;
+		dev_info(priv->dev, "Enabling PTP Time stamping...\n");
 		break;
 	default:
 		return -ERANGE;
@@ -1379,42 +1593,18 @@
 	/* Enabling Time stamping is done only for Port 1 */
 	if (config.tx_type == HWTSTAMP_TX_OFF &&
 			config.rx_filter == HWTSTAMP_FILTER_NONE) {
-		__raw_writel(0x0, &priv->slaves[0].regs->ts_ctl);
-		__raw_writel(0x001e0000,
-			&priv->slaves[0].regs->ts_seq_ltype);
-
-		/* Empty Queue */
-		priv->cpts_time->rx_fifo.head = 0;
-		priv->cpts_time->tx_fifo.head = 0;
-		priv->cpts_time->rx_fifo.tail = 0;
-		priv->cpts_time->tx_fifo.tail = 0;
-		priv->cpts_time->enable_timestamping = false;
-		pr_debug("Disabling Time stamping...\n");
-	} else {
-		u32 val = 0;
+		cpts_enable_l2_ts(priv, false);
 
-		val |= (1<<0);			/*enable RX */
-		val |= (1<<4);			/* enable TX */
-		val |= (0xFFFFu << 16);		/* enable all message types */
-
-#ifdef CONFIG_TI_CPSW_DUAL_EMAC
-		__raw_writel(val, &priv->slaves[priv->emac_port].regs->ts_ctl);
-		__raw_writel(0x001e88f7,
-			&priv->slaves[priv->emac_port].regs->ts_seq_ltype);
-#else /* !CONFIG_TI_CPSW_DUAL_EMAC */
-		__raw_writel(val, &priv->slaves[0].regs->ts_ctl);
-		__raw_writel(0x001e88f7,
-			&priv->slaves[0].regs->ts_seq_ltype);
-#endif /* CONFIG_TI_CPSW_DUAL_EMAC */
-
-		/* Empty Queue */
-		priv->cpts_time->rx_fifo.head = 0;
-		priv->cpts_time->tx_fifo.head = 0;
-		priv->cpts_time->rx_fifo.tail = 0;
-		priv->cpts_time->tx_fifo.tail = 0;
-		priv->cpts_time->enable_timestamping = true;
+		priv->cpts_time->enable_timestamping = false;
+		dev_info(priv->dev, "Disabling PTP Time stamping...\n");
 	}
 
+	/* Empty Queue */
+	priv->cpts_time->rx_fifo.head = 0;
+	priv->cpts_time->tx_fifo.head = 0;
+	priv->cpts_time->rx_fifo.tail = 0;
+	priv->cpts_time->tx_fifo.tail = 0;
+
 	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
 			-EFAULT : 0;
 }
@@ -1429,166 +1619,16 @@
 	int rxpriority, int txpriority, int switchpriority)
 {
 	if (port == 0) {
-		switch (rxpriority) {
-		case 0:
-			__raw_writel(CPSW_PRIMAP_PRI0(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		case 1:
-			__raw_writel(CPSW_PRIMAP_PRI1(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		case 2:
-			__raw_writel(CPSW_PRIMAP_PRI2(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		case 3:
-			__raw_writel(CPSW_PRIMAP_PRI3(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		case 4:
-			__raw_writel(CPSW_PRIMAP_PRI4(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		case 5:
-			__raw_writel(CPSW_PRIMAP_PRI5(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		case 6:
-			__raw_writel(CPSW_PRIMAP_PRI6(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		case 7:
-			__raw_writel(CPSW_PRIMAP_PRI7(txpriority),
-				&priv->host_port_regs->cpdma_tx_pri_map);
-			break;
-		default:
-			printk(KERN_INFO "cpsw_set_priority_mapping:"
-						" Invalid rxpriority value");
-			return -EFAULT;
-		}
-
-		if (switchpriority != CPSW_USE_DEFAULT) {
-			switch (txpriority) {
-			case 0:
-				__raw_writel(CPSW_PRIMAP_PRI0(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			case 1:
-				__raw_writel(CPSW_PRIMAP_PRI1(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			case 2:
-				__raw_writel(CPSW_PRIMAP_PRI2(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			case 3:
-				__raw_writel(CPSW_PRIMAP_PRI3(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			case 4:
-				__raw_writel(CPSW_PRIMAP_PRI4(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			case 5:
-				__raw_writel(CPSW_PRIMAP_PRI5(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			case 6:
-				__raw_writel(CPSW_PRIMAP_PRI6(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			case 7:
-				__raw_writel(CPSW_PRIMAP_PRI7(switchpriority),
-					&priv->host_port_regs->tx_pri_map);
-				break;
-			default:
-				printk(KERN_INFO "cpsw_set_priority_mapping:"
-						"Invalid txpriority value");
-				return -EFAULT;
-			}
-		}
+		writel(CPSW_PRIMAP(rxpriority, txpriority),
+		       &priv->host_port_regs->cpdma_tx_pri_map);
+		writel(CPSW_PRIMAP(txpriority, switchpriority),
+		       &priv->host_port_regs->tx_pri_map);
 	} else {
 		/* Configure sliver priority mapping registers */
-		switch (rxpriority) {
-		case 0:
-			__raw_writel(CPSW_PRIMAP_PRI0(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		case 1:
-			__raw_writel(CPSW_PRIMAP_PRI1(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		case 2:
-			__raw_writel(CPSW_PRIMAP_PRI2(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		case 3:
-			__raw_writel(CPSW_PRIMAP_PRI3(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		case 4:
-			__raw_writel(CPSW_PRIMAP_PRI4(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		case 5:
-			__raw_writel(CPSW_PRIMAP_PRI5(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		case 6:
-			__raw_writel(CPSW_PRIMAP_PRI6(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		case 7:
-			__raw_writel(CPSW_PRIMAP_PRI7(txpriority),
-				&slave(priv, port-1)->sliver->rx_pri_map);
-			break;
-		default:
-			printk(KERN_INFO "\nWARN: cpsw_set_priority_mapping:"
-					" Invalid rxpriority value");
-			return -EFAULT;
-		}
-
-		if (switchpriority != CPSW_USE_DEFAULT) {
-			switch (txpriority) {
-			case 0:
-				__raw_writel(CPSW_PRIMAP_PRI0(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			case 1:
-				__raw_writel(CPSW_PRIMAP_PRI1(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			case 2:
-				__raw_writel(CPSW_PRIMAP_PRI2(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			case 3:
-				__raw_writel(CPSW_PRIMAP_PRI3(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			case 4:
-				__raw_writel(CPSW_PRIMAP_PRI4(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			case 5:
-				__raw_writel(CPSW_PRIMAP_PRI5(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			case 6:
-				__raw_writel(CPSW_PRIMAP_PRI6(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			case 7:
-				__raw_writel(CPSW_PRIMAP_PRI7(switchpriority),
-					&slave(priv, port-1)->regs->tx_pri_map);
-				break;
-			default:
-				printk(KERN_INFO "cpsw_set_priority_mapping:"
-						" Invalid txpriority value");
-				return -EFAULT;
-			}
-		}
+		writel(CPSW_PRIMAP(rxpriority, txpriority),
+		       &slave(priv, port-1)->sliver->rx_pri_map);
+		writel(CPSW_PRIMAP(txpriority, switchpriority),
+		       cpsw_slave_reg(priv, slave(priv, port-1), tx_pri_map));
 	}
 	return 0;
 }
@@ -1753,7 +1793,8 @@
 			port_state = "forward";
 			break;
 		}
-		port_vlan = __raw_readl(&priv->slaves[0].regs->port_vlan);
+		port_vlan = readl(cpsw_slave_reg(priv, &priv->slaves[0],
+						 port_vlan));
 		out_len += snprintf(buf + out_len, size - out_len,
 			"\t%-8u %-8u %-8u %s\n", 1,
 			port_vlan & 0xfff, (port_vlan > 13) & 0x7, port_state);
@@ -1772,7 +1813,8 @@
 			port_state = "forward";
 			break;
 		}
-		port_vlan = __raw_readl(&priv->slaves[1].regs->port_vlan);
+		port_vlan = readl(cpsw_slave_reg(priv, &priv->slaves[0],
+						 port_vlan));
 		out_len += snprintf(buf + out_len, size - out_len,
 			"\t%-8u %-8u %-8u %s\n", 2,
 			port_vlan & 0xfff, (port_vlan > 13) & 0x7, port_state);
@@ -1874,7 +1916,7 @@
 		struct ifreq *ifrq, int cmd)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
-	struct net_switch_config switch_config;
+	struct net_switch_config *switch_config;
 	int ret = -EFAULT;
 
 	/*
@@ -1882,15 +1924,15 @@
 	* switch statement required.
 	* Function calls are based on switch_config.cmd
 	*/
-	if (cmd != SIOCDEVPRIVATE)
+	if (cmd != SIOCSWITCHCONFIG)
 		return ret;
 
-	if (copy_from_user(&switch_config,
-			(struct net_switch_config *)(ifrq->ifr_data),
+	switch_config = kzalloc(sizeof(struct net_switch_config), GFP_KERNEL);
+	if (copy_from_user(switch_config, (ifrq->ifr_data),
 			sizeof(struct net_switch_config)))
 		return ret;
 
-	switch (switch_config.cmd) {
+	switch (switch_config->cmd) {
 	case CONFIG_SWITCH_ADD_MULTICAST:
 		if ((switchcmd(switch_config).untag_port <= 3) &&
 				(switchcmd(switch_config).vid <= 4095) &&
@@ -1914,7 +1956,7 @@
 					switchcmd(switch_config).flag,
 					switchcmd(switch_config).untag_port);
 		} else {
-			printk(KERN_ERR "Invalid Switch config arguments\n");
+			dev_err(priv->dev, "Invalid Switch config arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -1934,7 +1976,7 @@
 					priv->host_port, 0,
 					switchcmd(switch_config).vid);
 		} else {
-			printk(KERN_ERR "Invalid Switch config arguments\n");
+			dev_err(priv->dev, "Invalid Switch config arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -1944,7 +1986,7 @@
 			ret = cpsw_ale_add_oui(priv->ale,
 				switchcmd(switch_config).addr);
 		} else {
-			printk(KERN_ERR "Invalid Switch config arguments\n");
+			dev_err(priv->dev, "Invalid Switch config arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -1956,13 +1998,14 @@
 				switchcmd(switch_config).addr,
 				switchcmd(switch_config).vid);
 			if (ret >= 0) {
-				switch_config.ret_type = ret;
+				switch_config->ret_type = ret;
 				ret = copy_to_user(ifrq->ifr_data,
-					&switch_config,
-					sizeof(switch_config)) ? -EFAULT : 0;
+					switch_config,
+					sizeof(struct net_switch_config)) ?
+					-EFAULT : 0;
 			}
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -1983,7 +2026,7 @@
 						<< priv->host_port,
 					switchcmd(switch_config).vid);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2004,7 +2047,7 @@
 					switchcmd(switch_config).addr,
 					switchcmd(switch_config).vid);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2021,19 +2064,20 @@
 				switchcmd(switch_config).reg_multi,
 				switchcmd(switch_config).unreg_multi);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
 
 	case CONFIG_SWITCH_FIND_VLAN:
 		if (switchcmd(switch_config).vid <= 4095) {
-			switch_config.ret_type = cpsw_ale_match_vlan(priv->ale,
+			switch_config->ret_type = cpsw_ale_match_vlan(priv->ale,
 				switchcmd(switch_config).vid);
-			ret = copy_to_user(ifrq->ifr_data, &switch_config,
-				sizeof(switch_config)) ? -EFAULT : 0;
+			ret = copy_to_user(ifrq->ifr_data, switch_config,
+				sizeof(struct net_switch_config)) ?
+				-EFAULT : 0;
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2046,7 +2090,7 @@
 				switchcmd(switch_config).mem_port
 				<< priv->host_port);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2063,17 +2107,17 @@
 				port_vlan |= (1 << 12);
 
 			if (switchcmd(switch_config).port == 0)
-				__raw_writel(port_vlan,
+				writel(port_vlan,
 					&priv->host_port_regs->port_vlan);
 			else if (switchcmd(switch_config).port == 1)
-				__raw_writel(port_vlan,
-					&(priv->slaves[0].regs->port_vlan));
+				writel(port_vlan, cpsw_slave_reg(priv,
+						&priv->slaves[0], port_vlan));
 			else
-				__raw_writel(port_vlan,
-					&(priv->slaves[1].regs->port_vlan));
+				writel(port_vlan, cpsw_slave_reg(priv,
+						&priv->slaves[1], port_vlan));
 			ret = 0;
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2087,18 +2131,19 @@
 	case CONFIG_SWITCH_DUMP:
 		ret = cpsw_ale_dump(priv->ale,
 			switchcmd(switch_config).aledump,
-			switch_config.cmd_data.buf, 4095);
+			switch_config->cmd_data.buf, 4095);
 		if (ret)
-			ret = copy_to_user(ifrq->ifr_data, &switch_config,
-				sizeof(switch_config)) ? -EFAULT : 0;
+			ret = copy_to_user(ifrq->ifr_data, switch_config,
+				sizeof(struct net_switch_config)) ?
+				-EFAULT : 0;
 		break;
 
 	case CONFIG_SWITCH_SET_FLOW_CONTROL:
 		if (portcmd(switch_config).port <= 7) {
-			__raw_writel(portcmd(switch_config).port,
+			writel(portcmd(switch_config).port,
 				&priv->regs->flow_control);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2114,26 +2159,27 @@
 				priocmd(switch_config).prio_tx,
 				priocmd(switch_config).prio_switch);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
 
 	case CONFIG_SWITCH_PORT_STATISTICS_ENABLE:
 		if (portcmd(switch_config).port <= 7) {
-			__raw_writel(portcmd(switch_config).port,
+			writel(portcmd(switch_config).port,
 				&priv->regs->stat_port_en);
 			ret = 0;
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
 
 	case CONFIG_SWITCH_CONFIG_DUMP:
-		cpsw_config_dump(priv, switch_config.cmd_data.buf, 4096);
-		ret = copy_to_user(ifrq->ifr_data, &switch_config,
-			sizeof(switch_config)) ? -EFAULT : 0;
+		cpsw_config_dump(priv, switch_config->cmd_data.buf, 4096);
+		ret = copy_to_user(ifrq->ifr_data, switch_config,
+			sizeof(struct net_switch_config)) ?
+			-EFAULT : 0;
 		break;
 
 	case CONFIG_SWITCH_RATELIMIT:
@@ -2155,7 +2201,7 @@
 				portcmd(switch_config).addr_type,
 				portcmd(switch_config).limit);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2170,7 +2216,7 @@
 				ALE_PORT_DROP_UNKNOWN_VLAN, 1);
 			ret = 0;
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2198,7 +2244,7 @@
 				portcmd(switch_config).unknown_vlan_member);
 			ret = 0;
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2230,7 +2276,7 @@
 				ret = phy_ethtool_gset(priv->slaves[0].phy,
 						&ecmd);
 			} else {
-				printk(KERN_ERR "Phy not Found\n");
+				dev_err(priv->dev, "Phy not Found\n");
 				ret = -EFAULT;
 				break;
 			}
@@ -2240,12 +2286,12 @@
 				ret = phy_ethtool_gset(priv->slaves[1].phy,
 						&ecmd);
 			} else {
-				printk(KERN_ERR "Phy not Found\n");
+				dev_err(priv->dev, "Phy not Found\n");
 				ret = -EFAULT;
 				break;
 			}
 		else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 			break;
 		}
@@ -2275,7 +2321,7 @@
 				ret = phy_ethtool_sset(priv->slaves[1].phy,
 					&ecmd);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2291,7 +2337,7 @@
 				ret = phy_ethtool_gset(priv->slaves[0].phy,
 						&ecmd);
 			} else {
-				printk(KERN_ERR "Phy not Found\n");
+				dev_err(priv->dev, "Phy not Found\n");
 				ret = -EFAULT;
 				break;
 			}
@@ -2301,12 +2347,12 @@
 				ret = phy_ethtool_gset(priv->slaves[1].phy,
 						&ecmd);
 			} else {
-				printk(KERN_ERR "Phy not Found\n");
+				dev_err(priv->dev, "Phy not Found\n");
 				ret = -EFAULT;
 				break;
 			}
 		else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 			break;
 		}
@@ -2317,8 +2363,9 @@
 				portcmd(switch_config).direction = 1;
 			else
 				portcmd(switch_config).direction = 0;
-			ret = copy_to_user(ifrq->ifr_data, &switch_config,
-				sizeof(switch_config)) ? -EFAULT : 0;
+			ret = copy_to_user(ifrq->ifr_data, switch_config,
+				sizeof(struct net_switch_config)) ?
+				-EFAULT : 0;
 		}
 
 		break;
@@ -2330,7 +2377,7 @@
 				portcmd(switch_config).port,
 				portcmd(switch_config).port_state);
 		} else {
-			printk(KERN_ERR "Invalid Arguments\n");
+			dev_err(priv->dev, "Invalid Arguments\n");
 			ret = -EFAULT;
 		}
 		break;
@@ -2345,6 +2392,7 @@
 		ret = -EOPNOTSUPP;
 	}
 
+	kfree(switch_config);
 	return ret;
 }
 #endif /* CONFIG_TI_CPSW_DUAL_EMAC */
@@ -2357,13 +2405,14 @@
 
 	switch (cmd) {
 	case SIOCSHWTSTAMP:
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+	defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 		return cpsw_hwtstamp_ioctl(ndev, ifrq, cmd);
 #else
 		return -EOPNOTSUPP;
 #endif
 
-	case SIOCDEVPRIVATE:
+	case SIOCSWITCHCONFIG:
 #ifdef CONFIG_TI_CPSW_DUAL_EMAC
 		return -EOPNOTSUPP;
 #else
@@ -2380,29 +2429,64 @@
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
 
-	if (ndev->flags & IFF_PROMISC) {
-		/* Enable promiscuous mode */
+	if (!netdev_mc_empty(ndev)) {
+		struct netdev_hw_addr *ha;
+
+		/* Clear all mcast from ALE */
+		cpsw_ale_flush_multicast(priv->ale,
+				ALE_ALL_PORTS << priv->host_port);
+
+		/* program multicast address list into ALE register */
+		netdev_for_each_mc_addr(ha, ndev) {
+			cpsw_ale_add_mcast(priv->ale, (u8 *)ha->addr,
+				ALE_ALL_PORTS << priv->host_port, 0, 0);
+		}
 	} else {
-		if (!netdev_mc_empty(ndev)) {
-			struct netdev_hw_addr *ha;
+		/* Clear all mcast from ALE */
+		cpsw_ale_flush_multicast(priv->ale,
+				ALE_ALL_PORTS << priv->host_port);
+	}
+}
 
-			/* Clear all mcast from ALE */
-			cpsw_ale_flush_multicast(priv->ale,
-					ALE_ALL_PORTS << priv->host_port);
-
-			/* program multicast address list into ALE register */
-			netdev_for_each_mc_addr(ha, ndev) {
-				cpsw_ale_add_mcast(priv->ale, (u8 *)ha->addr,
-					ALE_ALL_PORTS << priv->host_port, 0, 0);
-			}
-		} else {
-			/* Clear all mcast from ALE */
-			cpsw_ale_flush_multicast(priv->ale,
-					ALE_ALL_PORTS << priv->host_port);
+#ifdef CONFIG_TI_CPSW_DUAL_EMAC
+
+static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+	struct cpsw_ale *ale = priv->ale;
+
+	if (flags & IFF_PROMISC) {
+		if ((priv->slaves[0].ndev->flags & IFF_PROMISC) ||
+				(priv->slaves[1].ndev->flags & IFF_PROMISC)) {
+			/*
+			 * Enabling promiscuous mode for one interface will be
+			 * common for both the interface as the interface
+			 * shares the same hardware resource.
+			 */
+
+			/* Enable Bypass */
+			cpsw_ale_control_set(ale, 0, ALE_BYPASS, 1);
+
+			dev_err(&ndev->dev, "promiscuity enabled\n");
+		} else {
+			/* Disable Bypass */
+			cpsw_ale_control_set(ale, 0, ALE_BYPASS, 0);
+			dev_err(&ndev->dev, "promiscuity disabled\n");
 		}
 	}
+
+	/*
+	 * The switch cannot filter multicast traffic unless it is configured
+	 * in "VLAN Aware" mode.  Unfortunately, VLAN awareness requires a
+	 * whole bunch of additional logic that this driver does not implement
+	 * at present.
+	 */
+	if ((flags & IFF_ALLMULTI) && !(ndev->flags & IFF_ALLMULTI))
+		dev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");
 }
 
+#else
+
 static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
 {
 	/*
@@ -2426,6 +2510,8 @@
 		dev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");
 }
 
+#endif
+
 static int cpsw_ndo_set_mac_address(struct net_device *ndev, void *p)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
@@ -2548,8 +2634,10 @@
 			     struct ethtool_cmd *ecmd)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
-	if (priv->slaves->phy)
-		return phy_ethtool_gset(priv->slaves->phy, ecmd);
+	int slave_no = cpsw_slave_phy_index(priv);
+
+	if (priv->slaves[slave_no].phy)
+		return phy_ethtool_gset(priv->slaves[slave_no].phy, ecmd);
 	else
 		return -EOPNOTSUPP;
 
@@ -2566,9 +2654,10 @@
 static int cpsw_set_settings(struct net_device *ndev, struct ethtool_cmd *ecmd)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
+	int slave_no = cpsw_slave_phy_index(priv);
 
-	if (priv->slaves->phy)
-		return phy_ethtool_sset(priv->slaves->phy, ecmd);
+	if (priv->slaves[slave_no].phy)
+		return phy_ethtool_sset(priv->slaves[slave_no].phy, ecmd);
 	else
 		return -EOPNOTSUPP;
 
@@ -2680,6 +2769,20 @@
 #endif /* CONFIG_TI_CPSW_DUAL_EMAC */
 }
 
+#ifdef CONFIG_TI_CPSW_DUAL_EMAC
+
+static inline void cpsw_deinit_slave_emac(struct cpsw_priv *priv)
+{
+	struct net_device *ndev = priv->slaves[1].ndev;
+
+	unregister_netdev(ndev);
+	free_netdev(ndev);
+}
+
+#else
+#define cpsw_deinit_slave_emac(priv)
+#endif
+
 static int __devinit cpsw_probe(struct platform_device *pdev)
 {
 	struct cpsw_platform_data	*data = pdev->dev.platform_data;
@@ -2717,7 +2820,8 @@
 	priv->rx_packet_max = max(rx_packet_max, 128);
 
 	priv->cpts_time = kzalloc(sizeof(struct cpts_time_handle), GFP_KERNEL);
-#ifdef CONFIG_PTP_1588_CLOCK_CPTS
+#if (defined(CONFIG_PTP_1588_CLOCK_CPTS) ||		\
+		defined(CONFIG_PTP_1588_CLOCK_CPTS_MODULE))
 	gpriv = priv;
 #endif /* CONFIG_PTP_1588_CLOCK_CPTS */
 
@@ -2816,13 +2920,13 @@
 	dma_params.rxfree		= (void __iomem *)(((u32)priv->regs) +
 						data->cpdma_reg_ofs + 0x0e0);
 	dma_params.txhdp		= (void __iomem *)(((u32)priv->regs) +
-						data->cpdma_reg_ofs + 0x100);
+						data->cpdma_sram_ofs);
 	dma_params.rxhdp		= (void __iomem *)(((u32)priv->regs) +
-						data->cpdma_reg_ofs + 0x120);
+						data->cpdma_sram_ofs + 0x020);
 	dma_params.txcp			= (void __iomem *)(((u32)priv->regs) +
-						data->cpdma_reg_ofs + 0x140);
+						data->cpdma_sram_ofs + 0x040);
 	dma_params.rxcp			= (void __iomem *)(((u32)priv->regs) +
-						data->cpdma_reg_ofs + 0x160);
+						data->cpdma_sram_ofs + 0x060);
 	dma_params.num_chan		= data->channels;
 	dma_params.has_soft_reset	= true;
 	dma_params.min_packet_size	= CPSW_MIN_PACKET_SIZE;
@@ -2878,12 +2982,12 @@
 		for (i = res->start; i <= res->end; i++) {
 			if (request_irq(i, cpsw_interrupt, IRQF_DISABLED,
 					dev_name(&pdev->dev), priv)) {
-				dev_err(priv->dev, "error attaching irq\n");
+				pr_err("error attaching irq\n");
 				goto clean_ale_ret;
 			}
 			#ifdef CPSW_IRQ_QUIRK
 			priv->irqs_table[k] = i;
-			priv->num_irqs = k;
+			priv->num_irqs = k+1;
 			#endif
 		}
 		k++;
@@ -2921,7 +3025,6 @@
 		return -ENOMEM;
 	}
 
-	platform_set_drvdata(pdev, ndev);
 	priv_sl2 = netdev_priv(ndev);
 	spin_lock_init(&priv_sl2->lock);
 	priv_sl2->data = *data;
@@ -3033,11 +3136,14 @@
 {
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct cpsw_priv *priv = netdev_priv(ndev);
+	int i;
 
 	msg(notice, probe, "removing device\n");
 	platform_set_drvdata(pdev, NULL);
 
-	free_irq(ndev->irq, priv);
+	cpsw_deinit_slave_emac(priv);
+	for (i = 0; i < priv->num_irqs; i++)
+		free_irq(priv->irqs_table[i], priv);
 	cpsw_ale_destroy(priv->ale);
 	cpdma_chan_destroy(priv->txch);
 	cpdma_chan_destroy(priv->rxch);
@@ -3050,6 +3156,7 @@
 	clk_put(priv->clk);
 	kfree(priv->cpts_time);
 	kfree(priv->slaves);
+	unregister_netdev(ndev);
 	free_netdev(ndev);
 
 	return 0;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/net/cpsw_ale.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/net/cpsw_ale.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/net/cpsw_ale.c	2014-08-07 11:51:55.722748538 -0600
@@ -64,6 +64,9 @@
 		__addr__[3] == 0xff && __addr__[4] == 0xff && \
 		__addr__[5] == 0xff)
 
+#define cpsw_ale_snprintf(buf, len, fmt, args...)			\
+		((len) > 0) ? snprintf(buf, len, fmt, ##args) : 0
+
 static inline int cpsw_ale_get_field(u32 *ale_entry, u32 start, u32 bits)
 {
 	int idx;
@@ -309,10 +312,10 @@
 	int port_mask   = cpsw_ale_get_port_mask(ale_entry);
 	int super       = cpsw_ale_get_super(ale_entry);
 
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "mcstate: %s(%d), ", str_mcast_state[mcast_state],
 			   mcast_state);
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "port mask: %x, %ssuper\n", port_mask,
 			   super ? "" : "no ");
 	return outlen;
@@ -328,10 +331,10 @@
 	int secure      = cpsw_ale_get_secure(ale_entry);
 	int blocked     = cpsw_ale_get_blocked(ale_entry);
 
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "uctype: %s(%d), ", str_ucast_type[ucast_type],
 			   ucast_type);
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "port: %d%s%s\n", port_num, secure ? ", Secure" : "",
 			   blocked ? ", Blocked" : "");
 	return outlen;
@@ -345,13 +348,13 @@
 	int unreg_mcast = cpsw_ale_get_vlan_unreg_mcast(ale_entry);
 	int member_list = cpsw_ale_get_vlan_member_list(ale_entry);
 
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "vlanuntag: %x, ", untag_force);
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "vlanregmcast: %x, ", reg_mcast);
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "vlanunregmcast: %x, ", unreg_mcast);
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "vlanmemberlist: %x\n", member_list);
 	return outlen;
 }
@@ -367,24 +370,26 @@
 		return outlen;
 
 	if (idx >= 0) {
-		outlen += snprintf(buf + outlen, len - outlen,
+		outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 				   "index %d, ", idx);
 	}
 
-	outlen += snprintf(buf + outlen, len - outlen, "raw: %08x %08x %08x, ",
-			   ale_entry[0], ale_entry[1], ale_entry[2]);
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
+				"raw: %08x %08x %08x, ",
+				ale_entry[0], ale_entry[1], ale_entry[2]);
 
-	outlen += snprintf(buf + outlen, len - outlen,
+	outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			   "type: %s(%d), ", str_type[type], type);
 
 	if (type == ALE_TYPE_VLAN || type == ALE_TYPE_VLAN_ADDR) {
-		outlen += snprintf(buf + outlen, len - outlen, "vlan: %d, ",
-				   cpsw_ale_get_vlan_id(ale_entry));
+		outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
+					"vlan: %d, ",
+					cpsw_ale_get_vlan_id(ale_entry));
 	}
 
 	if (type == ALE_TYPE_ADDR || type == ALE_TYPE_VLAN_ADDR) {
 		cpsw_ale_get_addr(ale_entry, addr);
-		outlen += snprintf(buf + outlen, len - outlen,
+		outlen += cpsw_ale_snprintf(buf + outlen, len - outlen,
 			"addr: " ADDR_FMT_STR ", ", ADDR_FMT_ARGS(addr));
 		outlen += cpsw_ale_get_mcast(ale_entry) ?
 			cpsw_ale_dump_mcast(ale_entry, buf + outlen,
@@ -558,7 +563,7 @@
 int cpsw_ale_del_vlan(struct cpsw_ale *ale, u16 vid, int port)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
-	int idx, mask;
+	int idx;
 
 	idx = cpsw_ale_match_vlan(ale, vid);
 	if (idx < 0)
@@ -566,24 +571,10 @@
 
 	cpsw_ale_read(ale, idx, ale_entry);
 
-	mask  = cpsw_ale_get_vlan_untag_force(ale_entry);
-	mask &= ~BIT(port);
-	cpsw_ale_set_vlan_untag_force(ale_entry, mask);
-
-	mask  = cpsw_ale_get_vlan_reg_mcast(ale_entry);
-	mask &= ~BIT(port);
-	cpsw_ale_set_vlan_reg_mcast(ale_entry, mask);
-
-	mask  = cpsw_ale_get_vlan_unreg_mcast(ale_entry);
-	mask &= ~BIT(port);
-	cpsw_ale_set_vlan_unreg_mcast(ale_entry, mask);
-
-	mask  = cpsw_ale_get_vlan_member_list(ale_entry);
-	mask &= ~BIT(port);
-	if (!mask)
+	if (!port)
 		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
 	else
-		cpsw_ale_set_vlan_member_list(ale_entry, mask);
+		cpsw_ale_set_vlan_member_list(ale_entry, port);
 
 	cpsw_ale_write(ale, idx, ale_entry);
 	return 0;
@@ -792,14 +783,14 @@
 	for (i = 0, info = ale_controls; i < ALE_NUM_CONTROLS; i++, info++) {
 		/* global controls */
 		if (info->port_shift == 0 &&  info->port_offset == 0) {
-			len += snprintf(buf + len, SZ_4K - len,
+			len += cpsw_ale_snprintf(buf + len, SZ_4K - len,
 					"%s=%d\n", info->name,
 					cpsw_ale_control_get(ale, 0, i));
 			continue;
 		}
 		/* port specific controls */
 		for (port = 0; port < ale->ale_ports; port++) {
-			len += snprintf(buf + len, SZ_4K - len,
+			len += cpsw_ale_snprintf(buf + len, SZ_4K - len,
 					"%s.%d=%d\n", info->name, port,
 					cpsw_ale_control_get(ale, port, i));
 		}
@@ -922,6 +913,7 @@
 void cpsw_ale_stop(struct cpsw_ale *ale)
 {
 	del_timer_sync(&ale->timer);
+	cpsw_ale_control_set(ale, 0, ALE_ENABLE, 0);
 	device_remove_file(ale->params.dev, &ale->ale_table_attr);
 	device_remove_file(ale->params.dev, &ale->ale_control_attr);
 }
@@ -946,8 +938,6 @@
 {
 	if (!ale)
 		return -EINVAL;
-	cpsw_ale_stop(ale);
-	cpsw_ale_control_set(ale, 0, ALE_ENABLE, 0);
 	kfree(ale);
 	return 0;
 }
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/net/davinci_cpdma.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/net/davinci_cpdma.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/net/davinci_cpdma.c	2014-08-07 11:51:55.730748537 -0600
@@ -788,6 +788,9 @@
 		goto unlock_ret;
 	}
 
+	if (status & CPDMA_DESC_PASS_CRC)
+		outlen -= 4;
+
 	status	= status & (CPDMA_DESC_EOQ | CPDMA_DESC_TD_COMPLETE |
 				CPDMA_DESC_PORT_MASK);
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/net/davinci_mdio.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/net/davinci_mdio.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/net/davinci_mdio.c	2014-08-07 11:51:55.738748537 -0600
@@ -181,6 +181,11 @@
 		__davinci_mdio_reset(data);
 		return -EAGAIN;
 	}
+
+	reg = __raw_readl(&regs->user[0].access);
+	if ((reg & USERACCESS_GO) == 0)
+		return 0;
+
 	dev_err(data->dev, "timed out waiting for user access\n");
 	return -ETIMEDOUT;
 }
@@ -385,8 +390,10 @@
 	struct device *dev = &pdev->dev;
 	struct davinci_mdio_data *data = dev_get_drvdata(dev);
 
-	if (data->bus)
+	if (data->bus) {
+		mdiobus_unregister(data->bus);
 		mdiobus_free(data->bus);
+	}
 
 	if (data->clk) {
 		clk_disable(data->clk);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/scsi/scsi_pm.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/scsi/scsi_pm.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/scsi/scsi_pm.c	2014-08-07 11:51:55.738748537 -0600
@@ -144,9 +144,9 @@
 	int	err;
 
 	err = pm_runtime_get_sync(&sdev->sdev_gendev);
-	if (err < 0)
+	if (err < 0 && err !=-EACCES)
 		pm_runtime_put_sync(&sdev->sdev_gendev);
-	else if (err > 0)
+	else
 		err = 0;
 	return err;
 }
@@ -173,9 +173,9 @@
 	int	err;
 
 	err = pm_runtime_get_sync(&shost->shost_gendev);
-	if (err < 0)
+	if (err < 0 && err !=-EACCES)
 		pm_runtime_put_sync(&shost->shost_gendev);
-	else if (err > 0)
+	else
 		err = 0;
 	return err;
 }
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/spi/spi.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/spi/spi.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/spi/spi.c	2014-08-07 11:51:55.750748536 -0600
@@ -242,7 +242,7 @@
 	}
 
 	spi->master = master;
-	spi->dev.parent = dev;
+	spi->dev.parent = &master->dev;
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
 	device_initialize(&spi->dev);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/core/usb.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/core/usb.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/core/usb.c	2014-08-07 11:51:55.754748536 -0600
@@ -993,7 +993,58 @@
 	debugfs_remove(usb_debug_devices);
 	debugfs_remove(usb_debug_root);
 }
+/**
+ * usb_buffer_alloc - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP
+ * @dev: device the buffer will be used with
+ * @size: requested buffer size
+ * @mem_flags: affect whether allocation may block
+ * @dma: used to return DMA address of buffer
+ *
+ * Return value is either null (indicating no buffer could be allocated), or
+ * the cpu-space pointer to a buffer that may be used to perform DMA to the
+ * specified device.  Such cpu-space buffers are returned along with the DMA
+ * address (through the pointer provided).
+ *
+ * These buffers are used with URB_NO_xxx_DMA_MAP set in urb->transfer_flags
+ * to avoid behaviors like using "DMA bounce buffers", or thrashing IOMMU
+ * hardware during URB completion/resubmit.  The implementation varies between
+ * platforms, depending on details of how DMA will work to this device.
+ * Using these buffers also eliminates cacheline sharing problems on
+ * architectures where CPU caches are not DMA-coherent.  On systems without
+ * bus-snooping caches, these buffers are uncached.
+ *
+ * When the buffer is no longer used, free it with usb_buffer_free().
+ */
+void *usb_buffer_alloc(struct usb_device *dev, size_t size, gfp_t mem_flags,
+                       dma_addr_t *dma)
+{
+        if (!dev || !dev->bus)
+                return NULL;
+        return hcd_buffer_alloc(dev->bus, size, mem_flags, dma);
+}
+EXPORT_SYMBOL_GPL(usb_buffer_alloc);
 
+/**
+ * usb_buffer_free - free memory allocated with usb_buffer_alloc()
+ * @dev: device the buffer was used with
+ * @size: requested buffer size
+ * @addr: CPU address of buffer
+ * @dma: DMA address of buffer
+ *
+ * This reclaims an I/O buffer, letting it be reused.  The memory must have
+ * been allocated using usb_buffer_alloc(), and the parameters must match
+ * those provided in that allocation request.
+ */
+void usb_buffer_free(struct usb_device *dev, size_t size, void *addr,
+                     dma_addr_t dma)
+{
+        if (!dev || !dev->bus)
+                return;
+        if (!addr)
+                return;
+        hcd_buffer_free(dev->bus, size, addr, dma);
+}
+EXPORT_SYMBOL_GPL(usb_buffer_free);
 /*
  * Init
  */
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/composite.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/composite.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/composite.c	2014-08-07 11:51:55.754748536 -0600
@@ -1284,7 +1284,7 @@
 
 	retval = usb_gadget_probe_driver(&composite_driver[id], composite_bind);
 	if (retval < 0)
-		put_gadget_drv_id();
+		put_gadget_drv_id(id);
 
 	return retval;
 }
@@ -1303,7 +1303,7 @@
 	for (i = 0; i < get_gadget_max_drv_id(); ++i)
 		if (composite[i] == driver) {
 			usb_gadget_unregister_driver(&composite_driver[i]);
-			put_gadget_drv_id();
+			put_gadget_drv_id(i);
 			composite[i] = NULL;
 		}
 }
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/file_storage.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/file_storage.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/file_storage.c	2014-08-07 11:51:55.754748536 -0600
@@ -3157,7 +3157,6 @@
 
 	kfree(fsg->luns);
 	kfree(fsg);
-	put_gadget_drv_id();
 }
 
 static void lun_release(struct device *dev)
@@ -3179,6 +3178,15 @@
 	DBG(fsg, "unbind\n");
 	clear_bit(REGISTERED, &fsg->atomic_bitflags);
 
+	/* If the thread isn't already dead, tell it to exit now */
+	if (fsg->state != FSG_STATE_TERMINATED) {
+		raise_exception(fsg, FSG_STATE_EXIT);
+		wait_for_completion(&fsg->thread_notifier);
+
+		/* The cleanup routine waits for this completion also */
+		complete(&fsg->thread_notifier);
+	}
+
 	/* Unregister the sysfs attribute files and the LUNs */
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
@@ -3192,15 +3200,6 @@
 		}
 	}
 
-	/* If the thread isn't already dead, tell it to exit now */
-	if (fsg->state != FSG_STATE_TERMINATED) {
-		raise_exception(fsg, FSG_STATE_EXIT);
-		wait_for_completion(&fsg->thread_notifier);
-
-		/* The cleanup routine waits for this completion also */
-		complete(&fsg->thread_notifier);
-	}
-
 	/* Free the data buffers */
 	for (i = 0; i < FSG_NUM_BUFFERS; ++i)
 		kfree(fsg->buffhds[i].buf);
@@ -3654,6 +3653,7 @@
 static void __exit fsg_cleanup(void)
 {
 	struct fsg_dev	*fsg = the_fsg;
+	int id = fsg_driver.id;
 
 	/* Unregister the driver iff the thread hasn't already done so */
 	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags))
@@ -3663,5 +3663,6 @@
 	wait_for_completion(&fsg->thread_notifier);
 
 	kref_put(&fsg->ref, fsg_release);
+	put_gadget_drv_id(id);
 }
 module_exit(fsg_cleanup);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/multi.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/multi.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/gadget/multi.c	2014-08-07 11:51:55.754748536 -0600
@@ -41,6 +41,8 @@
 MODULE_AUTHOR("Michal Nazarewicz");
 MODULE_LICENSE("GPL");
 
+static char manufacturer[50];
+static u16 vendorID;
 
 /***************************** All the files... *****************************/
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41.c	2014-08-07 11:51:55.754748536 -0600
@@ -48,8 +48,7 @@
 
 static u32 *allocated_queues[CPPI41_NUM_QUEUE_MGR];
 
-/* First 32 packet descriptors are reserved for unallocated memory regions. */
-static u32 next_desc_index[CPPI41_NUM_QUEUE_MGR] = { 1 << 5 };
+static u32 next_desc_index[CPPI41_NUM_QUEUE_MGR] = { 0 };
 static u8  next_mem_rgn[CPPI41_NUM_QUEUE_MGR];
 
 static struct {
@@ -109,18 +108,18 @@
 	linking_ram[q_mgr].virt_addr = ptr;
 	linking_ram[q_mgr].size = rgn0_size * 4;
 
-	__raw_writel(linking_ram[q_mgr].phys_addr,
+	writel(linking_ram[q_mgr].phys_addr,
 			q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
 	DBG("Linking RAM region 0 base @ %p, value: %x\n",
 	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG,
-	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG));
+	    raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG));
 
-	__raw_writel(rgn0_size, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
+	writel(rgn0_size, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
 	DBG("Linking RAM region 0 size @ %p, value: %x\n",
 	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG,
-	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG));
+	    readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG));
 
-	ptr = kzalloc(BITS_TO_LONGS(cppi41_queue_mgr[q_mgr].num_queue),
+	ptr = kzalloc(BITS_TO_LONGS(cppi41_queue_mgr[q_mgr].num_queue) * sizeof(long),
 		      GFP_KERNEL);
 	if (ptr == NULL) {
 		printk(KERN_ERR "ERROR: %s: Unable to allocate queue bitmap.\n",
@@ -146,8 +145,8 @@
 	q_mgr_regs = cppi41_queue_mgr[q_mgr].q_mgr_rgn_base;
 
 	/* free the Queue Mgr linking ram space */
-	__raw_writel(0,	q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
-	__raw_writel(0, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
+	writel(0,	q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
+	writel(0, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
 	dma_free_coherent(NULL, linking_ram[q_mgr].size,
 			linking_ram[q_mgr].virt_addr,
 			linking_ram[q_mgr].phys_addr);
@@ -176,7 +175,7 @@
 		}
 #endif
 		val = sched_tbl[i];
-		__raw_writel(val, dma_block->sched_table_base +
+		writel(val, dma_block->sched_table_base +
 			DMA_SCHED_TABLE_WORD_REG(i));
 		DBG("DMA scheduler table @ %p, value written: %x\n",
 		dma_block->sched_table_base + DMA_SCHED_TABLE_WORD_REG(i),
@@ -210,7 +209,7 @@
 			j++;
 		}
 		if (num_ch % 4 == 0) {
-			__raw_writel(val, dma_block->sched_table_base +
+			writel(val, dma_block->sched_table_base +
 				DMA_SCHED_TABLE_WORD_REG(tbl_index));
 			tbl_index++;
 			val = j = 0;
@@ -218,7 +217,7 @@
 	}
 
 	if (num_ch % 4) {
-		__raw_writel(val, dma_block->sched_table_base +
+		writel(val, dma_block->sched_table_base +
 			DMA_SCHED_TABLE_WORD_REG(tbl_index));
 	}
 	return num_ch;
@@ -248,7 +247,7 @@
 			j++;
 		}
 		if (num_ch % 4 == 0) {
-			__raw_writel(val, dma_block->sched_table_base +
+			writel(val, dma_block->sched_table_base +
 				DMA_SCHED_TABLE_WORD_REG(tbl_index));
 			tbl_index++;
 			val = j = 0;
@@ -256,7 +255,7 @@
 	}
 
 	if (num_ch % 4) {
-		__raw_writel(val, dma_block->sched_table_base +
+		writel(val, dma_block->sched_table_base +
 			DMA_SCHED_TABLE_WORD_REG(tbl_index));
 	}
 	return num_ch;
@@ -295,13 +294,13 @@
 	 * queue manager and queue number.
 	 */
 	dma_block = &cppi41_dma_block[dma_num];
-	__raw_writel((q_mgr << DMA_TD_DESC_QMGR_SHIFT) |
+	writel((q_mgr << DMA_TD_DESC_QMGR_SHIFT) |
 		     (q_num << DMA_TD_DESC_QNUM_SHIFT),
 		     dma_block->global_ctrl_base +
 		     DMA_TEARDOWN_FREE_DESC_CTRL_REG);
 	DBG("Teardown free descriptor control @ %p, value: %x\n",
 	    dma_block->global_ctrl_base + DMA_TEARDOWN_FREE_DESC_CTRL_REG,
-	    __raw_readl(dma_block->global_ctrl_base +
+	    readl(dma_block->global_ctrl_base +
 			DMA_TEARDOWN_FREE_DESC_CTRL_REG));
 
 	num_desc = 1 << num_order;
@@ -355,19 +354,19 @@
 	num_reg = (tbl_size + 3) / 4;
 	for (i = 0; i < num_reg; i++) {
 		val = sched_tbl[i];
-		__raw_writel(val, dma_block->sched_table_base +
+		writel(val, dma_block->sched_table_base +
 			     DMA_SCHED_TABLE_WORD_REG(i));
 		DBG("DMA scheduler table @ %p, value written: %x\n",
 		    dma_block->sched_table_base + DMA_SCHED_TABLE_WORD_REG(i),
 		    val);
 	}
 
-	__raw_writel((tbl_size - 1) << DMA_SCHED_LAST_ENTRY_SHIFT |
+	writel((tbl_size - 1) << DMA_SCHED_LAST_ENTRY_SHIFT |
 		     DMA_SCHED_ENABLE_MASK,
 		     dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG);
 	DBG("DMA scheduler control @ %p, value: %x\n",
 	    dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG,
-	    __raw_readl(dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG));
+	    readl(dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG));
 
 	return 0;
 
@@ -408,14 +407,14 @@
 	/* disable the dma schedular */
 	num_reg = (tbl_size + 3) / 4;
 	for (i = 0; i < num_reg; i++) {
-		__raw_writel(0, dma_block->sched_table_base +
+		writel(0, dma_block->sched_table_base +
 			     DMA_SCHED_TABLE_WORD_REG(i));
 		DBG("DMA scheduler table @ %p, value written: %x\n",
 		    dma_block->sched_table_base + DMA_SCHED_TABLE_WORD_REG(i),
 		    0);
 	}
 
-	__raw_writel(0,	dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG);
+	writel(0,	dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG);
 
 	return 0;
 }
@@ -450,10 +449,10 @@
 	desc_mem_regs = cppi41_queue_mgr[q_mgr].desc_mem_rgn_base;
 
 	/* Write the base register */
-	__raw_writel(rgn_addr, desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn));
+	writel(rgn_addr, desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn));
 	DBG("Descriptor region base @ %p, value: %x\n",
 	    desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn),
-	    __raw_readl(desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn)));
+	    readl(desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn)));
 
 	/* Write the control register */
 	ctrl = ((index << QMGR_MEM_RGN_INDEX_SHIFT) &
@@ -462,10 +461,10 @@
 		QMGR_MEM_RGN_DESC_SIZE_MASK) |
 	       (((num_order - 5) << QMGR_MEM_RGN_SIZE_SHIFT) &
 		QMGR_MEM_RGN_SIZE_MASK);
-	__raw_writel(ctrl, desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn));
+	writel(ctrl, desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn));
 	DBG("Descriptor region control @ %p, value: %x\n",
 	    desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn),
-	    __raw_readl(desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn)));
+	    readl(desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn)));
 
 	*mem_rgn = rgn;
 	return 0;
@@ -486,11 +485,11 @@
 
 	desc_mem_regs = cppi41_queue_mgr[q_mgr].desc_mem_rgn_base;
 
-	if (__raw_readl(desc_mem_regs + QMGR_MEM_RGN_BASE_REG(mem_rgn)) == 0)
+	if (readl(desc_mem_regs + QMGR_MEM_RGN_BASE_REG(mem_rgn)) == 0)
 		return -ENOENT;
 
-	__raw_writel(0, desc_mem_regs + QMGR_MEM_RGN_BASE_REG(mem_rgn));
-	__raw_writel(0, desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(mem_rgn));
+	writel(0, desc_mem_regs + QMGR_MEM_RGN_BASE_REG(mem_rgn));
+	writel(0, desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(mem_rgn));
 
 	return 0;
 }
@@ -512,7 +511,7 @@
 	/* Populate the channel object structure */
 	tx_ch_obj->base_addr  = cppi41_dma_block[dma_num].ch_ctrl_stat_base +
 				DMA_CH_TX_GLOBAL_CFG_REG(ch_num);
-	tx_ch_obj->global_cfg = __raw_readl(tx_ch_obj->base_addr);
+	tx_ch_obj->global_cfg = readl(tx_ch_obj->base_addr);
 	return 0;
 }
 EXPORT_SYMBOL(cppi41_tx_ch_init);
@@ -533,7 +532,7 @@
 	/* Populate the channel object structure */
 	rx_ch_obj->base_addr  = cppi41_dma_block[dma_num].ch_ctrl_stat_base +
 				DMA_CH_RX_GLOBAL_CFG_REG(ch_num);
-	rx_ch_obj->global_cfg = __raw_readl(rx_ch_obj->base_addr);
+	rx_ch_obj->global_cfg = readl(rx_ch_obj->base_addr);
 	return 0;
 }
 EXPORT_SYMBOL(cppi41_rx_ch_init);
@@ -566,11 +565,11 @@
 		DMA_CH_TX_DEFAULT_QNUM_MASK);
 
 	/* Get the current state of the enable bit. */
-	dma_ch_obj->global_cfg = val |= __raw_readl(dma_ch_obj->base_addr);
-	__raw_writel(val, dma_ch_obj->base_addr);
+	dma_ch_obj->global_cfg = val |= readl(dma_ch_obj->base_addr);
+	writel(val, dma_ch_obj->base_addr);
 	DBG("Channel global configuration @ %p, value written: %x, "
 	    "value read: %x\n", dma_ch_obj->base_addr, val,
-	    __raw_readl(dma_ch_obj->base_addr));
+	    readl(dma_ch_obj->base_addr));
 
 }
 EXPORT_SYMBOL(cppi41_dma_ch_default_queue);
@@ -582,7 +581,7 @@
 			    struct cppi41_rx_ch_cfg  *cfg)
 {
 	void __iomem *base = rx_ch_obj->base_addr;
-	u32 val = __raw_readl(rx_ch_obj->base_addr);
+	u32 val = readl(rx_ch_obj->base_addr);
 
 	val |= ((cfg->sop_offset << DMA_CH_RX_SOP_OFFSET_SHIFT) &
 		DMA_CH_RX_SOP_OFFSET_MASK) |
@@ -599,9 +598,9 @@
 	val |= (cfg->rx_max_buf_cnt << DMA_CH_RX_MAX_BUF_CNT_SHIFT);
 
 	rx_ch_obj->global_cfg = val;
-	__raw_writel(val, base);
+	writel(val, base);
 	DBG("Rx channel global configuration @ %p, value written: %x, "
-	    "value read: %x\n", base, val, __raw_readl(base));
+	    "value read: %x\n", base, val, readl(base));
 
 	base -= DMA_CH_RX_GLOBAL_CFG_REG(0);
 
@@ -624,7 +623,7 @@
 			DMA_CH_RX_EMBED_SOP_SLOT_SHIFT) &
 		       DMA_CH_RX_EMBED_SOP_SLOT_MASK);
 
-		__raw_writel(val, base + DMA_CH_RX_EMBED_PKT_CFG_REG_B(0));
+		writel(val, base + DMA_CH_RX_EMBED_PKT_CFG_REG_B(0));
 		DBG("Rx channel embedded packet configuration B @ %p, "
 		    "value written: %x\n",
 		    base + DMA_CH_RX_EMBED_PKT_CFG_REG_B(0), val);
@@ -654,7 +653,7 @@
 			DMA_CH_RX_EMBED_FBP_BMGR_SHIFT(3)) &
 		       DMA_CH_RX_EMBED_FBP_BMGR_MASK(3));
 
-		__raw_writel(val, base + DMA_CH_RX_EMBED_PKT_CFG_REG_A(0));
+		writel(val, base + DMA_CH_RX_EMBED_PKT_CFG_REG_A(0));
 		DBG("Rx channel embedded packet configuration A @ %p, "
 		    "value written: %x\n",
 		    base + DMA_CH_RX_EMBED_PKT_CFG_REG_A(0), val);
@@ -673,7 +672,7 @@
 			DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(1)) &
 		       DMA_CH_RX_HOST_FDQ_QMGR_MASK(1));
 
-		__raw_writel(val, base + DMA_CH_RX_HOST_PKT_CFG_REG_A(0));
+		writel(val, base + DMA_CH_RX_HOST_PKT_CFG_REG_A(0));
 		DBG("Rx channel host packet configuration A @ %p, "
 		    "value written: %x\n",
 		    base + DMA_CH_RX_HOST_PKT_CFG_REG_A(0), val);
@@ -691,7 +690,7 @@
 			DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(3)) &
 		       DMA_CH_RX_HOST_FDQ_QMGR_MASK(3));
 
-		__raw_writel(val, base + DMA_CH_RX_HOST_PKT_CFG_REG_B(0));
+		writel(val, base + DMA_CH_RX_HOST_PKT_CFG_REG_B(0));
 		DBG("Rx channel host packet configuration B @ %p, "
 		    "value written: %x\n",
 		    base + DMA_CH_RX_HOST_PKT_CFG_REG_B(0), val);
@@ -707,7 +706,7 @@
 			DMA_CH_RX_MONO_SOP_OFFSET_SHIFT) &
 		       DMA_CH_RX_MONO_SOP_OFFSET_MASK);
 
-		__raw_writel(val, base + DMA_CH_RX_MONO_PKT_CFG_REG(0));
+		writel(val, base + DMA_CH_RX_MONO_PKT_CFG_REG(0));
 		DBG("Rx channel monolithic packet configuration @ %p, "
 		    "value written: %x\n",
 		    base + DMA_CH_RX_MONO_PKT_CFG_REG(0), val);
@@ -720,17 +719,17 @@
 			    u8 rx_max_buf_cnt)
 {
 	void __iomem *base = rx_ch_obj->base_addr;
-	u32 val = __raw_readl(rx_ch_obj->base_addr);
+	u32 val = readl(rx_ch_obj->base_addr);
 
 	val = rx_ch_obj->global_cfg;
 	val &= ~(0x7 << DMA_CH_RX_MAX_BUF_CNT_SHIFT);
 	val |= (rx_max_buf_cnt << DMA_CH_RX_MAX_BUF_CNT_SHIFT);
 
 	rx_ch_obj->global_cfg = val;
-	__raw_writel(val, base);
+	writel(val, base);
 
 	DBG("%s: rx-global-cfg @ %p, value written: %x, "
-	    "value read: %x\n", __func__, base, val, __raw_readl(base));
+	    "value read: %x\n", __func__, base, val, readl(base));
 
 }
 EXPORT_SYMBOL(cppi41_rx_ch_set_maxbufcnt);
@@ -739,14 +738,14 @@
  */
 void cppi41_dma_ch_teardown(struct cppi41_dma_ch_obj *dma_ch_obj)
 {
-	u32 val = __raw_readl(dma_ch_obj->base_addr);
+	u32 val = readl(dma_ch_obj->base_addr);
 
 	/* Initiate channel teardown. */
 	val |= dma_ch_obj->global_cfg & ~DMA_CH_TX_ENABLE_MASK;
 	dma_ch_obj->global_cfg = val |= DMA_CH_TX_TEARDOWN_MASK;
-	__raw_writel(val, dma_ch_obj->base_addr);
+	writel(val, dma_ch_obj->base_addr);
 	DBG("Tear down channel @ %p, value written: %x, value read: %x\n",
-	    dma_ch_obj->base_addr, val, __raw_readl(dma_ch_obj->base_addr));
+	    dma_ch_obj->base_addr, val, readl(dma_ch_obj->base_addr));
 }
 EXPORT_SYMBOL(cppi41_dma_ch_teardown);
 
@@ -761,9 +760,9 @@
 
 	/* Teardown bit remains set after completion, so clear it now... */
 	dma_ch_obj->global_cfg = val &= ~DMA_CH_TX_TEARDOWN_MASK;
-	__raw_writel(val, dma_ch_obj->base_addr);
+	writel(val, dma_ch_obj->base_addr);
 	DBG("Enable channel @ %p, value written: %x, value read: %x\n",
-	    dma_ch_obj->base_addr, val, __raw_readl(dma_ch_obj->base_addr));
+	    dma_ch_obj->base_addr, val, readl(dma_ch_obj->base_addr));
 }
 EXPORT_SYMBOL(cppi41_dma_ch_enable);
 
@@ -773,10 +772,10 @@
 void cppi41_dma_ch_disable(struct cppi41_dma_ch_obj *dma_ch_obj)
 {
 	dma_ch_obj->global_cfg &= ~DMA_CH_TX_ENABLE_MASK;
-	__raw_writel(dma_ch_obj->global_cfg, dma_ch_obj->base_addr);
+	writel(dma_ch_obj->global_cfg, dma_ch_obj->base_addr);
 	DBG("Disable channel @ %p, value written: %x, value read: %x\n",
 	    dma_ch_obj->base_addr, dma_ch_obj->global_cfg,
-	    __raw_readl(dma_ch_obj->base_addr));
+	    readl(dma_ch_obj->base_addr));
 }
 EXPORT_SYMBOL(cppi41_dma_ch_disable);
 
@@ -940,7 +939,7 @@
 	if (pkt_size)
 		val = (pkt_size << QMGR_QUEUE_PKT_SIZE_SHIFT) &
 		      QMGR_QUEUE_PKT_SIZE_MASK;
-	__raw_writel(val, queue_obj->base_addr + QMGR_QUEUE_REG_C(0));
+	writel(val, queue_obj->base_addr + QMGR_QUEUE_REG_C(0));
 #endif
 
 	val = (((desc_size - 24) >> (2 - QMGR_QUEUE_DESC_SIZE_SHIFT)) &
@@ -949,7 +948,7 @@
 
 	DBG("Pushing value %x to queue @ %p\n", val, queue_obj->base_addr);
 
-	__raw_writel(val, queue_obj->base_addr + QMGR_QUEUE_REG_D(0));
+	writel(val, queue_obj->base_addr + QMGR_QUEUE_REG_D(0));
 }
 EXPORT_SYMBOL(cppi41_queue_push);
 
@@ -958,7 +957,7 @@
  */
 unsigned long cppi41_queue_pop(const struct cppi41_queue_obj *queue_obj)
 {
-	u32 val = __raw_readl(queue_obj->base_addr + QMGR_QUEUE_REG_D(0));
+	u32 val = readl(queue_obj->base_addr + QMGR_QUEUE_REG_D(0));
 
 	DBG("Popping value %x from queue @ %p\n", val, queue_obj->base_addr);
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41.h	2014-08-07 11:51:55.754748536 -0600
@@ -259,6 +259,7 @@
 #define CPPI41_PKT_TYPE_USB		5
 #define CPPI41_PKT_TYPE_GENERIC		6
 #define CPPI41_PKT_TYPE_ETHERNET	7
+#define CPPI41_ZLP			(1 << 19)
 #define CPPI41_RETURN_POLICY_SHIFT	15
 #define CPPI41_RETURN_POLICY_MASK	(1 << CPPI41_RETURN_POLICY_SHIFT)
 #define CPPI41_RETURN_LINKED		0
@@ -483,6 +484,11 @@
 	u8 num_rx_ch;		/* Number of the Rx channels. */
 	u8 num_max_ch;		/* maximum dma channels */
 	const struct cppi41_tx_ch *tx_ch_info;
+	void *desc_vaddr;
+	dma_addr_t desc_paddr;
+	u32 numdesc;
+	u32 desc_totsize;
+	u8 mem_rgn;
 };
 
 extern struct cppi41_queue_mgr cppi41_queue_mgr[];
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41_dma.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41_dma.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41_dma.c	2014-08-07 11:51:55.754748536 -0600
@@ -28,12 +28,6 @@
 #include "musb_dma.h"
 #include "cppi41_dma.h"
 
-/* Configuration */
-#define USB_CPPI41_DESC_SIZE_SHIFT 6
-#define USB_CPPI41_DESC_ALIGN	(1 << USB_CPPI41_DESC_SIZE_SHIFT)
-#define USB_CPPI41_CH_NUM_PD	128	/* 4K bulk data at full speed */
-#define USB_CPPI41_MAX_PD	(USB_CPPI41_CH_NUM_PD * (USB_CPPI41_NUM_CH+1))
-
 #undef DEBUG_CPPI_TD
 #undef USBDRV_DEBUG
 
@@ -47,23 +41,6 @@
  * Data structure definitions
  */
 
-/*
- * USB Packet Descriptor
- */
-struct usb_pkt_desc;
-
-struct usb_pkt_desc {
-	/* Hardware descriptor fields from this point */
-	struct cppi41_host_pkt_desc hw_desc;	/* 40 bytes */
-	/* Protocol specific data */
-	dma_addr_t dma_addr;			/* offs:44 byte */
-	struct usb_pkt_desc *next_pd_ptr;	/* offs:48 byte*/
-	u8 ch_num;
-	u8 ep_num;
-	u8 eop;
-	u8 res1;				/* offs:52 */
-	u8 res2[12];				/* offs:64 */
-};
 
 /**
  * struct cppi41_channel - DMA Channel Control Structure
@@ -99,6 +76,13 @@
 	u8  zlp_queued;
 	u8  inf_mode;
 	u8  tx_complete;
+	u8  rx_complete;
+	u8  txdma_intr_first;
+	u8  txfifo_intr_enable;
+	u8  count;
+	u8  hb_mult;
+	u8  txfifo_intr_first;
+	struct usb_pkt_desc *curr_pd;
 };
 
 /**
@@ -114,6 +98,7 @@
 	struct cppi41_channel tx_cppi_ch[USB_CPPI41_NUM_CH];
 	struct cppi41_channel rx_cppi_ch[USB_CPPI41_NUM_CH];
 	struct work_struct      txdma_work;
+	struct work_struct      rxdma_work;
 
 	struct usb_pkt_desc *pd_pool_head; /* Free PD pool head */
 	dma_addr_t pd_mem_phys;		/* PD memory physical address */
@@ -129,12 +114,13 @@
 	u32 automode_reg_offs;		/* USB_AUTOREQ_REG offset */
 	u32 teardown_reg_offs;		/* USB_TEARDOWN_REG offset */
 	u32 bd_size;
-	u8  inf_mode;
 	u8  txfifo_intr_enable;		/* txfifo empty interrupt logic */
 };
 
 struct usb_cppi41_info usb_cppi41_info[2];
 EXPORT_SYMBOL(usb_cppi41_info);
+static void usb_process_tx_queue(struct cppi41 *cppi, unsigned index);
+static void rxdma_completion_work(struct work_struct *data);
 
 #ifdef DEBUG_CPPI_TD
 static void print_pd_list(struct usb_pkt_desc *pd_pool_head)
@@ -208,25 +194,15 @@
 	 * dma_alloc_coherent()  will return a page aligned address, so our
 	 * alignment requirement will be honored.
 	 */
-	cppi->bd_size = USB_CPPI41_MAX_PD * sizeof(struct usb_pkt_desc);
-	cppi->pd_mem = dma_alloc_coherent(cppi->musb->controller,
-					  cppi->bd_size,
-					  &cppi->pd_mem_phys,
-					  GFP_KERNEL | GFP_DMA);
-	if (cppi->pd_mem == NULL) {
+	cppi->bd_size = cppi_info->numdesc * sizeof(struct usb_pkt_desc);
+	cppi->pd_mem = (void *)cppi_info->desc_vaddr;
+	cppi->pd_mem_phys = cppi_info->desc_paddr;
+
+	if (!cppi->pd_mem || !cppi->pd_mem_phys) {
 		DBG(1, "ERROR: packet descriptor memory allocation failed\n");
 		return 0;
 	}
 
-	if (cppi41_mem_rgn_alloc(cppi_info->q_mgr, cppi->pd_mem_phys,
-				 USB_CPPI41_DESC_SIZE_SHIFT,
-				 get_count_order(USB_CPPI41_MAX_PD),
-				 &cppi->pd_mem_rgn)) {
-		DBG(1, "ERROR: queue manager memory region allocation "
-		    "failed\n");
-		goto free_pds;
-	}
-
 	/* Allocate the teardown completion queue */
 	if (cppi41_queue_alloc(CPPI41_UNASSIGNED_QUEUE,
 			       0, &cppi->teardownQNum)) {
@@ -314,11 +290,6 @@
 	if (cppi41_mem_rgn_free(cppi_info->q_mgr, cppi->pd_mem_rgn))
 		DBG(1, "ERROR: failed to free queue manager memory region\n");
 
- free_pds:
-	dma_free_coherent(cppi->musb->controller,
-			  cppi->bd_size,
-			  cppi->pd_mem, cppi->pd_mem_phys);
-
 	return 0;
 }
 
@@ -341,16 +312,6 @@
 	if (cppi41_queue_free(cppi_info->q_mgr, cppi->teardownQNum))
 		DBG(1, "ERROR: failed to free teardown completion queue\n");
 
-	/*
-	 * Free the packet descriptor region allocated
-	 * for all Tx/Rx channels.
-	 */
-	if (cppi41_mem_rgn_free(cppi_info->q_mgr, cppi->pd_mem_rgn))
-		DBG(1, "ERROR: failed to free queue manager memory region\n");
-
-	dma_free_coherent(cppi->musb->controller, cppi->bd_size,
-			  cppi->pd_mem, cppi->pd_mem_phys);
-
 	cppi->pd_mem = 0;
 	cppi->pd_mem_phys = 0;
 	cppi->pd_pool_head = 0;
@@ -564,6 +525,7 @@
 	u16 q_mgr = cppi_info->q_mgr;
 	u16 tx_comp_q = cppi_info->tx_comp_q[tx_ch->ch_num];
 	u8 en_bd_intr = cppi->en_bd_intr;
+	struct musb_hw_ep *hw_ep = cppi->musb->endpoints + tx_ch->end_pt->epnum;
 
 	/*
 	 * Tx can use the generic RNDIS mode where we can probably fit this
@@ -590,6 +552,19 @@
 	    tx_ch->ch_num, tx_ch->dma_mode ? "accelerated" : "transparent",
 	    pkt_size, num_pds, tx_ch->start_addr + tx_ch->curr_offset, length);
 
+	/* Enable txfifo empty interrupt logic for supported platform to make
+	 * sure last byte is transferred out of txfifo, this logic
+	 * enabled only for isochronous transfer types. There is HW bug
+	 * in TxFifoEmpty interrupt logic when multiple tx endpoints active
+	 * in parallel
+	 */
+	if (hw_ep->xfer_type == USB_ENDPOINT_XFER_ISOC
+		&& cppi->txfifo_intr_enable
+		&& length <= tx_ch->pkt_size) {
+			tx_ch->txfifo_intr_enable = 1;
+			tx_ch->txfifo_intr_first = 0;
+	}
+
 	for (n = 0; n < num_pds; n++) {
 		struct cppi41_host_pkt_desc *hw_desc;
 
@@ -631,6 +606,16 @@
 		DBG(5, "TX PD %p: buf %08x, len %08x, pkt info %08x\n", curr_pd,
 		    hw_desc->buf_ptr, hw_desc->buf_len, hw_desc->pkt_info);
 
+		/* make sure descriptor details are updated to memory*/
+		dsb();
+
+		/* enable tx fifo empty interrupt */
+		if (tx_ch->txfifo_intr_enable) {
+			DBG(1, "txs(%p %d) enable txFintr\n", curr_pd,
+				hw_desc->orig_buf_len & ~CPPI41_PKT_INTR_FLAG);
+			txfifoempty_int_enable(cppi->musb, curr_pd->ep_num);
+		}
+
 		cppi41_queue_push(&tx_ch->queue_obj, curr_pd->dma_addr,
 				  USB_CPPI41_DESC_ALIGN, pkt_size);
 	}
@@ -741,56 +726,59 @@
 	struct cppi41_host_pkt_desc *hw_desc;
 	u32 length = rx_ch->length - rx_ch->curr_offset;
 	u32 pkt_size = rx_ch->pkt_size;
-	u32 max_rx_transfer_size = 64 * 1024;
+	u32 max_rx_transfer_size = MAX_GRNDIS_PKTSIZE;
 	u32 i, n_bd , pkt_len;
-	struct usb_gadget_driver *gadget_driver;
-	u8 en_bd_intr = cppi->en_bd_intr, mode;
+	u8 en_bd_intr = cppi->en_bd_intr;
+	u8 dma_mode, autoreq;
 
-	if (is_peripheral_active(cppi->musb)) {
-		/* TODO: temporary fix for CDC/RNDIS which needs to be in
-		 * GENERIC_RNDIS mode. Without this RNDIS gadget taking
-		 * more then 2K ms for a 64 byte pings.
-		 */
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		gadget_driver = cppi->musb->gadget_driver;
-#endif
-		pkt_len = rx_ch->pkt_size;
-		mode = USB_GENERIC_RNDIS_MODE;
-		if (!strcmp(gadget_driver->driver.name, "g_file_storage")) {
-			if (cppi->inf_mode && length > pkt_len) {
-				pkt_len = 0;
-				length = length - rx_ch->pkt_size;
-				cppi41_rx_ch_set_maxbufcnt(&rx_ch->dma_ch_obj,
-					DMA_CH_RX_MAX_BUF_CNT_1);
-				rx_ch->inf_mode = 1;
-			} else {
-				max_rx_transfer_size = rx_ch->pkt_size;
-				mode = USB_TRANSPARENT_MODE;
-			}
-		} else
-			if (rx_ch->length < max_rx_transfer_size)
-				pkt_len = rx_ch->length;
+	pkt_len = rx_ch->length;
+	/*
+	 * Rx can use the generic RNDIS mode where we can
+	 * probably fit this transfer in one PD and one IRQ
+	 * (or two with a short packet).
+	 */
+	dma_mode = USB_TRANSPARENT_MODE;
+	autoreq = USB_AUTOREQ_ALL_BUT_EOP;
+	if (((pkt_size & 0x3f) == 0) &&
+		cppi->cppi_info->rx_dma_mode == USB_GENERIC_RNDIS_MODE) {
+			dma_mode = USB_GENERIC_RNDIS_MODE;
+	}
+
+	if (dma_mode == USB_GENERIC_RNDIS_MODE) {
+		if (cppi->cppi_info->rx_inf_mode) {
+			if (length >= 2 * rx_ch->pkt_size)
+				dma_mode = USB_INFINITE_DMAMODE;
+			else
+				dma_mode = USB_TRANSPARENT_MODE;
+		}
+	}
 
-		if (mode != USB_TRANSPARENT_MODE)
-			cppi41_set_ep_size(rx_ch, pkt_len);
-		cppi41_mode_update(rx_ch, mode);
+	if (length < rx_ch->pkt_size)
+		dma_mode = USB_TRANSPARENT_MODE;
+
+	if (dma_mode == USB_INFINITE_DMAMODE) {
+		pkt_len = 0;
+		length = length - rx_ch->pkt_size;
+		cppi41_rx_ch_set_maxbufcnt(
+			&rx_ch->dma_ch_obj,
+			DMA_CH_RX_MAX_BUF_CNT_1);
+			rx_ch->inf_mode = 1;
+		dma_mode = USB_GENERIC_RNDIS_MODE;
+		autoreq = USB_AUTOREQ_ALWAYS;
 	} else {
-		/*
-		 * Rx can use the generic RNDIS mode where we can
-		 * probably fit this transfer in one PD and one IRQ
-		 * (or two with a short packet).
-		 */
-		if ((pkt_size & 0x3f) == 0) {
-			cppi41_mode_update(rx_ch, USB_GENERIC_RNDIS_MODE);
-			cppi41_autoreq_update(rx_ch, USB_AUTOREQ_ALL_BUT_EOP);
+		if (pkt_len > max_rx_transfer_size)
+			pkt_len = max_rx_transfer_size;
+	}
 
-			pkt_size = (length > 0x10000) ? 0x10000 : length;
-			cppi41_set_ep_size(rx_ch, pkt_size);
-		} else {
-			cppi41_mode_update(rx_ch, USB_TRANSPARENT_MODE);
-			cppi41_autoreq_update(rx_ch, USB_NO_AUTOREQ);
-			max_rx_transfer_size = rx_ch->pkt_size;
-		}
+	/* update cppi mode */
+	cppi41_mode_update(rx_ch, dma_mode);
+
+	if (dma_mode != USB_TRANSPARENT_MODE) {
+		if (is_host_enabled(cppi->musb))
+			cppi41_autoreq_update(rx_ch, autoreq);
+		cppi41_set_ep_size(rx_ch, pkt_len);
+	} else if (is_host_enabled(cppi->musb)) {
+		cppi41_autoreq_update(rx_ch, USB_NO_AUTOREQ);
 	}
 
 	DBG(4, "RX DMA%u, %s, maxpkt %u, addr %#x, rec'd %u/%u\n",
@@ -800,6 +788,12 @@
 
 	/* calculate number of bd required */
 	n_bd = (length + max_rx_transfer_size - 1)/max_rx_transfer_size;
+	if (dma_mode == USB_TRANSPARENT_MODE) {
+		if (!rx_ch->hb_mult)
+			max_rx_transfer_size = rx_ch->pkt_size;
+		else
+			max_rx_transfer_size = rx_ch->hb_mult * rx_ch->pkt_size;
+	}
 
 	for (i = 0; i < n_bd ; ++i) {
 		/* Get Rx packet descriptor from the free pool */
@@ -832,6 +826,10 @@
 
 		if (en_bd_intr)
 			hw_desc->orig_buf_len |= CPPI41_PKT_INTR_FLAG;
+
+		/* make sure descriptor details are updated to memory*/
+		dsb();
+
 		/*
 		 * Push the free Rx packet descriptor
 		 * to the free descriptor/buffer queue.
@@ -845,10 +843,28 @@
 	 * HCD arranged ReqPkt for the first packet.
 	 * We arrange it for all but the last one.
 	 */
-	if (is_host_active(cppi->musb) && rx_ch->channel.actual_len) {
+	if (is_host_active(cppi->musb) && rx_ch->channel.actual_len &&
+		!rx_ch->inf_mode) {
 		void __iomem *epio = rx_ch->end_pt->regs;
 		u16 csr = musb_readw(epio, MUSB_RXCSR);
+		u8 curr_toggle = (csr & MUSB_RXCSR_H_DATATOGGLE) ? 1 : 0;
+		if (cppi->musb->datatog_fix) {
+			/* check if data toggle bit got out of sync */
+			if (curr_toggle == rx_ch->end_pt->prev_toggle) {
+				DBG(4, "Data toggle same as previous (=%d) on"
+					"ep%d\n", curr_toggle,
+					rx_ch->end_pt->epnum);
+
+				csr |= MUSB_RXCSR_H_DATATOGGLE |
+					MUSB_RXCSR_H_WR_DATATOGGLE;
+				musb_writew(epio, MUSB_RXCSR, csr);
 
+				rx_ch->end_pt->prev_toggle = !curr_toggle;
+			} else {
+				rx_ch->end_pt->prev_toggle = curr_toggle;
+			}
+		}
+		csr = musb_readw(epio, MUSB_RXCSR);
 		csr |= MUSB_RXCSR_H_REQPKT | MUSB_RXCSR_H_WZC_BITS;
 		musb_writew(epio, MUSB_RXCSR, csr);
 	}
@@ -904,7 +920,8 @@
 	/* Set the transfer parameters, then queue up the first segment */
 	cppi_ch->start_addr = dma_addr;
 	cppi_ch->curr_offset = 0;
-	cppi_ch->pkt_size = maxpacket;
+	cppi_ch->hb_mult = (maxpacket >> 11) & 0x03;
+	cppi_ch->pkt_size = maxpacket & ~(3 << 11);
 	cppi_ch->length = length;
 	cppi_ch->transfer_mode = mode;
 	cppi_ch->zlp_queued = 0;
@@ -1134,7 +1151,7 @@
 	void __iomem *reg_base, *epio;
 	unsigned long pd_addr;
 	u32 csr, td_reg;
-	u8 ch_num, ep_num;
+	u8 ch_num, ep_num, i;
 
 	cppi_ch = container_of(channel, struct cppi41_channel, channel);
 	ch_num = cppi_ch->ch_num;
@@ -1170,6 +1187,13 @@
 	if (cppi_ch->transmit) {
 		dprintk("Tx channel teardown, cppi_ch = %p\n", cppi_ch);
 
+		/* disable the DMAreq before teardown */
+		csr  = musb_readw(epio, MUSB_TXCSR);
+		csr &= ~MUSB_TXCSR_DMAENAB;
+		musb_writew(epio, MUSB_TXCSR, csr);
+
+		cppi_ch->tx_complete = 0;
+		cppi_ch->txdma_intr_first = 0;
 		/* Tear down Tx DMA channel */
 		usb_tx_ch_teardown(cppi_ch);
 
@@ -1179,19 +1203,52 @@
 		musb_writel(reg_base, cppi->teardown_reg_offs, td_reg);
 
 		/* Flush FIFO of the endpoint */
-		csr  = musb_readw(epio, MUSB_TXCSR);
-		csr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_H_WZC_BITS;
-		musb_writew(epio, MUSB_TXCSR, csr);
-		musb_writew(epio, MUSB_TXCSR, csr);
-		cppi_ch->tx_complete = 0;
+		for (i = 0; i < 2; ++i) {
+			csr  = musb_readw(epio, MUSB_TXCSR);
+			if (csr & MUSB_TXCSR_TXPKTRDY) {
+				csr |= MUSB_TXCSR_FLUSHFIFO |
+					MUSB_TXCSR_H_WZC_BITS;
+				musb_writew(epio, MUSB_TXCSR, csr);
+			}
+		}
 	} else { /* Rx */
 		dprintk("Rx channel teardown, cppi_ch = %p\n", cppi_ch);
 
+		cppi_ch->rx_complete = 0;
+		/* For host, ensure ReqPkt is never set again */
+		cppi41_autoreq_update(cppi_ch, USB_NO_AUTOREQ);
+
+		/* disable the DMAreq and remove reqpkt */
+		csr  = musb_readw(epio, MUSB_RXCSR);
+		/* 250usec delay to drain to cppi dma
+		 * pipe line */
+		udelay(250);
+		DBG(4, "before rx-teardown: rxcsr %x rxcount %x\n", csr,
+			musb_readw(epio, MUSB_RXCOUNT));
+
+		/* For host, clear (just) ReqPkt at end of current packet(s) */
+		if (is_host_active(cppi->musb))
+			csr &= ~MUSB_RXCSR_H_REQPKT;
+
+		csr &= ~MUSB_RXCSR_DMAENAB;
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		/* wait till xdma completes last 64 bytes transfer from
+		 * mentor fifo to internal cppi fifo and drain
+		 * cppi dma pipe line
+		 */
+		udelay(250);
+
 		/* Flush FIFO of the endpoint */
 		csr  = musb_readw(epio, MUSB_RXCSR);
-		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_H_WZC_BITS;
+
+		if (csr & MUSB_RXCSR_RXPKTRDY)
+			csr |= MUSB_RXCSR_FLUSHFIFO;
+
+		csr |= MUSB_RXCSR_H_WZC_BITS;
 		musb_writew(epio, MUSB_RXCSR, csr);
 		musb_writew(epio, MUSB_RXCSR, csr);
+		csr  = musb_readw(epio, MUSB_RXCSR);
 
 		/* Issue CPPI FIFO teardown for Rx channel */
 		td_reg  = musb_readl(reg_base, cppi->teardown_reg_offs);
@@ -1210,22 +1267,6 @@
 
 		/* For host, ensure ReqPkt is never set again */
 		cppi41_autoreq_update(cppi_ch, USB_NO_AUTOREQ);
-
-		/* For host, clear (just) ReqPkt at end of current packet(s) */
-		if (is_host_active(cppi->musb))
-			csr &= ~MUSB_RXCSR_H_REQPKT;
-		csr |= MUSB_RXCSR_H_WZC_BITS;
-
-		/* Clear DMA enable */
-		csr &= ~MUSB_RXCSR_DMAENAB;
-		musb_writew(epio, MUSB_RXCSR, csr);
-
-		/* Flush the FIFO of endpoint once again */
-		csr  = musb_readw(epio, MUSB_RXCSR);
-		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_H_WZC_BITS;
-		musb_writew(epio, MUSB_RXCSR, csr);
-
-		udelay(50);
 	}
 
 	/*
@@ -1272,7 +1313,6 @@
 	unsigned long flags;
 
 	while (1) {
-		spin_lock_irqsave(&musb->lock, flags);
 		for (index = 0; index < USB_CPPI41_NUM_CH; index++) {
 			void __iomem *epio;
 			u16 csr;
@@ -1287,27 +1327,34 @@
 				 */
 				if (!tx_ch->end_pt) {
 					tx_ch->tx_complete = 0;
+					tx_ch->count = 0;
 					continue;
 				}
 
 				epio = tx_ch->end_pt->regs;
 				csr = musb_readw(epio, MUSB_TXCSR);
 
-				if (!cppi->txfifo_intr_enable &&
+				if (!tx_ch->txfifo_intr_enable &&
 					(csr & (MUSB_TXCSR_TXPKTRDY |
 					MUSB_TXCSR_FIFONOTEMPTY))) {
 					resched = 1;
 				} else {
+					if (tx_ch->count > 0) {
+						tx_ch->count--;
+						resched = 1;
+						continue;
+					}
 					tx_ch->channel.status =
 						MUSB_DMA_STATUS_FREE;
 					tx_ch->tx_complete = 0;
+					spin_lock_irqsave(&musb->lock, flags);
 					musb_dma_completion(musb, index+1, 1);
+					spin_unlock_irqrestore(&musb->lock, flags);
 				}
 			}
 		}
-		spin_unlock_irqrestore(&musb->lock, flags);
 
-		if (!cppi->txfifo_intr_enable && resched) {
+		if (resched) {
 			resched = 0;
 			cond_resched();
 		} else {
@@ -1317,12 +1364,42 @@
 
 }
 
-void cppi41_handle_txfifo_intr(struct musb *musb)
+void cppi41_handle_txfifo_intr(struct musb *musb, u16 usbintr)
 {
 	struct cppi41 *cppi;
+	struct cppi41_channel *tx_ch;
+	int index;
 
 	cppi = container_of(musb->dma_controller, struct cppi41, controller);
-	schedule_work(&cppi->txdma_work);
+	for (index = 0; (index < USB_CPPI41_NUM_CH) && usbintr; index++) {
+		if (usbintr & 1) {
+			tx_ch = &cppi->tx_cppi_ch[index];
+			/* disable txfifo empty interupt */
+			txfifoempty_int_disable(musb, index+1);
+			if (!tx_ch->txfifo_intr_enable)
+				DBG(4, "Bug, wrong TxFintr ep%d\n",
+					index+1);
+			tx_ch->txfifo_intr_enable = 0;
+
+			if (tx_ch->txdma_intr_first) {
+				tx_ch->txdma_intr_first = 0;
+				tx_ch->channel.status =
+					MUSB_DMA_STATUS_FREE;
+
+				DBG(4, "txc: givback ep%d\n", index+1);
+				musb_dma_completion(musb, index+1, 1);
+			} else {
+				/* sometime the TxFifoEmpty interupt comes
+				 * first followed by dma interrupt, hence
+				 * service dma interrupt.
+				 */
+				tx_ch->txfifo_intr_first = 1;
+				DBG(4, "Early TxFIntr ep%d\n", index+1);
+				usb_process_tx_queue(cppi, index);
+			}
+		}
+		usbintr = usbintr >> 1;
+	}
 }
 EXPORT_SYMBOL(cppi41_handle_txfifo_intr);
 
@@ -1351,12 +1428,34 @@
 	cppi->en_bd_intr = cppi->cppi_info->bd_intr_ctrl;
 	cppi->txfifo_intr_enable = musb->txfifo_intr_enable;
 	INIT_WORK(&cppi->txdma_work, txdma_completion_work);
+	INIT_WORK(&cppi->rxdma_work, rxdma_completion_work);
+
+	/*
+	 * Extra IN token has been seen when a file is transferred from one MSC
+	 * device to other due to xDMA IP bug when multiple masters access
+	 * mentor controller register space.
+	 * As a software workaround use transparent mode and correct data toggle
+	 * when they go wrong.
+	 * This issue is expected to be fixed in RTL version post 0xD.
+	 */
+	if ((cppi->cppi_info->version & USBSS_RTL_VERSION_MASK) >
+			USBSS_RTL_VERSION_D) {
+		cppi->cppi_info->rx_dma_mode = USB_GENERIC_RNDIS_MODE;
+		cppi->musb->datatog_fix = 0;
+	} else {
+		cppi->cppi_info->rx_dma_mode = USB_TRANSPARENT_MODE;
+		cppi->musb->datatog_fix = 1;
+	}
 
 	/* enable infinite mode only for ti81xx silicon rev2 */
 	if (cpu_is_ti81xx() && ((omap_rev() == TI8168_REV_ES2_0) ||
 		(omap_rev() == TI8148_REV_ES2_0))) {
 		DBG(1, "cppi41dma supports infinite mode\n");
-		cppi->inf_mode = 1;
+		/*
+		 * to enable inf_mode, generic rndis mode must be
+		 * enabled. also datatog_fix must be set to zero
+		 */
+		cppi->cppi_info->rx_inf_mode = 0;
 	}
 
 	return &cppi->controller;
@@ -1422,6 +1521,8 @@
 		    (tx_ch->transfer_mode && !tx_ch->zlp_queued))
 			cppi41_next_tx_segment(tx_ch);
 		else if (tx_ch->channel.actual_len >= tx_ch->length) {
+			void __iomem *epio;
+			u16 csr;
 
 			/*
 			 * We get Tx DMA completion interrupt even when
@@ -1431,10 +1532,176 @@
 			 * USB functionality. So far, we have obsered
 			 * failure with iperf.
 			 */
-			tx_ch->tx_complete = 1;
-			if (!cppi->txfifo_intr_enable)
-				schedule_work(&cppi->txdma_work);
+			/* wait for tx fifo empty completion interrupt
+			 * if enabled other wise use the workthread
+			 * to poll fifo empty status
+			 */
+			epio = tx_ch->end_pt->regs;
+			csr = musb_readw(epio, MUSB_TXCSR);
+
+			if (tx_ch->txfifo_intr_enable) {
+				tx_ch->txdma_intr_first = 1;
+				DBG(4, "wait for TxF-EmptyIntr ep%d\n", ep_num);
+			} else if (tx_ch->txfifo_intr_first) {
+				tx_ch->txfifo_intr_first = 0;
+				tx_ch->channel.status = MUSB_DMA_STATUS_FREE;
+				musb_dma_completion(cppi->musb, ep_num, 1);
+			} else {
+				int residue;
+
+				residue = tx_ch->channel.actual_len %
+						tx_ch->pkt_size;
+
+				if (tx_ch->pkt_size > 128 && !residue) {
+					tx_ch->channel.status =
+						MUSB_DMA_STATUS_FREE;
+					musb_dma_completion(cppi->musb,
+						ep_num, 1);
+				} else {
+					tx_ch->tx_complete = 1;
+					tx_ch->count = 1;
+					schedule_work(&cppi->txdma_work);
+				}
+			}
+		}
+	}
+}
+static void usb_process_rx_bd(struct cppi41 *cppi,
+		struct usb_pkt_desc *curr_pd)
+{
+	u8 en_bd_intr = cppi->en_bd_intr;
+	struct cppi41_channel *rx_ch;
+	u8 ch_num, ep_num;
+	u32 length = 0, orig_buf_len;
+
+	/* Extract the data from received packet descriptor */
+	length = curr_pd->hw_desc.desc_info & CPPI41_PKT_LEN_MASK;
+	ch_num = curr_pd->ch_num;
+	ep_num = curr_pd->ep_num;
+	rx_ch = &cppi->rx_cppi_ch[ch_num];
+	DBG(4, "Rx complete: dma channel(%d) ep%d len %d\n",
+		ch_num, ep_num, length);
+
+	rx_ch->channel.actual_len += length;
+
+	if (curr_pd->eop) {
+		curr_pd->eop = 0;
+		/* disable the rx dma schedular */
+		if (is_peripheral_active(cppi->musb) &&
+			!cppi->cppi_info->rx_inf_mode)
+			cppi41_schedtbl_remove_dma_ch(0, 0, ch_num, 0);
+	}
+
+	/*
+	 * Return Rx PD to the software list --
+	 * this is protected by critical section
+	 */
+	usb_put_free_pd(cppi, curr_pd);
+
+	orig_buf_len = curr_pd->hw_desc.orig_buf_len;
+	if (en_bd_intr)
+		orig_buf_len &= ~CPPI41_PKT_INTR_FLAG;
+
+	DBG(4, "curr_pd=%p, len=%d, origlen=%d,rxch(alen/len)=%d/%d\n",
+		curr_pd, length, orig_buf_len,
+		rx_ch->channel.actual_len, rx_ch->length);
+
+	if (rx_ch->channel.actual_len >= rx_ch->length ||
+		     length < orig_buf_len) {
+
+#ifdef CONFIG_ARCH_TI81XX
+		struct musb_hw_ep *ep;
+		u8 isoc, next_seg = 0;
+
+		/* Workaround for early rx completion of
+		 * cppi41 dma in Generic RNDIS mode for ti81xx
+		 */
+		if (cpu_is_ti81xx() && is_host_enabled(cppi->musb)) {
+			u32 pkt_size = rx_ch->pkt_size;
+			ep = cppi->musb->endpoints + ep_num;
+			isoc = musb_readb(ep->regs, MUSB_RXTYPE);
+			isoc = (isoc >> 4) & 0x1;
+
+			if (!isoc
+				&& (rx_ch->dma_mode == USB_GENERIC_RNDIS_MODE)
+				&& (rx_ch->channel.actual_len < rx_ch->length)
+				&& !(rx_ch->channel.actual_len % pkt_size))
+					next_seg = 1;
+		}
+		if (next_seg) {
+			rx_ch->curr_offset = rx_ch->channel.actual_len;
+			cppi41_next_rx_segment(rx_ch);
+		} else
+#endif
+		{
+			rx_ch->channel.status = MUSB_DMA_STATUS_FREE;
+
+			if (rx_ch->inf_mode) {
+				cppi41_rx_ch_set_maxbufcnt(
+				&rx_ch->dma_ch_obj, 0);
+				rx_ch->inf_mode = 0;
+			}
+
+			/* Rx completion routine callback */
+			musb_dma_completion(cppi->musb, ep_num, 0);
 		}
+	} else {
+			if ((rx_ch->length - rx_ch->curr_offset) > 0)
+				cppi41_next_rx_segment(rx_ch);
+	}
+}
+
+static void rxdma_completion_work(struct work_struct *data)
+{
+	struct cppi41 *cppi = container_of(data, struct cppi41, rxdma_work);
+	struct musb *musb = cppi->musb;
+	unsigned index;
+	u8 resched = 0;
+	unsigned long flags, length;
+	struct cppi41_channel *rx_ch;
+
+	while (1) {
+		for (index = 0; index < USB_CPPI41_NUM_CH; index++) {
+			rx_ch = &cppi->rx_cppi_ch[index];
+			if (rx_ch->rx_complete) {
+				/* Sometimes a EP can unregister from a DMA
+				 * channel while the data is still in the FIFO.
+				 * Probable reason a proper abort was not
+				 * called before taking such a step.
+				 */
+				if (!rx_ch->curr_pd) {
+					ERR("invalid curr_pd chnum%d\n", index);
+					continue;
+				}
+
+				length = rx_ch->curr_pd->hw_desc.desc_info &
+						CPPI41_PKT_LEN_MASK;
+				if (length == 0) {
+					resched = 1;
+					continue;
+				}
+
+				/* reset length when handle zlp recived */
+				if (rx_ch->curr_pd->hw_desc.pkt_info
+					& CPPI41_ZLP) {
+					rx_ch->curr_pd->hw_desc.desc_info &=
+							~CPPI41_PKT_LEN_MASK;
+				}
+
+				spin_lock_irqsave(&musb->lock, flags);
+				usb_process_rx_bd(cppi, rx_ch->curr_pd);
+				rx_ch->rx_complete = 0;
+				rx_ch->count = 0;
+				rx_ch->curr_pd = 0;
+				spin_unlock_irqrestore(&musb->lock, flags);
+			}
+		}
+
+		if (resched) {
+			resched = 0;
+			cond_resched();
+		} else
+			return ;
 	}
 }
 
@@ -1443,7 +1710,6 @@
 	struct cppi41_queue_obj rx_queue_obj;
 	unsigned long pd_addr;
 	struct usb_cppi41_info *cppi_info = cppi->cppi_info;
-	u8 en_bd_intr = cppi->en_bd_intr;
 
 	if (cppi41_queue_init(&rx_queue_obj, cppi_info->q_mgr,
 			      cppi_info->rx_comp_q[index])) {
@@ -1455,7 +1721,7 @@
 		struct usb_pkt_desc *curr_pd;
 		struct cppi41_channel *rx_ch;
 		u8 ch_num, ep_num;
-		u32 length = 0, orig_buf_len, timeout = 50;
+		u32 length = 0, timeout = 50;
 
 		curr_pd = usb_get_pd_ptr(cppi, pd_addr);
 		if (curr_pd == NULL) {
@@ -1476,79 +1742,26 @@
 			udelay(1);
 		}
 
-		if (length == 0)
-			ERR("!Race condtion: rxBD read before updated by dma");
-
 		/* Extract the data from received packet descriptor */
 		ch_num = curr_pd->ch_num;
 		ep_num = curr_pd->ep_num;
-
-		DBG(4, "Rx complete: dma channel(%d) ep%d len %d timeout %d\n",
-			ch_num, ep_num, length, (50-timeout));
-
 		rx_ch = &cppi->rx_cppi_ch[ch_num];
-		rx_ch->channel.actual_len += length;
 
-		if (curr_pd->eop) {
-			curr_pd->eop = 0;
-			/* disable the rx dma schedular */
-			if (is_peripheral_active(cppi->musb) && !cppi->inf_mode)
-				cppi41_schedtbl_remove_dma_ch(0, 0, ch_num, 0);
+		if (length == 0) {
+			DBG(4, "!Race condtion: rxBD still not updated, poll"
+				"rxBD update ch%d ep%d\n", ch_num, ep_num);
+			rx_ch->rx_complete = 1;
+			rx_ch->count = 1;
+			rx_ch->curr_pd = curr_pd;
+			schedule_work(&cppi->rxdma_work);
+			continue;
 		}
 
-		/*
-		 * Return Rx PD to the software list --
-		 * this is protected by critical section
-		 */
-		usb_put_free_pd(cppi, curr_pd);
-
-		orig_buf_len = curr_pd->hw_desc.orig_buf_len;
-		if (en_bd_intr)
-			orig_buf_len &= ~CPPI41_PKT_INTR_FLAG;
+		/* reset length when handle zlp recived */
+		if (curr_pd->hw_desc.pkt_info & CPPI41_ZLP)
+			curr_pd->hw_desc.desc_info &= ~CPPI41_PKT_LEN_MASK;
 
-		if (unlikely(rx_ch->channel.actual_len >= rx_ch->length ||
-			     length < orig_buf_len)) {
-
-#ifdef CONFIG_ARCH_TI81XX
-			struct musb_hw_ep *ep;
-			u8 isoc, next_seg = 0;
-
-			/* Workaround for early rx completion of
-			 * cppi41 dma in Generic RNDIS mode for ti81xx
-			 */
-			if (cpu_is_ti81xx() && is_host_enabled(cppi->musb)) {
-				u32 pkt_size = rx_ch->pkt_size;
-				ep = cppi->musb->endpoints + ep_num;
-				isoc = musb_readb(ep->regs, MUSB_RXTYPE);
-				isoc = (isoc >> 4) & 0x1;
-
-				if (!isoc
-				&& (rx_ch->dma_mode == USB_GENERIC_RNDIS_MODE)
-				&& (rx_ch->channel.actual_len < rx_ch->length)
-				&& !(rx_ch->channel.actual_len % pkt_size))
-					next_seg = 1;
-			}
-			if (next_seg) {
-				rx_ch->curr_offset = rx_ch->channel.actual_len;
-				cppi41_next_rx_segment(rx_ch);
-			} else
-#endif
-			{
-				rx_ch->channel.status = MUSB_DMA_STATUS_FREE;
-
-				if (rx_ch->inf_mode) {
-					cppi41_rx_ch_set_maxbufcnt(
-					&rx_ch->dma_ch_obj, 0);
-					rx_ch->inf_mode = 0;
-				}
-				/* Rx completion routine callback */
-				musb_dma_completion(cppi->musb, ep_num, 0);
-			}
-		} else {
-			if (is_peripheral_active(cppi->musb) &&
-				((rx_ch->length - rx_ch->curr_offset) > 0))
-				cppi41_next_rx_segment(rx_ch);
-		}
+		usb_process_rx_bd(cppi, curr_pd);
 	}
 }
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41_dma.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41_dma.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/cppi41_dma.h	2014-08-07 11:51:55.754748536 -0600
@@ -21,6 +21,33 @@
 #define _CPPI41_DMA_H_
 #include <plat/usb.h>
 
+/* USBSS RTL versions */
+#define USBSS_RTL_VERSION_MASK	0xF
+#define USBSS_RTL_VERSION_D	0xD
+
+/* Configuration */
+#define USB_CPPI41_DESC_SIZE_SHIFT 6
+#define USB_CPPI41_DESC_ALIGN	(1 << USB_CPPI41_DESC_SIZE_SHIFT)
+#define USB_CPPI41_CH_NUM_PD	128	/* 4K bulk data at full speed */
+#define USB_CPPI41_MAX_PD	(USB_CPPI41_CH_NUM_PD * (USB_CPPI41_NUM_CH+1))
+
+/*
+ * USB Packet Descriptor
+ */
+struct usb_pkt_desc;
+
+struct usb_pkt_desc {
+	/* Hardware descriptor fields from this point */
+	struct cppi41_host_pkt_desc hw_desc;	/* 40 bytes */
+	/* Protocol specific data */
+	dma_addr_t dma_addr;			/* offs:44 byte */
+	struct usb_pkt_desc *next_pd_ptr;	/* offs:48 byte*/
+	u8 ch_num;
+	u8 ep_num;
+	u8 eop;
+	u8 res1;				/* offs:52 */
+	u8 res2[12];				/* offs:64 */
+};
 /**
  * struct usb_cppi41_info - CPPI 4.1 USB implementation details
  * @dma_block:	DMA block number
@@ -40,6 +67,12 @@
 	u16 *tx_comp_q;
 	u16 *rx_comp_q;
 	u8 bd_intr_ctrl;
+	u8 rx_dma_mode;
+	u8 rx_inf_mode;
+	u32 version;
+	u32 numdesc;
+	dma_addr_t desc_vaddr;
+	dma_addr_t desc_paddr;
 };
 
 extern struct usb_cppi41_info usb_cppi41_info[];
@@ -56,5 +89,7 @@
  * cppi41_handle_txfifo_intr - Handles tx fifo empty interupts
  * @musb:	the controller
  */
-void cppi41_handle_txfifo_intr(struct musb *musb);
+void cppi41_handle_txfifo_intr(struct musb *musb, u16 usbintr);
+void txfifoempty_int_enable(struct musb *musb, u8 ep_num);
+void txfifoempty_int_disable(struct musb *musb, u8 ep_num);
 #endif	/* _CPPI41_DMA_H_ */
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_core.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_core.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_core.c	2014-08-07 11:51:55.758748536 -0600
@@ -171,10 +171,10 @@
 }
 
 static inline u8 __musb_readb(const void __iomem *addr, unsigned offset)
-	{ return __raw_readb(addr + offset); }
+	{ return readb(addr + offset); }
 
 static inline void __musb_writeb(void __iomem *addr, unsigned offset, u8 data)
-	{ __raw_writeb(data, addr + offset); }
+	{ writeb(data, addr + offset); }
 
 static int musb_ulpi_read(struct otg_transceiver *otg, u32 offset)
 {
@@ -1084,7 +1084,7 @@
  */
 
 /* mode 0 - fits in 2KB */
-static struct musb_fifo_cfg __devinitdata mode_0_cfg[] = {
+static struct musb_fifo_cfg mode_0_cfg[] = {
 { .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
 { .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },
 { .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, },
@@ -1093,7 +1093,7 @@
 };
 
 /* mode 1 - fits in 4KB */
-static struct musb_fifo_cfg __devinitdata mode_1_cfg[] = {
+static struct musb_fifo_cfg mode_1_cfg[] = {
 { .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
 { .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
 { .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, .mode = BUF_DOUBLE, },
@@ -1102,7 +1102,7 @@
 };
 
 /* mode 2 - fits in 4KB */
-static struct musb_fifo_cfg __devinitdata mode_2_cfg[] = {
+static struct musb_fifo_cfg mode_2_cfg[] = {
 { .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
 { .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },
 { .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
@@ -1112,7 +1112,7 @@
 };
 
 /* mode 3 - fits in 4KB */
-static struct musb_fifo_cfg __devinitdata mode_3_cfg[] = {
+static struct musb_fifo_cfg mode_3_cfg[] = {
 { .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
 { .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
 { .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
@@ -1122,7 +1122,7 @@
 };
 
 /* mode 4 - fits in 16KB */
-static struct musb_fifo_cfg __devinitdata mode_4_cfg[] = {
+static struct musb_fifo_cfg mode_4_cfg[] = {
 { .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512,},
 { .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512,},
 { .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512,},
@@ -1154,7 +1154,7 @@
 
 
 /* mode 5 - fits in 8KB */
-static struct musb_fifo_cfg __devinitdata mode_5_cfg[] = {
+static struct musb_fifo_cfg mode_5_cfg[] = {
 { .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, },
 { .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, },
 { .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, },
@@ -1185,7 +1185,7 @@
 };
 
 /* mode 6 - fits in 32KB */
-static struct musb_fifo_cfg __devinitdata mode_6_cfg[] = {
+static struct musb_fifo_cfg mode_6_cfg[] = {
 { .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE,},
 { .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE,},
 { .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE,},
@@ -1294,11 +1294,11 @@
 	return offset + (maxpacket << ((c_size & MUSB_FIFOSZ_DPB) ? 1 : 0));
 }
 
-static struct musb_fifo_cfg __devinitdata ep0_cfg = {
+static struct musb_fifo_cfg ep0_cfg = {
 	.style = FIFO_RXTX, .maxpacket = 64,
 };
 
-static int __devinit ep_config_from_table(struct musb *musb)
+int ep_config_from_table(struct musb *musb)
 {
 	const struct musb_fifo_cfg	*cfg;
 	unsigned		i, n;
@@ -1391,7 +1391,7 @@
 
 	return 0;
 }
-
+EXPORT_SYMBOL(ep_config_from_table);
 
 /*
  * ep_config_from_hw - when MUSB_C_DYNFIFO_DEF is false
@@ -1580,6 +1580,12 @@
 	return 0;
 }
 
+void musb_reinit(u16 musb_type, struct musb *musb)
+{
+	musb_core_init(musb_type ? MUSB_CONTROLLER_MHDRC
+			: MUSB_CONTROLLER_HDRC, musb);
+}
+EXPORT_SYMBOL(musb_reinit);
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430) || \
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_core.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_core.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_core.h	2014-08-07 11:51:55.758748536 -0600
@@ -277,6 +277,9 @@
 		void __iomem *);
 	void (*dma_controller_destroy)(struct dma_controller *);
 	int (*simulate_babble_intr)(struct musb *musb);
+	void (*txfifoempty_intr_enable)(struct musb *musb, u8 ep_num);
+	void (*txfifoempty_intr_disable)(struct musb *musb, u8 ep_num);
+	void (*reinit)(u16 musb_type, struct musb *musb);
 };
 
 /*
@@ -329,6 +332,8 @@
 	struct musb_ep		ep_in;			/* TX */
 	struct musb_ep		ep_out;			/* RX */
 #endif
+	u8			xfer_type;
+	u8			prev_toggle;		/* Rx */
 };
 
 static inline struct usb_request *next_in_request(struct musb_hw_ep *hw_ep)
@@ -521,6 +526,8 @@
 #endif
 	short			fifo_mode;
 	u8			txfifo_intr_enable;
+	u8			is_overcurrent;
+	u8			datatog_fix;
 };
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
@@ -616,6 +623,18 @@
 extern void musb_restore_context(struct musb *musb);
 extern void musb_save_context(struct musb *musb);
 
+static inline void txfifoempty_int_enable(struct musb *musb, u8 ep_num)
+{
+	if (musb->ops->txfifoempty_intr_enable)
+		musb->ops->txfifoempty_intr_enable(musb, ep_num);
+}
+
+static inline void txfifoempty_int_disable(struct musb *musb, u8 ep_num)
+{
+	if (musb->ops->txfifoempty_intr_disable)
+		musb->ops->txfifoempty_intr_disable(musb, ep_num);
+}
+
 static inline void musb_platform_set_vbus(struct musb *musb, int is_on)
 {
 	if (musb->ops->set_vbus)
@@ -706,6 +725,7 @@
 		return "?dma?";
 #endif
 }
+extern void musb_reinit(u16 musb_type, struct musb *musb);
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 extern void musb_gb_work(struct work_struct *data);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_gadget.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_gadget.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_gadget.c	2014-08-07 11:51:55.758748536 -0600
@@ -891,6 +891,7 @@
 		goto fail;
 	}
 	musb_ep->type = usb_endpoint_type(desc);
+	hw_ep->xfer_type = musb_ep->type;
 
 	/* check direction and (later) maxpacket size against endpoint */
 	if (usb_endpoint_num(desc) != epnum)
@@ -1841,24 +1842,42 @@
 }
 EXPORT_SYMBOL(usb_gadget_probe_driver);
 
-int num_composite_drv;
+u8 gadget_free_ids[MAX_MUSB_INSTANCE];
+
 int get_gadget_drv_id(void)
 {
 	int id;
-	if (num_composite_drv >= MAX_MUSB_INSTANCE)
+
+	for (id = 0; id < MAX_MUSB_INSTANCE; ++id) {
+		if (!gadget_free_ids[id]) {
+			gadget_free_ids[id] = 1;
+			break;
+		}
+	}
+
+	if (id >= MAX_MUSB_INSTANCE) {
+		DBG(8, "no free gadget_id available\n");
 		return -EINVAL;
-	id = num_composite_drv;
-	num_composite_drv++;
+	}
+
+	DBG(8, "gadget_free_ids[%d, %d], allocated_id %d\n", id,
+		gadget_free_ids[0], gadget_free_ids[1]);
+
 	return id;
 }
 EXPORT_SYMBOL(get_gadget_drv_id);
 
-int put_gadget_drv_id(void)
+int put_gadget_drv_id(int id)
 {
-	if (num_composite_drv <= 0)
+	if (id >= MAX_MUSB_INSTANCE)
 		return -EINVAL;
-	num_composite_drv--;
-	return num_composite_drv;
+
+	gadget_free_ids[id] = 0;
+
+	DBG(8, "gadget_free_ids[%d, %d], free-id %d\n", gadget_free_ids[0],
+		gadget_free_ids[1], id);
+
+	return 0;
 }
 EXPORT_SYMBOL(put_gadget_drv_id);
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_host.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_host.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_host.c	2014-08-07 11:51:55.758748536 -0600
@@ -132,25 +132,22 @@
 {
 	void __iomem	*epio = ep->regs;
 	u16		csr;
-	u16		lastcsr = 0;
 	int		retries = 1000;
 
 	csr = musb_readw(epio, MUSB_TXCSR);
-	while (csr & MUSB_TXCSR_FIFONOTEMPTY) {
-		if (csr != lastcsr)
+	while (csr & MUSB_TXCSR_TXPKTRDY) {
+		if (!(csr & MUSB_TXCSR_FIFONOTEMPTY))
+			return ;
+		else
 			DBG(3, "Host TX FIFONOTEMPTY csr: %02x\n", csr);
-		lastcsr = csr;
-		csr = MUSB_TXCSR_FLUSHFIFO;
+		csr |= MUSB_TXCSR_FLUSHFIFO;
 		musb_writew(epio, MUSB_TXCSR, csr);
 		csr = musb_readw(epio, MUSB_TXCSR);
-		if (!(csr & MUSB_TXCSR_FIFONOTEMPTY))
-			break;
 		if (retries-- < 1) {
 			DBG(3, "Warning!!!...Could not flush host TX%d"
 				" fifo: csr: %04x\n", ep->epnum, csr);
 			return;
 		}
-		mdelay(1);
 	}
 }
 
@@ -245,6 +242,7 @@
 	/* initialize software qh state */
 	qh->offset = 0;
 	qh->segsize = 0;
+	hw_ep->xfer_type = qh->type;
 
 	/* gather right source of data */
 	switch (qh->type) {
@@ -278,6 +276,7 @@
 			}; s; }),
 			epnum, buf + offset, len);
 
+
 	/* Configure endpoint */
 	musb_ep_set_qh(hw_ep, is_in, qh);
 	musb_ep_program(musb, epnum, urb, !is_in, buf, offset, len);
@@ -357,18 +356,39 @@
 static inline void musb_save_toggle(struct musb_qh *qh, int is_in,
 				    struct urb *urb)
 {
+	struct musb		*musb = qh->hw_ep->musb;
 	void __iomem		*epio = qh->hw_ep->regs;
 	u16			csr;
+	u8			curr_toggle;
 
 	/*
 	 * FIXME: the current Mentor DMA code seems to have
 	 * problems getting toggle correct.
 	 */
 
-	if (is_in)
+	if (is_in) {
 		csr = musb_readw(epio, MUSB_RXCSR) & MUSB_RXCSR_H_DATATOGGLE;
-	else
+		if (musb->datatog_fix) {
+			curr_toggle = csr ? 1 : 0;
+
+			/* check if data toggle has gone out of sync */
+			if (is_dma_capable() && qh->hw_ep->rx_channel &&
+					curr_toggle == qh->hw_ep->prev_toggle) {
+				dev_dbg(musb->controller,
+					"Data toggle same as previous (=%d) on ep%d\n",
+						curr_toggle, qh->hw_ep->epnum);
+
+				csr = musb_readw(epio, MUSB_RXCSR);
+				csr |= MUSB_RXCSR_H_DATATOGGLE |
+						MUSB_RXCSR_H_WR_DATATOGGLE;
+				musb_writew(epio, MUSB_RXCSR, csr);
+
+				csr = 1;
+		}
+		}
+	} else {
 		csr = musb_readw(epio, MUSB_TXCSR) & MUSB_TXCSR_H_DATATOGGLE;
+	}
 
 	usb_settoggle(urb->dev, qh->epnum, !is_in, csr ? 1 : 0);
 }
@@ -463,7 +483,14 @@
 		}
 	}
 
-	if (qh != NULL && qh->is_ready) {
+	/* we should not start next urb when current urb
+	 * has failed, this is because stack will unlink/dequeue
+	 * remaining urbs. Programming the next urb will endup in
+	 * urb completion because of expected error (cause of current
+	 * urb failure) interrupts and interfere with urb dequeue
+	 * initiated by stack and cause a crash.
+	 */
+	if (status == 0 && qh != NULL && qh->is_ready) {
 		DBG(4, "... next ep%d %cX urb %p\n",
 		    hw_ep->epnum, is_in ? 'R' : 'T', next_urb(qh));
 		musb_start_urb(musb, is_in, qh);
@@ -482,7 +509,8 @@
 	 * ignore dma (various models),
 	 * leave toggle alone (may not have been saved yet)
 	 */
-	csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;
+	if (csr & MUSB_RXCSR_RXPKTRDY)
+		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;
 	csr &= ~(MUSB_RXCSR_H_REQPKT
 		| MUSB_RXCSR_H_AUTOREQ
 		| MUSB_RXCSR_AUTOCLEAR);
@@ -707,7 +735,8 @@
 	 */
 	wmb();
 
-	if (!dma->channel_program(channel, pkt_size, mode,
+	if (!dma->channel_program(channel, pkt_size |
+			(qh->hb_mult << 11), mode,
 			urb->transfer_dma + offset, length)) {
 		dma->channel_release(channel);
 		hw_ep->tx_channel = NULL;
@@ -717,6 +746,7 @@
 		musb_writew(epio, MUSB_TXCSR, csr | MUSB_TXCSR_H_WZC_BITS);
 		return false;
 	}
+
 	return true;
 }
 
@@ -736,6 +766,8 @@
 	void __iomem		*epio = hw_ep->regs;
 	struct musb_qh		*qh = musb_ep_get_qh(hw_ep, !is_out);
 	u16			packet_sz = qh->maxpacket;
+	u8			use_dma = 1;
+	u16			csr;
 
 	DBG(3, "%s hw%d urb %p spd%d dev%d ep%d%s "
 				"h_addr%02x h_port%02x bytes %d\n",
@@ -747,9 +779,17 @@
 
 	musb_ep_select(musb, mbase, epnum);
 
+	if (is_out && !len) {
+		use_dma = 0;
+		csr = musb_readw(epio, MUSB_TXCSR);
+		csr &= ~MUSB_TXCSR_DMAENAB;
+		musb_writew(epio, MUSB_TXCSR, csr);
+		hw_ep->tx_channel = NULL;
+	}
+
 	/* candidate for DMA? */
 	dma_controller = musb->dma_controller;
-	if (is_dma_capable() && epnum && dma_controller) {
+	if (use_dma && is_dma_capable() && epnum && dma_controller) {
 		dma_channel = is_out ? hw_ep->tx_channel : hw_ep->rx_channel;
 		if (!dma_channel) {
 			dma_channel = dma_controller->channel_alloc(
@@ -831,7 +871,7 @@
 						packet_sz) - 1) << 11);
 			else
 				musb_writew(epio, MUSB_TXMAXP,
-					packet_sz);
+					qh->maxpacket | (qh->hb_mult << 11));
 			musb_writeb(epio, MUSB_TXINTERVAL, qh->intv_reg);
 		} else {
 			musb_writeb(epio, MUSB_NAKLIMIT0, qh->intv_reg);
@@ -902,11 +942,21 @@
 				csr = musb_readw(hw_ep->regs,
 						MUSB_RXCSR);
 
+				if (musb->datatog_fix) {
+					/*
+					 * Save the datatoggle value which can
+					 * be compared later to see if data
+					 * toggle goes out of sync
+					 */
+					hw_ep->prev_toggle = (csr &
+					MUSB_RXCSR_H_DATATOGGLE) ? 1 : 0;
+				}
+
 				/* unless caller treats short rx transfers as
 				 * errors, we dare not queue multiple transfers.
 				 */
 				dma_ok = dma_controller->channel_program(
-						dma_channel, packet_sz,
+						dma_channel, packet_sz | (qh->hb_mult << 11),
 						!(urb->transfer_flags
 							& URB_SHORT_NOT_OK),
 						urb->transfer_dma + offset,
@@ -1661,7 +1711,7 @@
 			/* even if there was an error, we did the dma
 			 * for iso_frame_desc->length
 			 */
-			if (d->status != EILSEQ && d->status != -EOVERFLOW)
+			if (d->status != -EILSEQ && d->status != -EOVERFLOW)
 				d->status = 0;
 
 			if (++qh->iso_idx >= urb->number_of_packets)
@@ -1680,7 +1730,8 @@
 				length =
 					urb->iso_frame_desc[qh->iso_idx].length;
 
-				ret = c->channel_program(dma, qh->maxpacket,
+				ret = c->channel_program(dma, qh->maxpacket |
+						(qh->hb_mult << 11),
 						0, (u32) buf, length);
 				done = false;
 			} else {
@@ -1825,7 +1876,7 @@
 			 * adjusted first...
 			 */
 			ret = c->channel_program(
-				dma, qh->maxpacket,
+				dma, qh->maxpacket | ((qh->hb_mult - 1) << 11),
 				dma->desired_mode, buf, length);
 
 			if (!ret) {
@@ -1849,8 +1900,19 @@
 	urb->actual_length += xfer_len;
 	qh->offset += xfer_len;
 	if (done) {
-		if (urb->status == -EINPROGRESS)
-			urb->status = status;
+		if (urb->status == -EINPROGRESS) {
+			/* If short packet is not expected any transfer length
+			 * less than actual length is an error, hence
+			 * set urb status to -EREMOTEIO
+			 */
+			if ((urb->status == -EINPROGRESS)
+				&& (urb->transfer_flags & URB_SHORT_NOT_OK)
+				&& (urb->actual_length
+					< urb->transfer_buffer_length))
+				urb->status = -EREMOTEIO;
+			else
+				urb->status = status;
+		}
 		musb_advance_schedule(musb, urb, hw_ep, USB_DIR_IN);
 	}
 }
@@ -2194,7 +2256,7 @@
 	}
 
 	/* turn off DMA requests, discard state, stop polling ... */
-	if (is_in) {
+	if (is_in && ep->epnum) {
 		/* giveback saves bulk toggle */
 		csr = musb_h_flush_rxfifo(ep, 0);
 
@@ -2279,8 +2341,13 @@
 			list_del(&qh->ring);
 			kfree(qh);
 		}
-	} else
+	} else {
+		/* As this urb is dequeued by stack/application
+		 * we return this urb with ECANCELED status
+		 */
+		urb->status = -ECANCELED;
 		ret = musb_cleanup_urb(urb, qh);
+	}
 done:
 	spin_unlock_irqrestore(&musb->lock, flags);
 	return ret;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_io.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_io.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_io.h	2014-08-07 11:51:55.758748536 -0600
@@ -61,17 +61,17 @@
 /* NOTE:  these offsets are all in bytes */
 
 static inline u16 musb_readw(const void __iomem *addr, unsigned offset)
-	{ return __raw_readw(addr + offset); }
+	{ return readw(addr + offset); }
 
 static inline u32 musb_readl(const void __iomem *addr, unsigned offset)
-	{ return __raw_readl(addr + offset); }
+	{ return readl(addr + offset); }
 
 
 static inline void musb_writew(void __iomem *addr, unsigned offset, u16 data)
-	{ __raw_writew(data, addr + offset); }
+	{ writew(data, addr + offset); }
 
 static inline void musb_writel(void __iomem *addr, unsigned offset, u32 data)
-	{ __raw_writel(data, addr + offset); }
+	{ writel(data, addr + offset); }
 
 #else
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_procfs.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_procfs.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_procfs.c	2014-08-07 11:51:55.758748536 -0600
@@ -535,7 +535,7 @@
 			"\n",
 			musb_readl(musb->ctrl_base, DAVINCI_USB_CTRL_REG),
 			musb_readl(musb->ctrl_base, DAVINCI_USB_STAT_REG),
-			__raw_readl((void __force __iomem *)
+			readl((void __force __iomem *)
 					IO_ADDRESS(USBPHY_CTL_PADDR)),
 			musb_readl(musb->ctrl_base, DAVINCI_RNDIS_REG),
 			musb_readl(musb->ctrl_base, DAVINCI_AUTOREQ_REG),
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_virthub.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_virthub.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/musb_virthub.c	2014-08-07 11:51:55.758748536 -0600
@@ -358,8 +358,12 @@
 			 * initialization logic, e.g. for OTG, or change any
 			 * logic relating to VBUS power-up.
 			 */
-			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
-				musb_start(musb);
+			if (!(is_otg_enabled(musb) && hcd->self.is_b_host)) {
+				if (musb->is_overcurrent)
+					musb->is_overcurrent = 0;
+				else
+					musb_start(musb);
+			}
 			break;
 		case USB_PORT_FEAT_RESET:
 			musb_port_reset(musb, true);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/ti81xx.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/ti81xx.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/ti81xx.c	2014-08-07 11:51:55.758748536 -0600
@@ -39,6 +39,11 @@
 #include "musb_core.h"
 #include "cppi41_dma.h"
 
+#define BABBLE_WORKAROUND_1 0
+#define BABBLE_WORKAROUND_2 1
+
+#define BABBLE_WORKAROUND (BABBLE_WORKAROUND_2)
+
 struct ti81xx_glue {
 	struct device *dev;
 	struct clk *ick;		/* common usbss interface clk */
@@ -52,6 +57,7 @@
 static u8 usbss_init_done;
 struct musb *gmusb[2];
 u8 usbid_sw_ctrl;
+u8 phyctrl_enable, usbphy_rxcalib_enable;
 #undef USB_TI81XX_DEBUG
 
 #ifdef USB_TI81XX_DEBUG
@@ -74,14 +80,14 @@
 {
 	if (!usbss_init_done)
 		return 0;
-	return __raw_readl(usbss_virt_base + offset);
+	return readl(usbss_virt_base + offset);
 }
 
 static inline void usbss_write(u32 offset, u32 data)
 {
 	if (!usbss_init_done)
 		return ;
-	__raw_writel(data, usbss_virt_base + offset);
+	writel(data, usbss_virt_base + offset);
 }
 
 static void usbotg_ss_init(void)
@@ -91,6 +97,10 @@
 		usbss_write(USBSS_SYSCONFIG,
 			usbss_read(USBSS_SYSCONFIG) | USB_SOFT_RESET_MASK);
 
+		/* some customer faced kernel crashes without
+		 * providing this delay when Soc running at 1Ghz
+		 */
+		udelay(1);
 		/* clear any USBSS interrupts */
 		usbss_write(USBSS_IRQ_EOI, 0);
 		usbss_write(USBSS_IRQ_STATUS, usbss_read(USBSS_IRQ_STATUS));
@@ -162,7 +172,7 @@
 	u32 tmp;
 	u16 val;
 
-	tmp = __raw_readl(addr + (offset & ~3));
+	tmp = readl(addr + (offset & ~3));
 
 	switch (offset & 0x3) {
 	case 0:
@@ -182,7 +192,7 @@
 
 void ti81xx_musb_writew(void __iomem *addr, unsigned offset, u16 data)
 {
-	__raw_writew(data, addr + offset);
+	writew(data, addr + offset);
 }
 
 u8 ti81xx_musb_readb(const void __iomem *addr, unsigned offset)
@@ -190,7 +200,7 @@
 	u32 tmp;
 	u8 val;
 
-	tmp = __raw_readl(addr + (offset & ~3));
+	tmp = readl(addr + (offset & ~3));
 
 	switch (offset & 0x3) {
 	case 0:
@@ -211,7 +221,7 @@
 }
 void ti81xx_musb_writeb(void __iomem *addr, unsigned offset, u8 data)
 {
-	__raw_writeb(data, addr + offset);
+	writeb(data, addr + offset);
 }
 
 #ifdef CONFIG_USB_TI_CPPI41_DMA
@@ -411,6 +421,7 @@
 	struct usb_cppi41_info *cppi_info = &usb_cppi41_info[id];
 	u16 numch, blknum, order;
 	u32 i;
+	void *ptr;
 
 	/* init cppi info structure  */
 	cppi_info->dma_block = 0;
@@ -423,6 +434,7 @@
 	cppi_info->tx_comp_q = id ? tx_comp_q1 : tx_comp_q;
 	cppi_info->rx_comp_q = id ? rx_comp_q1 : rx_comp_q;
 	cppi_info->bd_intr_ctrl = 1;
+	cppi_info->version = usbss_read(USBSS_REVISION);
 
 	if (cppi41_init_done)
 		return 0;
@@ -469,6 +481,42 @@
 	cppi41_dma_block_init(blknum, cppi_info->q_mgr, order,
 			dma_sched_table, numch);
 
+	cppi41_dma_block[0].numdesc = USB_CPPI41_MAX_PD * num_instances;
+	cppi41_dma_block[0].desc_totsize = cppi41_dma_block[0].numdesc
+						* sizeof(struct usb_pkt_desc);
+	ptr = dma_alloc_coherent(NULL, cppi41_dma_block[0].desc_totsize,
+				&cppi41_dma_block[0].desc_paddr,
+				GFP_KERNEL | GFP_DMA);
+
+	if (!ptr) {
+		ERR("cppi41 init failed: unable to alloc desc memory\n");
+		return -ENOMEM;
+	}
+	cppi41_dma_block[0].desc_vaddr = ptr;
+
+	if (cppi41_mem_rgn_alloc(cppi_info->q_mgr,
+				 cppi41_dma_block[0].desc_paddr,
+				 USB_CPPI41_DESC_SIZE_SHIFT,
+				 get_count_order(cppi41_dma_block[0].numdesc),
+				 &cppi41_dma_block[0].mem_rgn)) {
+		DBG(1, "ERROR: queue manager memory region allocation "
+		    "failed\n");
+		dma_free_coherent(NULL,
+				cppi41_dma_block[0].desc_totsize,
+				cppi41_dma_block[0].desc_vaddr,
+				cppi41_dma_block[0].desc_paddr);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_instances; ++i) {
+		cppi_info = &usb_cppi41_info[i];
+		cppi_info->numdesc = USB_CPPI41_MAX_PD;
+		cppi_info->desc_vaddr = (u32)cppi41_dma_block[0].desc_vaddr +
+			i * USB_CPPI41_MAX_PD * sizeof(struct usb_pkt_desc);
+		cppi_info->desc_paddr = cppi41_dma_block[0].desc_paddr +
+			i * USB_CPPI41_MAX_PD * sizeof(struct usb_pkt_desc);
+	}
+
 	/* attach to the IRQ */
 	if (request_irq(irq, cppi41dma_Interrupt, 0, "cppi41_dma", 0))
 		printk(KERN_INFO "request_irq %d failed!\n", irq);
@@ -503,6 +551,11 @@
 	order = get_count_order(numch);
 	blknum = cppi_info->dma_block;
 
+	dma_free_coherent(NULL,
+			cppi41_dma_block[0].desc_totsize,
+			cppi41_dma_block[0].desc_vaddr,
+			cppi41_dma_block[0].desc_paddr);
+	cppi41_mem_rgn_free(0, cppi41_dma_block[0].mem_rgn);
 	cppi41_dma_block_uninit(blknum, cppi_info->q_mgr, order,
 			dma_sched_table, numch);
 	cppi41_queue_mgr_uninit(cppi_info->q_mgr);
@@ -523,7 +576,6 @@
 	cppi41_dma_sched_tbl_init(0, 0, dma_sched_table, 30);
 	return 0;
 }
-#endif /* CONFIG_USB_TI_CPPI41_DMA */
 
 /*
  * Because we don't set CTRL.UINT, it's "important" to:
@@ -532,6 +584,32 @@
  *	- use INTSET/INTCLR instead.
  */
 
+void txfifoempty_intr_enable(struct musb *musb, u8 ep_num)
+{
+	void __iomem *reg_base = musb->ctrl_base;
+	u32 coremask;
+
+	if (musb->txfifo_intr_enable) {
+		coremask = musb_readl(reg_base, USB_CORE_INTR_SET_REG);
+		coremask |= (1 << (ep_num + 16));
+		musb_writel(reg_base, USB_CORE_INTR_SET_REG, coremask);
+		DBG(1, "enable txF intr ep%d coremask %x\n", ep_num, coremask);
+	}
+}
+
+void txfifoempty_intr_disable(struct musb *musb, u8 ep_num)
+{
+	void __iomem *reg_base = musb->ctrl_base;
+	u32 coremask;
+
+	if (musb->txfifo_intr_enable) {
+		coremask = (1 << (ep_num + 16));
+		musb_writel(reg_base, USB_CORE_INTR_CLEAR_REG, coremask);
+	}
+}
+
+#endif /* CONFIG_USB_TI_CPPI41_DMA */
+
 /**
  * ti81xx_musb_enable - enable interrupts
  */
@@ -545,10 +623,6 @@
 	       ((musb->epmask & USB_RX_EP_MASK) << USB_INTR_RX_SHIFT);
 	coremask = (0x01ff << USB_INTR_USB_SHIFT);
 
-	/* TX endpoint Empty FIFO interrupts */
-	if (musb->txfifo_intr_enable)
-		coremask |= (0xffff << 16);
-
 	coremask &= ~MUSB_INTR_SOF;
 
 	musb_writel(reg_base, USB_EP_INTR_SET_REG, epmask);
@@ -786,10 +860,14 @@
 
 	/* Reset the controller */
 	musb_writel(reg_base, USB_CTRL_REG, USB_SOFT_RESET_MASK);
-	udelay(100);
+	while ((musb_readl(reg_base, USB_CTRL_REG) & 0x1))
+		cpu_relax();
 
 	/* Shutdown the on-chip PHY and its PLL. */
-	if (data->set_phy_power)
+	/* do not shut down the phy if rxcalib is enabled
+	 * performing rxcalibration second time does not work
+	 */
+	if (phyctrl_enable && data->set_phy_power)
 		data->set_phy_power(musb->id, 0);
 	udelay(100);
 
@@ -804,9 +882,8 @@
 		data->set_phy_power(musb->id, 1);
 	mdelay(100);
 
-	/* save the usbotgss register contents */
-	musb_platform_enable(musb);
-
+	if (musb->ops->reinit)
+		musb->ops->reinit(plat->config->multipoint, musb);
 	musb_start(musb);
 }
 
@@ -854,11 +931,13 @@
 
 	if (musb->txfifo_intr_enable && (usbintr & USB_INTR_TXFIFO_MASK)) {
 #ifdef CONFIG_USB_TI_CPPI41_DMA
-		cppi41_handle_txfifo_intr(musb);
+		DBG(1, "Isr:TxfifoIntr %x\n", usbintr >> USB_INTR_TXFIFO_EMPTY);
+		cppi41_handle_txfifo_intr(musb,
+				usbintr >> USB_INTR_TXFIFO_EMPTY);
 		ret = IRQ_HANDLED;
-		goto eoi;
 #endif
 	}
+	usbintr &= ~USB_INTR_TXFIFO_MASK;
 	/*
 	 * DRVVBUS IRQs are the only proxy we have (a very poor one!) for
 	 * AM3517's missing ID change IRQ.  We need an ID change IRQ to
@@ -876,12 +955,15 @@
 
 	if (is_babble) {
 		if (musb->enable_babble_work)
-			musb->int_usb |= MUSB_INTR_DISCONNECT;
+			musb->int_usb = MUSB_INTR_DISCONNECT;
 
 		ERR("CAUTION: musb%d: Babble Interrupt Occured\n", musb->id);
 		ERR("Please issue long reset to make usb functional !!\n");
 	}
 
+	if (is_host_enabled(musb) && musb->int_usb & MUSB_INTR_VBUSERROR)
+		musb->is_overcurrent = 1;
+
 	if (usbintr & (USB_INTR_DRVVBUS << USB_INTR_USB_SHIFT)) {
 		int drvvbus = musb_readl(reg_base, USB_STAT_REG);
 		void __iomem *mregs = musb->mregs;
@@ -1016,6 +1098,142 @@
 	return 0;
 }
 
+#define USBPHY_RX_CALIB			1
+#define USB2PHY_RXCALIB_REG_OFFS	0x304
+#define USB2PHY_RXCALIB_DONE		(1 << 22)
+#define USB2PHY_SQ_CAL_DONE		(1 << 1)
+#define USB2PHY_DAC3_OFFS		3
+#define USB2PHY_DAC2_OFFS		9
+#define USB2PHY_DAC1_OFFS		15
+#define USB2PHY_DAC1_EN_OFFS		21
+#define USB2PHY_DAC2_EN_OFFS		14
+#define USB2PHY_DAC3_EN_OFFS		8
+void usb2phy_config(struct musb *musb, u8 config, u8 config_option)
+{
+	u32 regs_offset, val, sign, rx_calib, timeout = 0xfffff;
+	u8 dac1, dac2, dac3;
+
+	switch (config)	{
+	case USBPHY_RX_CALIB:
+
+		regs_offset = USB2PHY_RXCALIB_REG_OFFS;
+		/* wait till rx_calib and squeltch calib done bit become true */
+		do {
+			val = musb_readl(musb->ctrl_base, regs_offset);
+			udelay(5);
+		} while (timeout-- && !((val & USB2PHY_RXCALIB_DONE)
+			&& (val & USB2PHY_SQ_CAL_DONE)));
+
+		DBG(4, "default rxcalib regval %08x\n", val);
+
+		if (!((val & USB2PHY_RXCALIB_DONE) &&
+			(val & USB2PHY_SQ_CAL_DONE))) {
+			ERR("usb2phy rxcalibration failed\n");
+			return ;
+		}
+
+		sign = (val >> 29) & 1;
+		rx_calib = (val >> 24) & 0x1F;
+		DBG(4, "musb(%d) sign %d current RXcalib %d\n", musb->id,
+				sign, rx_calib);
+
+		dac3 = (val >> USB2PHY_DAC3_OFFS) & 0x1F;
+		dac2 = (val >> USB2PHY_DAC2_OFFS) & 0x1F;
+		dac1 = (val >> USB2PHY_DAC1_OFFS) & 0x3F;
+		DBG(4, "initial value of DAC3 (%x) DAC2(%x) DAC1(%x)\n", dac3,
+				dac2, dac1);
+
+		/* add code of 2 for dac3/dac2 */
+		dac3 += 2;
+		if (dac3 > 0x1F)
+			dac3 = 0x1F;
+
+		dac2 += 2;
+		if (dac2 > 0x1F)
+			dac2 = 0x1F;
+		/* Always reduce the threshold by 15 codes (~15mV
+		 * If sign bit is .1., add 0xf to the magnitude bits
+		 * new_mag = old_mag + 0xf;
+		 * It will increase threshold in -ve direction
+		 * If sign bit is .0. and magnitude >= 0xf;
+		 * new_mag = old_mag . 0xf It will decrease threshold
+		 * If sign bit is .0. and magnitude < 0xf;
+		 * make sign bit = .1., new_mag = 0xf old_mag
+		 */
+		if (sign) {
+			if (rx_calib > 16)
+				rx_calib -= 15;
+			else
+				rx_calib += 15;
+		} else {
+			if (rx_calib >= 15)
+				rx_calib -= 15;
+			else {
+				sign = 1;
+				rx_calib = 15 - rx_calib;
+			}
+		}
+
+		pr_info("usb2phy: computed values rxcalib(%d)"
+			"DACs(%d %d %d)\n", rx_calib, dac1, dac2, dac3);
+
+		switch (config_option) {
+
+		case 1:
+			/* the new computed values are not working
+			 * causing interop issues with specifc mouse
+			 * hence over-riding the new computed
+			 * values of rxcalib register.
+			 */
+			rx_calib = 7;
+			dac1 = 14;
+			dac2 = 12;
+			dac3 = 15;
+			break;
+
+		case 2:
+			dac1 = 14;
+			dac2 = dac2 - 1;
+			dac3++;
+			break;
+			/* use new computed values */
+		default:
+			break;
+		}
+
+		pr_info("usb2phy: override computed values rxcalib(%d)"
+				"DACs(%d %d %d)\n", rx_calib, dac1, dac2, dac3);
+
+		val &= ~(0x3F << 24);
+		val |= ((rx_calib << 24) | (sign << 29) | (1 << 30));
+
+		/* override all DAC values */
+		val &= ~((0x1F << USB2PHY_DAC3_OFFS)
+			| (0x1F << USB2PHY_DAC2_OFFS)
+			| (0x3F << USB2PHY_DAC1_OFFS));
+		val |= ((dac3 << USB2PHY_DAC3_OFFS)
+			| (dac2 << USB2PHY_DAC2_OFFS)
+			| (dac1 << USB2PHY_DAC1_OFFS));
+		val |= ((1 << USB2PHY_DAC3_EN_OFFS)
+			| (1 << USB2PHY_DAC2_EN_OFFS)
+			| (1 << USB2PHY_DAC1_EN_OFFS));
+
+		DBG(4, "musb(%d) sign(%d) rxcalib(%d) dac3(%x) dac2(%x) "
+			"written val %x\n", musb->id, sign, rx_calib,
+			dac3, dac2, val);
+		musb_writel(musb->ctrl_base, regs_offset, val);
+		mdelay(1);
+		val = musb_readl(musb->ctrl_base, regs_offset);
+		pr_info("%s: musb(%d) rxcalib done, rxcalib read value %x\n",
+			__func__, musb->id, val);
+
+	break;
+
+	default:
+		break;
+	}
+}
+
 int ti81xx_musb_init(struct musb *musb)
 {
 	void __iomem *reg_base = musb->ctrl_base;
@@ -1058,6 +1276,12 @@
 	if (data->set_phy_power)
 		data->set_phy_power(musb->id, 1);
 
+	if (usbphy_rxcalib_enable) {
+		usb2phy_config(musb, USBPHY_RX_CALIB, 0);
+		data->usbphy_rxcalib_enable = 0;
+		data->phyctrl_enable = 0;
+	}
+
 	musb->a_wait_bcon = A_WAIT_BCON_TIMEOUT;
 	musb->isr = ti81xx_interrupt;
 
@@ -1096,20 +1320,17 @@
 	musb_platform_set_mode(musb, mode);
 
 #ifdef CONFIG_USB_TI_CPPI41_DMA
-	if (cpu_is_ti81xx() && ((omap_rev() == TI8168_REV_ES2_0) ||
-		(omap_rev() == TI8148_REV_ES2_0))) {
-
-		/* Enabling txfifo intr features, is not working
-		 * reliablely, hence disable txfifo intr logic
-		 */
-		musb->txfifo_intr_enable = 0;
+	/* TxFifo empty interrupt logic is supported
+	 * only for isochronous tranfers only
+	 */
+	musb->txfifo_intr_enable = data->txfifo_intr_enable;
 
-	}
 	if (musb->txfifo_intr_enable)
 		printk(KERN_DEBUG "TxFifo Empty intr enabled\n");
 	else
 		printk(KERN_DEBUG "TxFifo Empty intr disabled\n");
 #endif
+
 	/* enable babble workaround */
 	INIT_WORK(&musb->work, evm_deferred_musb_restart);
 	musb->enable_babble_work = data->babble_ctrl;
@@ -1118,6 +1339,7 @@
 		musb->enable_babble_work = 0;
 	}
 
+	musb->enable_babble_work = BABBLE_WORKAROUND;
 	musb_writel(reg_base, USB_IRQ_EOI, 0);
 
 	return 0;
@@ -1163,7 +1385,7 @@
 		del_timer_sync(&musb->otg_workaround);
 
 	/* Shutdown the on-chip PHY and its PLL. */
-	if (data->set_phy_power)
+	if (phyctrl_enable && data->set_phy_power)
 		data->set_phy_power(musb->id, 0);
 
 	otg_put_transceiver(musb->xceiv);
@@ -1190,6 +1412,11 @@
 	.dma_controller_create	= cppi41_dma_controller_create,
 	.dma_controller_destroy	= cppi41_dma_controller_destroy,
 	.simulate_babble_intr	= musb_simulate_babble,
+#ifdef CONFIG_USB_TI_CPPI41_DMA
+	.txfifoempty_intr_enable = txfifoempty_intr_enable,
+	.txfifoempty_intr_disable = txfifoempty_intr_disable,
+#endif
+	.reinit = musb_reinit,
 };
 
 static void __devexit ti81xx_delete_musb_pdev(struct ti81xx_glue *glue, u8 id)
@@ -1339,11 +1566,13 @@
 	usbotg_ss_init();
 
 	/* clear any USBSS interrupts */
-	__raw_writel(0, glue->mem_va + USBSS_IRQ_EOI);
-	__raw_writel(__raw_readl(glue->mem_va + USBSS_IRQ_STATUS),
+	writel(0, glue->mem_va + USBSS_IRQ_EOI);
+	writel(readl(glue->mem_va + USBSS_IRQ_STATUS),
 					glue->mem_va + USBSS_IRQ_STATUS);
 
 	/* create the child platform device for mulitple instances of musb */
+	usbphy_rxcalib_enable = data->usbphy_rxcalib_enable;
+	phyctrl_enable = data->phyctrl_enable;
 	for (i = 0; i <= data->instances; ++i) {
 #ifdef CONFIG_USB_TI_CPPI41_DMA
 		/* initialize the cppi41dma init */
@@ -1405,8 +1634,8 @@
 
 	/* Shutdown the on-chip PHY and its PLL. */
 	for (i = 0; i <= data->instances; ++i) {
-		if (data->set_phy_power)
-			data->set_phy_power(0, i);
+		if (phyctrl_enable && data->set_phy_power)
+			data->set_phy_power(i, 0);
 	}
 
 	/* disable the common usbss interface clock */
@@ -1424,7 +1653,7 @@
 	/* Start the on-chip PHY and its PLL. */
 	for (i = 0; i <= data->instances; ++i) {
 		if (data->set_phy_power)
-			data->set_phy_power(1, i);
+			data->set_phy_power(i, 1);
 	}
 
 	/* enable the common usbss interface clock */
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/ti81xx.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/ti81xx.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/musb/ti81xx.h	2014-08-07 11:51:55.758748536 -0600
@@ -121,6 +121,8 @@
 #define USB_INTR_USB_SHIFT      0
 #define USB_INTR_USB_MASK       (0x1ff << USB_INTR_USB_SHIFT) /* 8 Mentor */
 #define USB_INTR_TXFIFO_MASK     (0xffff << 16)
+#define USB_INTR_TXFIFO_EMPTY	17
+
 				/* interrupts and DRVVBUS interrupt */
 #define USB_INTR_DRVVBUS        0x100
 #define USB_INTR_RX_SHIFT       16
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/storage/usb.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/usb/storage/usb.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/usb/storage/usb.c	2014-08-07 11:51:55.762748536 -0600
@@ -797,6 +797,8 @@
 	 */
 	scsi_lock(host);
 	set_bit(US_FLIDX_DISCONNECTING, &us->dflags);
+	/* stop the current urbs when the device got disconnected */
+	usb_stor_stop_transport(us);
 	scsi_unlock(host);
 	wake_up(&us->delay_wait);
 }
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/sii9022a/sii9022a_drv.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/sii9022a/sii9022a_drv.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/sii9022a/sii9022a_drv.c	2014-08-07 11:51:55.806748534 -0600
@@ -26,6 +26,7 @@
 #include <linux/i2c.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/sii9022a.h>
 #include "../vpss/display_interface.h"
 #include "sii9022a_drv.h"
 
@@ -70,7 +71,7 @@
 				void *data);
 
 static struct TI81xx_display_driver hdmi_driver = {
-	.display = TI81xx_DISPLAY_DVO2,
+	.display = TI81xx_DISPLAY_HDMI,
 	.enable	= sii9022a_panel_enable,
 	.disable = sii9022a_panel_disable,
 	.suspend = sii9022a_panel_suspend,
@@ -836,14 +837,17 @@
 	int r = 0;
 
 	struct hdmi_video_encoder_create_params  input_encoder_create_params;
+	struct sii9022a_platform_data *pdata;
 	u32 input_standard;
 
-	input_encoder_create_params.device_i2c_inst_id = 1;
-	input_encoder_create_params.device_i2c_addr = 0x39;
-	input_encoder_create_params.inp_clk = 0;
-	input_encoder_create_params.hdmi_hot_plug_gpio_intr_line = 0;
-	input_encoder_create_params.sync_mode = ENCODER_EXTERNAL_SYNC;
-	input_encoder_create_params.clk_edge = 0;
+	pdata = dev_get_platdata(&client->dev);
+	if (!pdata)
+		printk(KERN_ERR "Platform data not found\n");
+
+	input_encoder_create_params.hdmi_hot_plug_gpio_intr_line =
+				pdata->hdmi_hot_plug_gpio_intr_line;
+	input_encoder_create_params.sync_mode = pdata->sync_mode;
+	input_encoder_create_params.clk_edge = pdata->clk_edge;
 
 	input_standard = gsii9022a_obj.standard;
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xx_ram.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xx_ram.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xx_ram.c	2014-08-07 11:51:55.854748532 -0600
@@ -431,7 +431,7 @@
 	if (!size)
 		return;
 
-	size = PAGE_ALIGN(size);
+	size = ALIGN(size, SZ_2M);
 
 	if (paddr) {
 
@@ -458,7 +458,7 @@
 		}
 
 	} else
-		paddr = memblock_alloc(size, PAGE_SIZE);
+		paddr = memblock_alloc(size, SZ_2M);
 
 	memblock_free(paddr, size);
 	memblock_remove(paddr, size);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/Kconfig	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/Kconfig	2014-08-07 11:51:55.922748529 -0600
@@ -1,5 +1,15 @@
-config TI81XX_HDMI
+menuconfig TI81XX_HDMI
 	tristate "TI81XX HDMI Driver"
+	select TI81XX_VPSS
 	help
 		This option builds driver required for booting TI81XX HDMI
 		Use 'M' to build as module.
+
+config TI81XX_HDMI_HDCP
+	bool "Include HDCP support"
+	default n
+	depends on TI81XX_HDMI
+	---help---
+		Support for HDCP block of HDMI to be included. Ensure a device
+		capable of HDCP is being used, failing which the behaviour of
+		the driver is un-defined.
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/Makefile
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/Makefile	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/Makefile	2014-08-07 11:51:55.946748527 -0600
@@ -1,3 +1,3 @@
 
 obj-$(CONFIG_TI81XX_HDMI) += ti81xxhdmi.o
-ti81xxhdmi-y       := hdmi.o edid.o
\ No newline at end of file
+ti81xxhdmi-y       := hdmi.o edid.o hdcp.o
\ No newline at end of file
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/edid.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/edid.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/edid.c	2014-08-07 11:51:55.974748526 -0600
@@ -238,13 +238,8 @@
 	printk(KERN_DEBUG "%x\n", i);
 	while (i < (0x80 + disp)) {
 		current_byte = edid[i];
-		/* printk(KERN_INFO "i = %x cur_byte = %x (cur_byte & EX_DATABLOCK_TAG_MASK) = %d\n",
-			i, current_byte,
-			(current_byte & HDMI_EDID_EX_DATABLOCK_TAG_MASK)); */
 		if ((current_byte >> 5)	== datablock) {
 			*offset = i;
-			/* printk(KERN_INFO "datablock %d %d\n",
-							datablock, *offset); */
 			return 0;
 		} else {
 			length = (current_byte &
@@ -271,7 +266,7 @@
 		else
 			format->length = length;
 
-		for (j = 1 ; j < length ; j++) {
+		for (j = 1 ; j <= format->length ; j++) {
 			current_byte = edid[offset+j];
 			format->fmt[j-1].code = current_byte & 0x7F;
 			format->fmt[j-1].pref = current_byte & 0x80;
@@ -282,7 +277,7 @@
 
 __u32 hdmi_get_audio_format(__u8 *edid, struct audio_format *format)
 {
-	int offset, current_byte, j = 0, length = 0;
+	int offset, current_byte, i, j = 0, length = 0;
 	enum extension_edid_db vsdb =  DATABLOCK_AUDIO;
 
 	format->length = 0;
@@ -292,17 +287,30 @@
 		current_byte = edid[offset];
 		length = current_byte & HDMI_EDID_EX_DATABLOCK_LEN_MASK;
 
-		if (length >= HDMI_AUDIO_FORMAT_MAX_LENGTH)
-			format->length = HDMI_AUDIO_FORMAT_MAX_LENGTH;
+		if (length >= HDMI_AUDIO_FORMAT_MAX_LENGTH * 3)
+			format->length = HDMI_AUDIO_FORMAT_MAX_LENGTH * 3;
 		else
 			format->length = length;
 
-		for (j = 1 ; j < length ; j++) {
+		i = 0;
+		for (j = 1 ; j <= format->length ; j++) {
 			if (j%3 == 1) {
 				current_byte = edid[offset + j];
-				format->fmt[j-1].format = current_byte & 0x78;
-				format->fmt[j-1].num_of_ch =
+				format->fmt[i].format =
+						(current_byte & 0x78) >> 3;
+				format->fmt[i].num_of_ch =
 						(current_byte & 0x07) + 1;
+			} else if (j%3 == 2) {
+				/* Get the Frequency -
+					CEA861 - PG 154 - Table 84 / 34 */
+				current_byte = edid[offset + j];
+				format->fmt[i].freq = current_byte;
+			} else if (j%3 == 0) {
+				/* Get the Bit Rate -
+					CEA861 - PG 154 - Table 84 / 34 */
+				current_byte = edid[offset + j];
+				format->fmt[i].width = current_byte & 0x7;
+				i++;
 			}
 		}
 	}
@@ -348,13 +356,12 @@
 
 __u32 hdmi_tv_yuv_supported(__u8 *edid)
 {
-	if (edid[0x7e] != 0x00 && edid[0x83] & 0x30) {
-		printk(KERN_INFO "YUV supported");
-		return 1;
-	}
+	if (edid[0x7e] != 0x00)
+		return (edid[0x83] & 0x30) >> 4;
 	return 0;
 }
-bool hdmi_tv_hdmi_supported(__u8 *edid)
+
+_Bool hdmi_tv_hdmi_supported(__u8 *edid)
 {
 	/*check with TV suppport HDMI or not
 	if no externsion block, HDMI is not supported*/
@@ -388,7 +395,7 @@
 
 }
 
-bool hdmi_tv_cec_get_pa(__u8 *edid, __u8 *pa)
+_Bool hdmi_tv_cec_get_pa(__u8 *edid, __u8 *pa)
 {
 	/*check with TV suppport HDMI or not
 	if no externsion block, HDMI is not supported*/
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/hdcp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/hdcp.c	2014-08-07 11:51:55.974748526 -0600
@@ -0,0 +1,884 @@
+/*
+ * hdcp.c
+ *
+ * HDCP interface DSS driver setting for TI's OMAP4 family of processor.
+ * Copyright (C) 2010-2011 Texas Instruments Incorporated - http://www.ti.com/
+ * Authors: Fabrice Olivero
+ *	Fabrice Olivero <f-olivero@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Rev history:
+ * Sujith Shivalingapps <sujith.s@ti.com>	Updated to include support for
+ *	DM81xx. HDCP functionality is part of HDMI character driver,
+ *	Was an independent character driver.
+ * Sujith Shivalingappa <sujith.s>@ti.com>	Customized to TI81XX platform.
+ */
+
+/* TODO FIX ME Sujith - memory leak in hdmi_lib.c hdmi_lib_init - mem allocated
+	for omap is not released - if silicon is ne/ce - Done - fixed -
+	raise an IR.
+
+	Memory leak in hdmi_init - If mem alloc fails for second alloc
+	first allocated memory is not released - Done - fixed - raise an IR.
+
+	When we have AKSV errors, we require to stop HDMI transmitter and
+	re-start autentication. Require to update the user guide for same.
+
+	Move verification of BKSV to applications (walk the revocation list).
+	Driver checks for syntax error of BKSV but not the revocation list.
+
+*/
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/completion.h>
+#include <linux/miscdevice.h>
+#include <linux/firmware.h>
+#include <linux/ti81xxhdmi.h>
+#include <plat/hdmi_lib.h>
+#include <plat/hdcp_ddc.h>
+#include <plat/hdcp_lib.h>
+#include "../vpss/display_interface.h"
+
+#include "hdcp.h"
+#include "hdmi.h"
+
+#ifdef PRINT_DEBUG_MSG
+#define HDCP_DBG(format, ...) \
+	printk(KERN_INFO "HDCP: " format, ## __VA_ARGS__)
+#else
+
+#define HDCP_DBG(format, ...)
+
+#endif
+
+#ifdef PRINT_STATE_TRANS_MSG
+#define HDCP_STT_DBG(format, ...) \
+	printk(KERN_INFO "HDCP: " format, ## __VA_ARGS__)
+#else
+
+#define HDCP_STT_DBG(format, ...)
+
+#endif
+
+struct hdcp hdcp;
+
+/* Stores data that would be used to autenticate a repeater */
+static struct hdcp_sha_in sha_input;
+
+/* State machine / workqueue */
+static void hdcp_wq_start_authentication(void);
+static void hdcp_wq_check_r0(void);
+static void hdcp_wq_step2_authentication(void);
+static void hdcp_wq_authentication_failure(void);
+static void hdcp_work_queue(struct work_struct *work);
+static struct delayed_work *hdcp_submit_work(int event, int delay);
+static void hdcp_cancel_work(struct delayed_work **work);
+static void hdcp_wq_disable(void);
+
+/* Callbacks */
+static void hdcp_start_frame_cb(void);
+static void hdcp_irq_cb(int hpd_low);
+
+/* Control functions */
+static long hdcp_enable_ctl(void __user *argp);
+static long hdcp_disable_ctl(void);
+static long hdcp_query_status_ctl(void __user *argp);
+static long hdcp_wait_event_ctl(void __user *argp);
+static long hdcp_done_ctl(void __user *argp);
+
+static DECLARE_WAIT_QUEUE_HEAD(hdcp_up_wait_queue);
+static DECLARE_WAIT_QUEUE_HEAD(hdcp_down_wait_queue);
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_user_space_task
+ *-----------------------------------------------------------------------------
+ */
+int hdcp_user_space_task(int flags)
+{
+	int ret;
+
+	HDCP_DBG("Wait for user space task %x\n", flags);
+	hdcp.hdcp_up_event = flags & 0xFF;
+	hdcp.hdcp_down_event = flags & 0xFF;
+	wake_up_interruptible(&hdcp_up_wait_queue);
+	wait_event_interruptible(hdcp_down_wait_queue,
+				(hdcp.hdcp_down_event & 0xFF) == 0);
+	ret = (hdcp.hdcp_down_event & 0xFF00) >> 8;
+
+	HDCP_DBG("User space task done %x\n", hdcp.hdcp_down_event);
+	hdcp.hdcp_down_event = 0;
+
+	return ret;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_disable
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_disable(void)
+{
+	HDCP_STT_DBG( "HDCP: disabled\n");
+
+	hdcp_cancel_work(&hdcp.pending_wq_event);
+	hdcp_lib_disable();
+	hdcp_lib_clear_pending_disable();
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_start_authentication
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_start_authentication(void)
+{
+	int status = HDCP_OK;
+
+	hdcp.hdcp_state = HDCP_AUTHENTICATION_START;
+
+	HDCP_STT_DBG( "HDCP: authentication start\n");
+
+	/* Step 1 part 1 (until R0 calc delay) */
+	status = hdcp_lib_step1_start();
+
+	if (status == -HDCP_AKSV_ERROR) {
+		hdcp_wq_authentication_failure();
+	} else if (status == -HDCP_CANCELLED_AUTH) {
+		HDCP_DBG("Authentication step 1 cancelled.");
+		return;
+	} else if (status != HDCP_OK) {
+		hdcp_wq_authentication_failure();
+	} else {
+		hdcp.hdcp_state = HDCP_WAIT_R0_DELAY;
+		hdcp.auth_state = HDCP_STATE_AUTH_1ST_STEP;
+		hdcp.pending_wq_event = hdcp_submit_work(HDCP_R0_EXP_EVENT,
+							 HDCP_R0_DELAY);
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_check_r0
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_check_r0(void)
+{
+	int status;
+
+	memset(hdcp.metadata, 0, 8);
+	status = hdcp_lib_step1_r0_check(hdcp.metadata);
+
+	if (status == -HDCP_CANCELLED_AUTH) {
+		HDCP_DBG("Authentication step 1/R0 cancelled.");
+		return;
+	} else if (status < 0)
+		hdcp_wq_authentication_failure();
+	else {
+		if (hdcp_lib_check_repeater_bit_in_tx()) {
+			/* Repeater */
+			HDCP_STT_DBG( "HDCP: authentication step 1 "
+					 "successful - Repeater\n");
+
+			hdcp.hdcp_state = HDCP_WAIT_KSV_LIST;
+			hdcp.auth_state = HDCP_STATE_AUTH_2ND_STEP;
+
+			hdcp.pending_wq_event =
+				hdcp_submit_work(HDCP_KSV_TIMEOUT_EVENT,
+						 HDCP_KSV_TIMEOUT_DELAY);
+		} else {
+			/* Receiver */
+			HDCP_STT_DBG( "HDCP: authentication step 1 "
+					 "successful - Receiver\n");
+
+			hdcp.hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
+			hdcp.auth_state = HDCP_STATE_AUTH_3RD_STEP;
+
+			/* Restore retry counter */
+			if (hdcp.en_ctrl.nb_retry == -1)
+				hdcp.retry_cnt = HDCP_INFINITE_REAUTH;
+			else
+				hdcp.retry_cnt = hdcp.en_ctrl.nb_retry;
+		}
+
+		memset(sha_input.data, 0, 5);
+		hdcp_lib_read_bksv(sha_input.data);
+		sha_input.byte_counter = 5;
+
+		status = hdcp_user_space_task(TI81XXHDMI_HDCP_EVENT_STEP1);
+		if (status) {
+			printk(KERN_ERR "HDCP: BKSV error %d\n", status);
+			hdcp_wq_authentication_failure();
+		}
+	}
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_step2_authentication
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_step2_authentication(void)
+{
+	int status = HDCP_OK;
+	int i;
+
+	/* KSV list timeout is running and should be canceled */
+	hdcp_cancel_work(&hdcp.pending_wq_event);
+
+	status = hdcp_lib_step2();
+
+	if (status == HDCP_OK){
+		status = hdcp_lib_get_sha_data(&sha_input);
+	}
+
+	if (status == HDCP_OK){
+		/* Add the meta data */
+		for (i = 0; i < 8; i++)
+			sha_input.data[sha_input.byte_counter++] =
+				hdcp.metadata[i];
+
+		/* Wait for user space, to confirm */
+		status = hdcp_user_space_task(TI81XXHDMI_HDCP_EVENT_STEP2);
+		if (status) {
+			printk(KERN_ERR "HDCP: CHECH_V error %d\n", status);
+		}
+		if (status == HDCP_OK) {
+			/* Re-enable Ri check */
+#ifdef _9032_AUTO_RI_
+			hdcp_lib_auto_ri_check(true);
+#endif
+		}
+	}
+
+	if (status == -HDCP_CANCELLED_AUTH) {
+		HDCP_DBG("Authentication step 2 cancelled.");
+		return;
+	} else if ((status == 0xFF) || (status == -HDCP_AUTH_FAILURE))
+		hdcp_wq_authentication_failure();
+	else {
+		HDCP_STT_DBG( "HDCP: (Repeater) authentication step 2 "
+				 "successful\n");
+
+		hdcp.hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
+		hdcp.auth_state = HDCP_STATE_AUTH_3RD_STEP;
+
+		/* Restore retry counter */
+		if (hdcp.en_ctrl.nb_retry == -1)
+			hdcp.retry_cnt = HDCP_INFINITE_REAUTH;
+		else
+			hdcp.retry_cnt = hdcp.en_ctrl.nb_retry;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_authentication_failure
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_authentication_failure(void)
+{
+	if (hdcp.hdmi_state == HDMI_STOPPED) {
+		hdcp.auth_state = HDCP_STATE_AUTH_FAILURE;
+		return;
+	}
+
+	hdcp_lib_auto_ri_check(false);
+	hdcp_lib_auto_bcaps_rdy_check(false);
+	hdcp_lib_set_av_mute(AV_MUTE_SET);
+	hdcp_lib_set_encryption(HDCP_ENC_OFF);
+
+	hdcp_cancel_work(&hdcp.pending_wq_event);
+
+	hdcp_lib_disable();
+	hdcp_lib_clear_pending_disable();
+
+	if (hdcp.retry_cnt && (hdcp.hdmi_state != HDMI_STOPPED)) {
+		if (hdcp.retry_cnt < HDCP_INFINITE_REAUTH) {
+			hdcp.retry_cnt--;
+			HDCP_STT_DBG( "HDCP: authentication failed - "
+					"retrying, attempts=%d\n",
+					hdcp.retry_cnt);
+		} else
+			HDCP_STT_DBG( "HDCP: authentication failed - "
+					 "retrying\n");
+
+		hdcp.hdcp_state = HDCP_AUTHENTICATION_START;
+		hdcp.auth_state = HDCP_STATE_AUTH_FAIL_RESTARTING;
+
+		hdcp.pending_wq_event = hdcp_submit_work(HDCP_AUTH_REATT_EVENT,
+							 HDCP_REAUTH_DELAY);
+	} else {
+		HDCP_STT_DBG("HDCP: authentication failed - "
+				"HDCP disabled\n");
+		hdcp.hdcp_state = HDCP_ENABLE_PENDING;
+		hdcp.auth_state = HDCP_STATE_AUTH_FAILURE;
+		/* Notify user space exit */
+		hdcp_user_space_task(TI81XXHDMI_HDCP_EVENT_EXIT);
+	}
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_work_queue
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_work_queue(struct work_struct *work)
+{
+	struct hdcp_delayed_work *hdcp_w =
+		container_of(work, struct hdcp_delayed_work, work.work);
+	int event = hdcp_w->event;
+
+	mutex_lock(&hdcp.lock);
+
+	HDCP_DBG("hdcp_work_queue() - START - %u hdmi=%d hdcp=%d auth=%d"
+		" evt= %x %d hdcp_ctrl=%02x",
+		jiffies_to_msecs(jiffies),
+		hdcp.hdmi_state,
+		hdcp.hdcp_state,
+		hdcp.auth_state,
+		(event & 0xFF00) >> 8,
+		event & 0xFF,
+		RD_REG_32(hdcp.hdmi_wp_base_addr + HDMI_IP_CORE_SYSTEM,
+			HDMI_IP_CORE_SYSTEM__HDCP_CTRL));
+
+	/* Clear pending_wq_event
+	 * In case a delayed work is scheduled from the state machine
+	 * "pending_wq_event" is used to memorize pointer on the event to be
+	 * able to cancel any pending work in case HDCP is disabled
+	 */
+	if (event & HDCP_WORKQUEUE_SRC)
+		hdcp.pending_wq_event = 0;
+
+	/* First handle HDMI state */
+	if (event == HDCP_START_FRAME_EVENT) {
+		hdcp.pending_start = 0;
+		hdcp.hdmi_state = HDMI_STARTED;
+	}
+
+	/* Handle HDCP disable (from any state) */
+	if ((event == HDCP_DISABLE_CTL) ||
+	    (event == HDCP_HPD_LOW_EVENT)) {
+		if (hdcp.hdcp_state != HDCP_DISABLED) {
+			if (hdcp.hdcp_state != HDCP_ENABLE_PENDING)
+				hdcp_wq_disable();
+
+			if (event == HDCP_DISABLE_CTL) {
+				hdcp.hdcp_state = HDCP_DISABLED;
+				/* Notify user space exit */
+				hdcp_user_space_task(TI81XXHDMI_HDCP_EVENT_EXIT);
+			}
+			else
+				hdcp.hdcp_state = HDCP_ENABLE_PENDING;
+
+			hdcp.auth_state = HDCP_STATE_DISABLED;
+		}
+
+		hdcp_lib_clear_pending_disable();
+	}
+
+	if (hdcp.hpd_low) {
+		hdcp.hpd_low = 0;
+		if (event & HDCP_WORKQUEUE_SRC)
+			goto exit_wq;
+	}
+
+	/**********************/
+	/* HDCP state machine */
+	/**********************/
+	switch (hdcp.hdcp_state) {
+
+	/* State */
+	/*********/
+	case HDCP_DISABLED:
+		/* HDCP enable control or re-authentication event */
+		if (event == HDCP_ENABLE_CTL) {
+			if (hdcp.en_ctrl.nb_retry == -1)
+				hdcp.retry_cnt = HDCP_INFINITE_REAUTH;
+			else
+				hdcp.retry_cnt = hdcp.en_ctrl.nb_retry;
+
+			if (hdcp.hdmi_state == HDMI_STARTED)
+				hdcp_wq_start_authentication();
+			else
+				hdcp.hdcp_state = HDCP_ENABLE_PENDING;
+			HDCP_DBG(KERN_INFO "DEBUG-STATE-MC: hdcp_state"
+				" - Disabled\n");
+			HDCP_DBG(KERN_INFO "DEBUG-STATE-MC: Event enabled\n");
+		} else {
+			HDCP_DBG(KERN_INFO "DEBUG-STATE-MC: hdcp_state"
+				" - Disabled\n");
+		}
+		break;
+
+	/* State */
+	/*********/
+	case HDCP_ENABLE_PENDING:
+		/* HDMI start frame event */
+		if (event == HDCP_START_FRAME_EVENT){
+			hdcp_wq_start_authentication();
+			HDCP_DBG(KERN_INFO "DEBUG-STATE-MC: hdcp_state - "
+				"HDCP Enable Pending - F start\n");
+		} else {
+			HDCP_DBG(KERN_INFO "DEBUG-STATE-MC: hdcp_state - "
+				"HDCP Enable Pending\n");
+		}
+		break;
+
+	/* State */
+	/*********/
+	case HDCP_AUTHENTICATION_START:
+		/* Re-authentication */
+		if (event == HDCP_AUTH_REATT_EVENT) {
+			hdcp_wq_start_authentication();
+			HDCP_DBG(KERN_INFO "DEBUG-STATE-MC: hdcp_state - "
+				"Auth start - restart attempt\n");
+		} else {
+			HDCP_DBG(KERN_INFO "DEBUG-STATE-MC: hdcp_state - "
+				"Auth start\n");
+		}
+		break;
+
+	/* State */
+	/*********/
+	case HDCP_WAIT_R0_DELAY:
+		/* R0 timer elapsed */
+		if (event == HDCP_R0_EXP_EVENT)
+			hdcp_wq_check_r0();
+
+		break;
+
+	/* State */
+	/*********/
+	case HDCP_WAIT_KSV_LIST:
+		/* Ri failure */
+		if (event == HDCP_RI_FAIL_EVENT) {
+			HDCP_STT_DBG( "HDCP: Ri check failure\n");
+
+			hdcp_wq_authentication_failure();
+		}
+		/* KSV list ready event */
+		else if (event == HDCP_KSV_LIST_RDY_EVENT)
+			hdcp_wq_step2_authentication();
+		/* Timeout */
+		else if (event == HDCP_KSV_TIMEOUT_EVENT) {
+			HDCP_STT_DBG( "HDCP: BCAPS polling timeout\n");
+			hdcp_wq_authentication_failure();
+		}
+		break;
+
+	/* State */
+	/*********/
+	case HDCP_LINK_INTEGRITY_CHECK:
+		/* Ri failure */
+		if (event == HDCP_RI_FAIL_EVENT) {
+			HDCP_STT_DBG( "HDCP: Ri check failure\n");
+			hdcp_wq_authentication_failure();
+		}
+		break;
+
+	default:
+		printk(KERN_WARNING "HDCP: error - unknow HDCP state\n");
+		break;
+	}
+
+exit_wq :
+	kfree(hdcp_w);
+	hdcp_w = 0;
+	if (event == HDCP_START_FRAME_EVENT){
+		hdcp.pending_start = 0;
+	}
+	if (event == HDCP_KSV_LIST_RDY_EVENT ||
+	    event == HDCP_R0_EXP_EVENT) {
+		hdcp.pending_wq_event = 0;
+	}
+
+	HDCP_DBG("hdcp_work_queue() - END - %u hdmi=%d hdcp=%d "
+		"auth=%d evt=%x %d ",
+		jiffies_to_msecs(jiffies),
+		hdcp.hdmi_state,
+		hdcp.hdcp_state,
+		hdcp.auth_state,
+		(event & 0xFF00) >> 8,
+		event & 0xFF);
+
+	mutex_unlock(&hdcp.lock);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_submit_work
+ *-----------------------------------------------------------------------------
+ */
+static struct delayed_work *hdcp_submit_work(int event, int delay)
+{
+	struct hdcp_delayed_work *work;
+
+	work = kmalloc(sizeof(struct hdcp_delayed_work), GFP_ATOMIC);
+
+	if (work) {
+		INIT_DELAYED_WORK(&work->work, hdcp_work_queue);
+		work->event = event;
+		queue_delayed_work(hdcp.workqueue,
+				   &work->work,
+				   msecs_to_jiffies(delay));
+	} else {
+		printk(KERN_WARNING "HDCP: Cannot allocate memory to "
+				    "create work\n");
+		return 0;
+	}
+
+	return &work->work;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_cancel_work
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_cancel_work(struct delayed_work **work)
+{
+	int ret = 0;
+
+	if (*work) {
+		ret = cancel_delayed_work(*work);
+		if (ret != 1) {
+			/* OK, the work was being executed
+			wait for it to finish */
+			ret = cancel_work_sync(&((*work)->work));
+		}
+		kfree(*work);
+		*work = 0;
+	}
+}
+
+
+/******************************************************************************
+ * HDCP callbacks
+ *****************************************************************************/
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_start_frame_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_start_frame_cb(void)
+{
+	HDCP_DBG("hdcp_start_frame_cb() %u", jiffies_to_msecs(jiffies));
+
+	/* Cancel any pending work */
+	if (hdcp.pending_start){
+		hdcp_cancel_work(&hdcp.pending_start);
+	}
+	if (hdcp.pending_wq_event){
+		hdcp_cancel_work(&hdcp.pending_wq_event);
+	}
+
+	hdcp.hpd_low = 0;
+	hdcp_lib_clear_pending_disable();
+	hdcp.retry_cnt = hdcp.en_ctrl.nb_retry;
+	hdcp.pending_start = hdcp_submit_work(HDCP_START_FRAME_EVENT,
+							HDCP_ENABLE_DELAY);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_irq_cb
+ *-----------------------------------------------------------------------------
+ */
+
+static void hdcp_irq_cb(int status)
+{
+	HDCP_DBG("hdcp_irq_cb() status=%x", status);
+
+	/* Disable auto Ri/BCAPS immediately */
+	if (((status & HDMI_RI_ERR) ||
+	    (status & HDMI_BCAP) ||
+	    (status & HDMI_HPD_LOW)) &&
+	    (hdcp.hdcp_state != HDCP_ENABLE_PENDING)) {
+		hdcp_lib_auto_ri_check(false);
+		hdcp_lib_auto_bcaps_rdy_check(false);
+	}
+
+	/* Work queue execution not required if HDCP is disabled */
+	/* TODO: ignore interrupts if they are masked (cannnot access UMASK
+	 * here so should use global variable
+	 */
+	if ((hdcp.hdcp_state != HDCP_DISABLED) &&
+	    (hdcp.hdcp_state != HDCP_ENABLE_PENDING)) {
+		if (status & HDMI_HPD_LOW) {
+			hdcp_lib_set_encryption(HDCP_ENC_OFF);
+		}
+
+		if (status & HDMI_RI_ERR) {
+			hdcp_lib_set_av_mute(AV_MUTE_SET);
+			hdcp_lib_set_encryption(HDCP_ENC_OFF);
+			hdcp_submit_work(HDCP_RI_FAIL_EVENT, 0);
+		}
+		/* RI error takes precedence over BCAP */
+		else if (status & HDMI_BCAP)
+			hdcp_submit_work(HDCP_KSV_LIST_RDY_EVENT, 0);
+	}
+
+	if (status & HDMI_HPD_LOW) {
+		hdcp_lib_set_pending_disable();	/* Used to exit on-going HDCP
+						* work */
+		hdcp.hpd_low = 0;		/* Used to cancel HDCP works */
+		hdcp_lib_disable();
+		hdcp.hdmi_state = HDMI_STOPPED;
+		hdcp.hdcp_state = HDCP_DISABLED;
+		hdcp.auth_state = HDCP_STATE_DISABLED;
+
+		/* Clear up any waits, if pending */
+		if (hdcp.hdcp_up_event != 0x0){
+			hdcp.hdcp_up_event = TI81XXHDMI_HDCP_EVENT_EXIT;
+			wake_up_interruptible(&hdcp_up_wait_queue);
+		}
+
+		if (hdcp.hdcp_down_event != 0x0){
+			hdcp.hdcp_down_event =
+				0x1100 | TI81XXHDMI_HDCP_EVENT_EXIT;
+			wake_up_interruptible(&hdcp_down_wait_queue);
+		}
+	}
+}
+
+/******************************************************************************
+ * HDCP control from ioctl
+ *****************************************************************************/
+
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_enable_ctl
+ *-----------------------------------------------------------------------------
+ */
+static long hdcp_enable_ctl(void __user *argp)
+{
+	HDCP_DBG("hdcp_ioctl() - ENABLE %u", jiffies_to_msecs(jiffies));
+
+	if (copy_from_user(&(hdcp.en_ctrl), argp,
+			   sizeof(struct ti81xxhdmi_hdcp_ena_ctrl))) {
+		printk(KERN_WARNING "HDCP: Error copying from user space "
+				    "- enable ioctl\n");
+		return -EFAULT;
+	}
+
+	/* Post event to workqueue */
+	if (hdcp_submit_work(HDCP_ENABLE_CTL, 0) == 0)
+		return -EFAULT;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_disable_ctl
+ *-----------------------------------------------------------------------------
+ */
+static long hdcp_disable_ctl(void)
+{
+	HDCP_DBG("hdcp_ioctl() - DISABLE %u", jiffies_to_msecs(jiffies));
+
+	hdcp_cancel_work(&hdcp.pending_start);
+	hdcp_cancel_work(&hdcp.pending_wq_event);
+
+	hdcp_lib_set_pending_disable();
+	/* Post event to workqueue */
+	if (hdcp_submit_work(HDCP_DISABLE_CTL, 0) == 0)
+		return -EFAULT;
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_query_status_ctl
+ *-----------------------------------------------------------------------------
+ */
+static long hdcp_query_status_ctl(void __user *argp)
+{
+	uint32_t *status = (uint32_t *)argp;
+
+	HDCP_DBG("hdcp_ioctl() - QUERY %u", jiffies_to_msecs(jiffies));
+
+	*status = hdcp.auth_state;
+
+	return 0;
+}
+
+static int hdcp_wait_re_entrance;
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wait_event_ctl
+ *-----------------------------------------------------------------------------
+ */
+static long hdcp_wait_event_ctl(void __user *argp)
+{
+	struct ti81xxhdmi_hdcp_wait_ctrl ctrl;
+
+	HDCP_DBG("hdcp_ioctl() - WAIT %u %d", jiffies_to_msecs(jiffies),
+					 hdcp.hdcp_up_event);
+
+	if (hdcp_wait_re_entrance == 0) {
+		if (((struct ti81xxhdmi_hdcp_wait_ctrl *)argp)->data == 0){
+			printk(KERN_WARNING "HDCP: Error copying from user "
+					"space - wait ioctl");
+			return -EFAULT;
+		}
+		if (copy_from_user(&ctrl, argp,
+				   sizeof(struct ti81xxhdmi_hdcp_wait_ctrl))) {
+			printk(KERN_WARNING "HDCP: Error copying from user "
+					"space - wait ioctl");
+			return -EFAULT;
+		}
+		hdcp_wait_re_entrance = 1;
+		wait_event_interruptible(hdcp_up_wait_queue,
+					 (hdcp.hdcp_up_event & 0xFF) != 0);
+
+		ctrl.event = hdcp.hdcp_up_event;
+
+		if ((ctrl.event & 0xFF) == TI81XXHDMI_HDCP_EVENT_STEP2 ||
+			(ctrl.event & 0xFF) == TI81XXHDMI_HDCP_EVENT_STEP1){
+			if (copy_to_user(ctrl.data, &sha_input,
+						sizeof(struct hdcp_sha_in))) {
+				printk(KERN_WARNING "HDCP: Error copying to "
+						    "user space - wait ioctl");
+				return -EFAULT;
+			}
+		}
+
+		hdcp.hdcp_up_event = 0;
+		hdcp_wait_re_entrance = 0;
+	} else {
+		printk(KERN_WARNING "HDCP Wait Q exited due to re-entrent\n");
+		ctrl.event = TI81XXHDMI_HDCP_EVENT_EXIT;
+	}
+	/* Store output data to output pointer */
+	if (copy_to_user(argp, &ctrl,
+			 sizeof(struct ti81xxhdmi_hdcp_wait_ctrl))) {
+		printk(KERN_WARNING "HDCP: Error copying to user space -"
+				    " wait ioctl");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_done_ctl
+ *-----------------------------------------------------------------------------
+ */
+static long hdcp_done_ctl(void __user *argp)
+{
+	uint32_t *status = (uint32_t *)argp;
+
+	HDCP_DBG("hdcp_ioctl() - DONE %u %d",
+		jiffies_to_msecs(jiffies), *status);
+
+	hdcp.hdcp_down_event &= ~(*status & 0xFF);
+	hdcp.hdcp_down_event |= *status & 0xFF00;
+
+	wake_up_interruptible(&hdcp_down_wait_queue);
+
+	return 0;
+}
+
+extern struct hdmi hdmi;
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_init
+ *-----------------------------------------------------------------------------
+ */
+int hdcp_init(void)
+{
+	HDCP_DBG("hdcp_init() %u", jiffies_to_msecs(jiffies));
+
+	/* Map HDMI WP address */
+	hdcp.hdmi_wp_base_addr = ioremap(TI81xx_HDMI_WP, 0x1000);
+
+	if (!hdcp.hdmi_wp_base_addr) {
+		printk(KERN_ERR "HDCP: HDMI WP IOremap error\n");
+		return -EFAULT;
+	}
+
+	mutex_init(&hdcp.lock);
+	mutex_lock(&hdcp.lock);
+
+	/* Variable init */
+	hdcp.en_ctrl.nb_retry  = 0;
+	hdcp.hdcp_state = HDCP_DISABLED;
+	hdcp.pending_start = 0;
+	hdcp.pending_wq_event = 0;
+	hdcp.retry_cnt = 0;
+	hdcp.auth_state = HDCP_STATE_DISABLED;
+	hdcp_lib_clear_pending_disable();
+	hdcp.hdcp_up_event = 0;
+	hdcp.hdcp_down_event = 0;
+	hdcp.hpd_low = 0;
+	hdcp_wait_re_entrance = 0;
+
+
+	hdcp.workqueue = create_singlethread_workqueue("hdcp");
+	if (hdcp.workqueue == NULL)
+		goto err_release_res;
+
+	hdmi.isr_cb = &hdcp_irq_cb;
+	hdmi.frame_start_event = &hdcp_start_frame_cb;
+
+	hdmi.enable_ctl = &hdcp_enable_ctl;
+	hdmi.disable_ctl = &hdcp_disable_ctl;
+	hdmi.query_status_ctl = &hdcp_query_status_ctl;
+	hdmi.wait_event_ctl = &hdcp_wait_event_ctl;
+	hdmi.done_ctl = &hdcp_done_ctl;
+
+	hdcp_lib_init();
+
+	mutex_unlock(&hdcp.lock);
+	printk(KERN_INFO "HDCP initialized\n");
+	return 0;
+
+err_release_res:
+	mutex_destroy(&hdcp.lock);
+	iounmap(hdcp.hdmi_wp_base_addr);
+
+	return -EFAULT;
+}
+
+EXPORT_SYMBOL(hdcp_init);
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_exit
+ *-----------------------------------------------------------------------------
+ */
+void hdcp_exit(void)
+{
+	HDCP_DBG("hdcp_exit() %u", jiffies_to_msecs(jiffies));
+
+	mutex_lock(&hdcp.lock);
+
+	hdcp.en_ctrl.nb_retry = 0;
+
+	hdmi.isr_cb = 0;
+	hdmi.frame_start_event = 0;
+
+	hdmi.enable_ctl = 0;
+	hdmi.disable_ctl = 0;
+	hdmi.query_status_ctl = 0;
+	hdmi.wait_event_ctl = 0;
+	hdmi.done_ctl = 0;
+
+	/* Unmap HDMI WP */
+	iounmap(hdcp.hdmi_wp_base_addr);
+
+	destroy_workqueue(hdcp.workqueue);
+
+	mutex_unlock(&hdcp.lock);
+	mutex_destroy(&hdcp.lock);
+}
+
+EXPORT_SYMBOL(hdcp_exit);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/hdcp.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/hdcp.h	2014-08-07 11:51:55.974748526 -0600
@@ -0,0 +1,131 @@
+/*
+ * hdcp.h
+ *
+ * HDCP interface DSS driver setting for TI's OMAP4 family of processor.
+ * Copyright (C) 2010-2011 Texas Instruments Incorporated - http://www.ti.com/
+ * Authors: Fabrice Olivero
+ *	Fabrice Olivero <f-olivero@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _HDCP_H_
+#define _HDCP_H_
+
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+
+
+/* Event source */
+#define HDCP_SRC_SHIFT		8
+#define HDCP_IOCTL_SRC		(0x1 << HDCP_SRC_SHIFT)
+#define HDCP_HDMI_SRC		(0x2 << HDCP_SRC_SHIFT)
+#define HDCP_IRQ_SRC		(0x4 << HDCP_SRC_SHIFT)
+#define HDCP_WORKQUEUE_SRC	(0x8 << HDCP_SRC_SHIFT)
+
+/* Workqueue events */
+/* Note: HDCP_ENABLE_CTL, HDCP_R0_EXP_EVENT, HDCP_KSV_TIMEOUT_EVENT and
+ * HDCP_AUTH_REATT_EVENT can be cancelled by HDCP disabling
+ */
+#define HDCP_ENABLE_CTL		(HDCP_IOCTL_SRC		| 0)
+#define HDCP_DISABLE_CTL	(HDCP_IOCTL_SRC		| 1)
+#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC		| 2)
+#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC		| 3)
+#define HDCP_HPD_LOW_EVENT	(HDCP_IRQ_SRC		| 4)
+#define HDCP_RI_FAIL_EVENT	(HDCP_IRQ_SRC		| 5)
+#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC		| 6)
+#define HDCP_R0_EXP_EVENT	(HDCP_WORKQUEUE_SRC	| 7)
+#define HDCP_KSV_TIMEOUT_EVENT	(HDCP_WORKQUEUE_SRC	| 8)
+#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC	| 9)
+
+
+enum hdcp_states {
+	HDCP_DISABLED,
+	HDCP_ENABLE_PENDING,
+	HDCP_AUTHENTICATION_START,
+	HDCP_WAIT_R0_DELAY,
+	HDCP_WAIT_KSV_LIST,
+	HDCP_LINK_INTEGRITY_CHECK,
+};
+
+enum hdmi_states {
+	HDMI_STOPPED,
+	HDMI_STARTED
+};
+
+struct hdcp_delayed_work {
+	struct delayed_work work;
+	int event;
+};
+
+struct hdcp {
+
+	struct mutex lock;
+	/* HDCP Enable configurations, supplied by apps. Currently takes in
+		argument to specify the number of re-trys to be attempted before
+		giving up autentication */
+	struct ti81xxhdmi_hdcp_ena_ctrl en_ctrl;
+	/* Specifies if HDMI is ON or OFF. HDMI requires to be ON before HDCP
+		can start autentication process */
+	enum hdmi_states hdmi_state;
+	/* Specifies curret state of HDCP autentication status, drives the state
+		machine */
+	enum hdcp_states hdcp_state;
+	/* Specifies the status of HDCP autentication that would be returned to
+		applications, when queried */
+	int auth_state;
+
+	/* Wait state indicator - has been enabled - unable to enable due to
+		HDMI not streaming */
+	struct delayed_work *pending_start;
+
+	/* Following variable should store works submitted from workqueue
+	 * context
+	 * WARNING: only ONE work at a time can be stored (no conflict
+	 * should happen). It is used to allow cancelled pending works when
+	 * disabling HDCP
+	 */
+	struct delayed_work *pending_wq_event;
+	/* No of re-trys required before giving up autentication */
+	int retry_cnt;
+	/* Not used as of now */
+	int dss_state;
+	/* Not used as of now, would require to indicate HDMI to restart when
+		AKSV errors are encountered */
+	int hdmi_restart;
+	/* Indicates the sink was di-connected or SINK drove the HPD low.
+		Not used as of now. */
+	int hpd_low;
+	/* Primary work queue, used to handle enable request, state transitions
+		etc... */
+	struct workqueue_struct *workqueue;
+
+	int hdcp_up_event;
+	int hdcp_down_event;
+
+	u8 metadata[10];
+
+	/* Remove the following */
+	void __iomem *hdmi_wp_base_addr;
+};
+
+/* Functions */
+void hdcp_exit(void);
+int hdcp_init(void);
+
+#endif /* _HDCP_H_ */
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/hdmi.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/hdmi.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/ti81xxhdmi/hdmi.h	2014-08-07 11:51:56.006748525 -0600
@@ -74,6 +74,49 @@
 #define TI814x_CM_HDMI_CLKCTRL_OFF			(0x0824)
 #define TI814x_CM_ALWON_SDIO_CLKCTRL			(0x15B0)
 
+/* distinguish power states when ACTIVE */
+enum hdmi_power_state {
+	HDMI_POWER_OFF,
+	HDMI_POWER_MIN,		/* minimum power for HPD detect */
+	HDMI_POWER_FULL,	/* full power */
+};
+
+/* Different state of this device on the CEC n/w */
+enum hdmi_cec_state {
+	HDMI_CEC_BYPASS,
+	HDMI_CEC_REGISTERED,
+	HDMI_CEC_UN_REGISTERED
+};
+
+struct hdmi {
+	struct kobject kobj;
+	void __iomem *base_phy;
+	void __iomem *base_pll;
+	void __iomem *base_prcm;
+	void __iomem *base_wp;
+	struct mutex lock;
+	int code;
+	int mode;
+	int deep_color;
+	int lr_fr;
+	int force_set;
+	int freq;
+	enum hdmi_power_state power_state;
+	/* added for DM814x Power management */
+	enum ti81xx_display_status status;
+	/* added this for maintaining the status of the driver. */
+	struct hdmi_config cfg;
+	struct platform_device *pdev;
+	struct ti81xx_venc_info vencinfo;
+	enum hdmi_cec_state cec_state;
+	void (*isr_cb) (int status);
+	void (*frame_start_event) (void);
+	long (*enable_ctl) (void __user *argp);
+	long (*disable_ctl) (void);
+	long (*query_status_ctl) (void __user *argp);
+	long (*wait_event_ctl) (void __user *argp);
+	long (*done_ctl)(void __user *argp);
+};
 
 #endif
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/capt.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/capt.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/capt.c	2014-08-07 11:51:56.034748523 -0600
@@ -36,7 +36,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
 #include <linux/videodev2.h>
-#include <mach/board-ti814x.h>
 
 #include "core.h"
 #include <mach/capt.h>
@@ -989,10 +988,6 @@
 	}
 	num_captctrl = 0;
 	capture_dev = NULL;
-
-	if (cpu_is_ti814x() && (!def_i2cmode))
-		ti814x_pcf8575_exit();
-
 }
 
 int __init vps_capt_init(struct platform_device *pdev)
@@ -1003,9 +998,6 @@
 	u32 offset = 0;
 	VPSSDBG("cap init\n");
 
-	if (cpu_is_ti814x() && (!def_i2cmode))
-		ti814x_pcf8575_init();
-
 	INIT_LIST_HEAD(&cctrl_list);
 
 	num_captctrl = 0;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/dc.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/dc.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/dc.h	2014-08-07 11:51:56.806748488 -0600
@@ -31,6 +31,8 @@
 #define SDVENC 2
 #define HDCOMP 3
 
+#define VPS_DC_OUTPUT_VGA	0xFF
+
 #define MAX_INPUT_NODES_BLENDER   5
 
 #define DM814X_PLL_CLOCK_SOURCE	0x2C8
@@ -43,6 +45,9 @@
 	DC_NODE_ID
 };
 
+#define VPSS_HDCOMP_SYNC_SRC_OFFSET	0x724
+#define VPSS_HDCOMP_SYNC_SRC_DVO2	0x4
+#define VPSS_HDCOMP_SYNC_SRC_DVO1	0x2
 
 struct dc_vencmode_info {
 	const char            *name;
@@ -63,6 +68,8 @@
 	char                     *name;
 	u32                      idx;
 	bool                     enabled;
+	/*if it is not mask, then this blender will not shown up*/
+	bool                     mask;
 	struct kobject           kobj;
 	u32                      actnodes;
 	struct vps_dispctrl      *dctrl;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/dctrl.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/dctrl.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/dctrl.c	2014-08-07 11:51:56.894748484 -0600
@@ -31,7 +31,6 @@
 #include <linux/kobject.h>
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
-#include <mach/board-ti816x.h>
 
 #include "core.h"
 #include "system.h"
@@ -300,7 +299,9 @@
 {
 	int i;
 
-	for (i = 0; i < disp_ctrl->numvencs; i++) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
+		if (!disp_ctrl->blenders[i].mask)
+			continue;
 		if (vid == venc_name[i].vid) {
 			*idx = venc_name[i].idx;
 			return 0;
@@ -316,8 +317,11 @@
 
 	int i;
 
-	for (i = 0; i < disp_ctrl->numvencs; i++) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
 		const struct dc_vencname_info *vnid = &venc_name[i];
+		if (!disp_ctrl->blenders[i].mask)
+			continue;
+
 		if (sysfs_streq(vname, vnid->name)) {
 			*vid = vnid->vid;
 			return 0;
@@ -330,8 +334,10 @@
 {
 	int i;
 
-	for (i = 0; i < disp_ctrl->numvencs; i++) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
 		const struct dc_vencname_info *vnid = &venc_name[i];
+		if (!disp_ctrl->blenders[i].mask)
+			continue;
 		if (vnid->idx == idx) {
 			*bid = vnid->bid;
 			return 0;
@@ -618,7 +624,9 @@
 {
 	int i;
 	int r = -EINVAL;
-	for (i = 0; i < disp_ctrl->numvencs; i++) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
+		if (!disp_ctrl->blenders[i].mask)
+			continue;
 		if (bid == venc_name[i].bid) {
 			r = dc_get_format_from_vid(venc_name[i].vid,
 						   width,
@@ -700,10 +708,27 @@
 				if (venc_ids == 1)
 					disp_ctrl->tiedvenc = 0;
 			}
-		} else
+		} else {
 			VPSSERR("failed to disable the venc.\n");
+			return -r;
+		}
 
 	}
+	if (!def_i2cmode) {
+		int ret = 0;
+		if (vid & VPS_DC_VENC_HDCOMP) {
+			if (v_pdata->pcf_ths_hd_set)
+				ret = v_pdata->pcf_ths_hd_set(
+					TI81XX_THS7360_DISABLE_SF);
+
+		} else if (vid & VPS_DC_VENC_SD) {
+			if (v_pdata->pcf_ths_sd_set)
+				ret = v_pdata->pcf_ths_sd_set(
+					TI81XX_THSFILTER_DISABLE_MODULE);
+		}
+		if (ret < 0)
+			VPSSERR("Disable THS filter failed.\n");
+	}
 	i = 0;
 	/*disable the external video device if applicable*/
 	while (vid >> i) {
@@ -737,40 +762,45 @@
 {
 	int i, r = 0;
 	int vencs = 0;
-	int bidx = 0;
+	int bidx = 0, idx;
 	struct vps_dcvencinfo vi;
 	if ((disp_ctrl == NULL) || (disp_ctrl->fvid2_handle == NULL))
 		return -EINVAL;
-
-
+	if (!vinfo->numvencs)
+		return 0;
+	vi.numvencs = 0;
 	/*get the current setting based on the app inputs*/
-	for (i = 0; i < vinfo->numvencs; i++)
-		vi.modeinfo[i].vencid = vinfo->modeinfo[i].vencid;
-
-	vi.numvencs = vinfo->numvencs;
+	for (i = 0; i < vinfo->numvencs; i++) {
+		if (vinfo->modeinfo[i].vencid & disp_ctrl->vencmask)
+			vi.modeinfo[vi.numvencs++].vencid =
+				vinfo->modeinfo[i].vencid;
+	}
 
 	r = dc_get_vencinfo(&vi);
-
 	if (r) {
 		VPSSERR("failed to get venc info.\n");
 		goto exit;
 	}
-
 	/*make sure current venc status is matching */
 	disp_ctrl->vinfo->numvencs = 0;
 	disp_ctrl->vinfo->tiedvencs = 0;
+	idx = 0;
 	for (i = 0; i < vinfo->numvencs; i++) {
-		if (vi.modeinfo[i].isvencrunning) {
-			if (vi.modeinfo[i].minfo.standard !=
+		if (!(vinfo->modeinfo[i].vencid & disp_ctrl->vencmask))
+			continue;
+
+		if (vi.modeinfo[idx].isvencrunning) {
+			if (vi.modeinfo[idx].minfo.standard !=
 			    vinfo->modeinfo[i].minfo.standard) {
 				VPSSERR("venc %d already running with \
-						different mode %d\n",
-						vi.modeinfo[i].vencid,
-						vi.modeinfo[i].minfo.standard);
+					different mode %d\n",
+					vi.modeinfo[idx].vencid,
+					vi.modeinfo[idx].minfo.standard);
 				/*update the local infor*/
-				get_idx_from_vid(vi.modeinfo[i].vencid, &bidx);
+				get_idx_from_vid(vi.modeinfo[idx].vencid,
+						&bidx);
 				memcpy(&venc_info.modeinfo[bidx],
-				       &vi.modeinfo[i],
+				       &vi.modeinfo[idx],
 				       sizeof(struct vps_dcmodeinfo));
 				/*Update the SDVENC Clock */
 				if (bidx == SDVENC) {
@@ -785,7 +815,7 @@
 
 			} else
 				VPSSDBG("venc %d already running\n",
-					vi.modeinfo[i].vencid);
+					vi.modeinfo[idx].vencid);
 
 
 		} else {
@@ -794,9 +824,9 @@
 				    [disp_ctrl->vinfo->numvencs++],
 				&vinfo->modeinfo[i],
 				sizeof(struct vps_dcmodeinfo));
-
 			vencs |= vinfo->modeinfo[i].vencid;
 		}
+		idx++;
 	}
 	if (vinfo->tiedvencs) {
 		if ((vencs & vinfo->tiedvencs) != vinfo->tiedvencs) {
@@ -822,8 +852,37 @@
 		}
 		disp_ctrl->enabled_venc_ids |= vencs;
 		disp_ctrl->tiedvenc = disp_ctrl->vinfo->tiedvencs;
+	}
+	if (!def_i2cmode) {
+		int ret = 0;
+		if (vencs & VPS_DC_VENC_HDCOMP)	{
+			if (v_pdata->pcf_ths_hd_set) {
+				u32 clock, thsctrl;
+				clock = venc_info.modeinfo[HDCOMP]. \
+					minfo.pixelclock;
+				thsctrl = TI81XX_THS7360_SF_TRUE_HD_MODE;
+				if (clock <= 54000)
+					thsctrl = TI81XX_THS7360_SF_ED_MODE;
+				else if (clock <= 74250)
+					thsctrl = TI81XX_THS7360_SF_HD_MODE;
+				if (v_pdata->pcf_ths_hd_set)
+					ret = v_pdata->pcf_ths_hd_set(
+								thsctrl);
+				if (ret > 0)
+					VPSSDBG("program ths to %d mode\n",
+						thsctrl);
+			}
+		}
+		if (vencs & VPS_DC_VENC_SD) {
+			if (v_pdata->pcf_ths_sd_set)
+				ret = v_pdata->pcf_ths_sd_set(
+					TI81XX_THSFILTER_ENABLE_MODULE);
+		}
+		if (ret < 0)
+			VPSSERR("failed to set THS filter\n");
 
 	}
+
 	/*handle external video device if applicable*/
 	for (i = 0; i < vinfo->numvencs; i++) {
 		struct dc_blender_info *binfo;
@@ -981,7 +1040,27 @@
 	return r;
 
 }
-static void dc_set_hdcomp_pll(u32 pllclk)
+static void dc_select_dvo2_clock(u32 src)
+{
+	u32 temp;
+	if (v_pdata->cpu == CPU_DM816X)
+		return;
+
+	temp = omap_readl(
+		TI814X_PLL_BASE + DM814X_PLL_CLOCK_SOURCE);
+
+	temp &= ~(0x1 << 24);
+
+	if (src == HDMI)
+		temp |= 0x1 << 24;
+
+	omap_writel(temp,
+		TI814X_PLL_BASE + DM814X_PLL_CLOCK_SOURCE);
+
+	return;
+
+}
+static void dc_select_hdcomp_pll(u32 pllclk)
 {
 	u32 value;
 	if (v_pdata->cpu != CPU_DM813X)
@@ -1013,6 +1092,52 @@
 	return;
 
 }
+/*select correct sync source*/
+static int dc_select_hdcomp_syncsrc(u32 src)
+{
+	if (cpu_is_ti816x() && (omap_rev() >= TI8168_REV_ES2_0)) {
+		u32 reg = omap_readl(TI81XX_CTRL_BASE +
+			VPSS_HDCOMP_SYNC_SRC_OFFSET);
+		/*select the sync source for DVO or HDCOMP
+		 in the 2.0 silicon, HDCOMP supports discrete
+		 sync output(HSYNC/VSYNC),
+		 these two signals are shared with SYNC pins of either DVO1 or
+		 DVO2 as below.
+
+		Pin Mapping:
+		HSYNC -- AR5/AT9/AR8
+		VSYNC -- AL5/AP9/AL9
+		Change pin names:
+		Pins AR5 and AT9 - change VOUT[1]_HSYNC to DAC_VOUT[1]_HSYNC
+		Pin AR8 - change VOUT[0]_AVID to DAC_HSYNC_VOUT[0]_AVID
+		Pins AL5 and AP9 - change VOUT[1]_VSYNC to DAC_VOUT[1]_VSYNC
+		Pin AL9 - change VOUT[0]_FLD to DAC_VSYNC_VOUT[0]_FLD
+
+		Bits   Field          Value        Descriptions
+		2      SPR_CTL0_2		To Select DAC or VOUT[0]
+					0	Selects VOUT[0]_AVID/FLD
+					1	Selects DAC_HSYNC/VSYNC
+
+
+		1	SPR_CTL0_1		To Select DAC or VOUT[1]
+
+					0	Selects VOUT[1]_HSYNC/VSYNC
+					1	Selects DAC_HSYNC/VSYNC
+
+		 */
+		reg &= ~(VPSS_HDCOMP_SYNC_SRC_DVO1 |
+				VPSS_HDCOMP_SYNC_SRC_DVO2);
+		if (src == HDMI)
+			reg |= VPSS_HDCOMP_SYNC_SRC_DVO1;
+		else if (src == DVO2)
+			reg |= VPSS_HDCOMP_SYNC_SRC_DVO2;
+
+		omap_writel(reg, TI81XX_CTRL_BASE +
+			VPSS_HDCOMP_SYNC_SRC_OFFSET);
+	}
+	return 0;
+
+}
 /*E******************************** private functions *********************/
 
 /*S*******************************  public functions  *********************/
@@ -1505,22 +1630,6 @@
 
 	venc_info.modeinfo[idx].minfo.standard = mid;
 	dc_get_timing(mid, &venc_info.modeinfo[idx].minfo);
-	if ((v_pdata->cpu == CPU_DM816X) && (!def_i2cmode)) {
-		if ((binfo->idx == HDCOMP) && (binfo->isdeviceon == true)) {
-			if ((mid == FVID2_STD_1080P_60) ||
-			    (mid == FVID2_STD_1080P_50))
-				r = pcf8575_ths7360_hd_enable(
-					TI816X_THS7360_SF_TRUE_HD_MODE);
-			else
-				r = pcf8575_ths7360_hd_enable(
-					TI816X_THS7360_SF_HD_MODE);
-			if (r < 0) {
-				VPSSERR("failed to set THS filter\n");
-				goto exit;
-			}
-
-		}
-	}
 	r = size;
 exit:
 	dc_unlock(binfo->dctrl);
@@ -1755,49 +1864,116 @@
 			binfo->clksrc.clksrc = clksrc.clksrc;
 		}
 	} else {
-		/*this is the special case to let
-		DVO2 use the HDMI_PLL*/
-		if ((v_pdata->cpu != CPU_DM816X) && (binfo->idx == DVO2))  {
-			u32 temp;
-			temp = omap_readl(
-				TI814X_PLL_BASE + DM814X_PLL_CLOCK_SOURCE);
+		r = -EINVAL;
+		VPSSERR("invalid clock source input\n");
+	}
 
-			if (sysfs_streq(buf, "hdmi"))
-				temp |= 0x1 << 24;
-			else
-				temp &= ~(0x1 << 24);
+exit:
+	dc_unlock(binfo->dctrl);
+	return r;
+}
+
+static ssize_t blender_source_show(struct dc_blender_info *binfo, char *buf)
+{
+	u32 value, r = 0;
+	if (binfo->idx == HDMI || binfo->idx == SDVENC)
+		return -EINVAL;
+	if ((binfo->idx == DVO2) && (v_pdata->cpu != CPU_DM816X)) {
+		value = omap_readl(
+		TI814X_PLL_BASE + DM814X_PLL_CLOCK_SOURCE);
+		if ((value >> 24) & 1)
+			r = snprintf(buf, PAGE_SIZE, "hdmi\n");
+		else
+			r = snprintf(buf, PAGE_SIZE, "dvo2\n");
+	} else if ((v_pdata->cpu == CPU_DM813X) &&
+	    (binfo->idx == HDCOMP)) {
+		value = omap_readl(TI814X_PLL_BASE +
+				DM813X_PLL_HD_CLOCK_SOURCE);
+		value &= 3;
+		switch (value) {
+		case 0:
+			r = snprintf(buf, PAGE_SIZE, "hdmi\n");
+			break;
+		case 2:
+			r = snprintf(buf, PAGE_SIZE, "sd\n");
+			break;
+		default:
+			r = snprintf(buf, PAGE_SIZE, "dvo2\n");
+			break;
+		}
 
+	} else if ((v_pdata->cpu == CPU_DM816X) &&
+		   (binfo->idx == HDCOMP) &&
+		   (omap_rev() >= TI8168_REV_ES2_0)) {
+
+		value = omap_readl(TI81XX_CTRL_BASE +
+			VPSS_HDCOMP_SYNC_SRC_OFFSET);
+		if (value & VPSS_HDCOMP_SYNC_SRC_DVO2)
+			r = snprintf(buf, PAGE_SIZE, "dvo2\n");
+		else if (value & VPSS_HDCOMP_SYNC_SRC_DVO1)
+			r = snprintf(buf, PAGE_SIZE, "dvo2\n");
+		else
+			r = snprintf(buf, PAGE_SIZE, "none\n");
+	}
 
-			omap_writel(temp,
-				TI814X_PLL_BASE + DM814X_PLL_CLOCK_SOURCE);
-			r = size;
-		} else if ((v_pdata->cpu == CPU_DM813X) &&
-		    (binfo->idx == HDCOMP)) {
-			/*FIXME add DM813X support here */
-			enum vps_vplloutputclk pllclk;
-			pllclk = VPS_SYSTEM_VPLL_OUTPUT_MAX_VENC;
-			if (sysfs_streq(buf, "sd"))
-				pllclk = VPS_SYSTEM_VPLL_OUTPUT_VENC_RF;
-			else if (sysfs_streq(buf, "dvo2"))
-				pllclk = VPS_SYSTEM_VPLL_OUTPUT_VENC_D;
-			else if (sysfs_streq(buf, "hdmi"))
-				pllclk = VPS_SYSTEM_VPLL_OUTPUT_VENC_HDMI;
 
-			dc_set_hdcomp_pll(pllclk);
-			r = size;
+	return r;
+}
 
-		} else {
-			r = -EINVAL;
-			VPSSERR("invalid clock source input\n");
-		}
+static ssize_t blender_source_store(struct dc_blender_info *binfo,
+				     const char *buf,
+				     size_t size)
+{
+
+	int r = 0;
+
+	if (binfo->idx == HDMI || binfo->idx == SDVENC)
+		return -EINVAL;
 
+	/*this is the special case to let
+	DVO2 use the HDMI_PLL*/
+	if ((v_pdata->cpu != CPU_DM816X) && (binfo->idx == DVO2))  {
+		u32 src = DVO2;;
+
+		if (sysfs_streq(buf, "hdmi"))
+			src = HDMI;
+		/*select right clock source*/
+		dc_select_dvo2_clock(src);
+		r = size;
+	} else if ((v_pdata->cpu == CPU_DM813X) &&
+	    (binfo->idx == HDCOMP)) {
+		/*add DM813X support here */
+		enum vps_vplloutputclk pllclk;
+		pllclk = VPS_SYSTEM_VPLL_OUTPUT_MAX_VENC;
+		if (sysfs_streq(buf, "sd"))
+			pllclk = VPS_SYSTEM_VPLL_OUTPUT_VENC_RF;
+		else if (sysfs_streq(buf, "dvo2"))
+			pllclk = VPS_SYSTEM_VPLL_OUTPUT_VENC_D;
+		else if (sysfs_streq(buf, "hdmi"))
+			pllclk = VPS_SYSTEM_VPLL_OUTPUT_VENC_HDMI;
+
+		dc_select_hdcomp_pll(pllclk);
+		r = size;
+
+	} else if ((v_pdata->cpu == CPU_DM816X) &&
+		   (binfo->idx == HDCOMP) &&
+		   (omap_rev() >= TI8168_REV_ES2_0)) {
+			u32 src = HDCOMP;
+			if (sysfs_streq(buf, "dvo1"))
+				src = HDMI;
+			else if (sysfs_streq(buf, "dvo2"))
+				src = DVO2;
+
+		/*set the correct sync source*/
+		dc_select_hdcomp_syncsrc(src);
+		r = size;
+	} else {
+		r = -EINVAL;
+		VPSSERR("invalid clock source input\n");
 	}
 
-exit:
-	dc_unlock(binfo->dctrl);
 	return r;
 }
-
 static ssize_t blender_output_show(struct dc_blender_info *binfo, char *buf)
 {
 	struct vps_dcoutputinfo oinfo;
@@ -1816,11 +1992,17 @@
 		l += snprintf(buf + l,
 			      PAGE_SIZE - l, "%s",
 			      dfmt_name[oinfo.dvofmt].name);
-	else
-		l += snprintf(buf + l,
+	else {
+		if ((oinfo.afmt == VPS_DC_A_OUTPUT_COMPONENT) &&
+			(oinfo.dvofmt == VPS_DC_DVOFMT_TRIPLECHAN_DISCSYNC) &&
+			binfo->idx == HDCOMP)
+			l += snprintf(buf + l,
+			      PAGE_SIZE - l, "vga");
+		else
+			l += snprintf(buf + l,
 			      PAGE_SIZE - l, "%s",
 			      afmt_name[oinfo.afmt].name);
-
+	}
 	if (binfo->idx != SDVENC) {
 		for (i = 0 ; i < ARRAY_SIZE(datafmt_name); i++) {
 			if (datafmt_name[i].value == oinfo.dataformat)
@@ -1882,7 +2064,7 @@
 		/*check digital format or analog format based on current venc*/
 		if (!found) {
 			if (isdigitalvenc(oinfo.vencnodenum)) {
-				for (i = 0; i < VPS_DC_DVOFMT_MAX; i++)
+				for (i = 0; i < ARRAY_SIZE(dfmt_name); i++)
 					if (sysfs_streq(ptr,
 					    dfmt_name[i].name)) {
 						dfmt = dfmt_name[i].value;
@@ -1890,7 +2072,7 @@
 						break;
 					}
 			} else {
-				for (i = 0; i < VPS_DC_A_OUTPUT_MAX; i++)
+				for (i = 0; i < ARRAY_SIZE(afmt_name); i++)
 					if (sysfs_streq(ptr,
 					    afmt_name[i].name)) {
 						afmt = afmt_name[i].value;
@@ -1929,13 +2111,6 @@
 		if (dfmt != VPS_DC_DVOFMT_MAX)
 			oinfo.dvofmt = dfmt;
 
-		if (pol == 0xFF) {
-			oinfo.dvoactvidpolarity = polarity[0];
-			oinfo.dvofidpolarity = polarity[1];
-			oinfo.dvohspolarity = polarity[2];
-			oinfo.dvovspolarity = polarity[3];
-		}
-
 	} else {
 		if ((afmt == VPS_DC_A_OUTPUT_MAX) && (fmt == FVID2_DF_MAX)) {
 			VPSSERR("no valid analog output settings\n");
@@ -1944,14 +2119,42 @@
 
 		}
 		if ((binfo->idx == SDVENC) &&
-		     (afmt == VPS_DC_A_OUTPUT_COMPONENT)) {
+		     ((afmt == VPS_DC_A_OUTPUT_COMPONENT) ||
+		     (afmt == VPS_DC_OUTPUT_VGA))) {
 			VPSSERR("component out not supported on sdvenc\n");
 			r = -EINVAL;
 			goto exit;
 
 		}
-		if (afmt != VPS_DC_A_OUTPUT_MAX)
+		if (afmt != VPS_DC_A_OUTPUT_MAX) {
 			oinfo.afmt = afmt;
+			if (afmt == VPS_DC_A_OUTPUT_COMPONENT)
+				oinfo.dvofmt =
+					VPS_DC_DVOFMT_TRIPLECHAN_EMBSYNC;
+			else if (afmt == VPS_DC_OUTPUT_VGA) {
+				oinfo.afmt = VPS_DC_A_OUTPUT_COMPONENT;
+				oinfo.dvofmt =
+				    VPS_DC_DVOFMT_TRIPLECHAN_EMBSYNC;
+				if (((v_pdata->cpu == CPU_DM816X) &&
+					(omap_rev() >= TI8168_REV_ES2_0)) ||
+					(v_pdata->cpu == CPU_DM813X))
+					oinfo.dvofmt =
+					    VPS_DC_DVOFMT_TRIPLECHAN_DISCSYNC;
+				else
+					VPSSERR("vga is not support"
+						"on this silicon, forced to "
+						"component\n");
+
+			}
+		}
+
+	}
+
+	if (pol == 0xFF) {
+		oinfo.dvoactvidpolarity = polarity[0];
+		oinfo.dvofidpolarity = polarity[1];
+		oinfo.dvohspolarity = polarity[2];
+		oinfo.dvovspolarity = polarity[3];
 	}
 
 	if (fmt != FVID2_DF_MAX)
@@ -2094,13 +2297,6 @@
 	return l;
 }
 
-static ssize_t blender_edid_store(struct dc_blender_info *binfo,
-				     const char *buf,
-				     size_t size)
-{
-	return 0;
-}
-
 struct blender_attribute {
 	struct attribute attr;
 	ssize_t (*show)(struct dc_blender_info *, char *);
@@ -2125,9 +2321,11 @@
 		blender_clksrc_show, blender_clksrc_store);
 static BLENDER_ATTR(order, S_IRUGO | S_IWUSR,
 		blender_order_show, blender_order_store);
+static BLENDER_ATTR(source, S_IRUGO | S_IWUSR,
+		blender_source_show, blender_source_store);
 /* currently EDID read only */
 static BLENDER_ATTR(edid, S_IRUGO,
-		blender_edid_show, blender_edid_store);
+		blender_edid_show, NULL);
 
 static struct attribute *blender_sysfs_attrs[] = {
 	&blender_attr_mode.attr,
@@ -2138,6 +2336,7 @@
 	&blender_attr_order.attr,
 	&blender_attr_name.attr,
 	&blender_attr_edid.attr,
+	&blender_attr_source.attr,
 	NULL
 };
 
@@ -2184,10 +2383,6 @@
 	.default_attrs = blender_sysfs_attrs,
 };
 
-
-
-/*sysfs for the display controller*/
-
 static ssize_t dctrl_tiedvencs_show(struct vps_dispctrl *dctrl, char *buf)
 {
 	return snprintf(buf, PAGE_SIZE, "%d\n", disp_ctrl->tiedvenc);
@@ -2366,12 +2561,22 @@
 			}
 		}
 		if (i == ARRAY_SIZE(vclksrc_name)) {
-			if (v_pdata->cpu == CPU_DM813X) {
+			if (v_pdata->cpu != CPU_DM816X) {
+
 				if (dc_get_vencid(venc, &vid)) {
 					VPSSERR("wrong venc\n");
 					break;
 				}
-				if (vid == VPS_DC_VENC_HDCOMP) {
+				/*this apply for both DM813X and DM814x*/
+				if (vid == VPS_DC_VENC_DVO2) {
+					if (sysfs_streq(csrc, "hdmi"))
+						dc_select_dvo2_clock(HDMI);
+					else
+						dc_select_dvo2_clock(DVO2);
+				}
+
+				if ((v_pdata->cpu == CPU_DM813X) &&
+				    (vid == VPS_DC_VENC_HDCOMP)) {
 					enum vps_vplloutputclk pllclk;
 					pllclk =
 					    VPS_SYSTEM_VPLL_OUTPUT_MAX_VENC;
@@ -2385,9 +2590,8 @@
 					else if (sysfs_streq(csrc, "sd"))
 						pllclk = \
 						VPS_SYSTEM_VPLL_OUTPUT_VENC_RF;
-					dc_set_hdcomp_pll(pllclk);
+					dc_select_hdcomp_pll(pllclk);
 				}
-
 			} else
 				VPSSERR("wrong clock source\n");
 		}
@@ -2640,13 +2844,14 @@
 			  int tied_vencs,
 			  const char *clksrc)
 {
-	int r = 0;
-	int i;
+	int r = 0, i, idx;
 	int size = 0, offset = 0;
+	struct vps_dcvencinfo vinfo;
+
 	VPSSDBG("dctrl init\n");
 
-	if ((v_pdata->cpu == CPU_DM816X) && (!def_i2cmode))
-		ti816x_pcf8575_init();
+	if ((!def_i2cmode) && (v_pdata->pcf_ths_init))
+		v_pdata->pcf_ths_init();
 
 	dc_payload_info = kzalloc(sizeof(struct vps_payload_info),
 				  GFP_KERNEL);
@@ -2673,12 +2878,27 @@
 		r = -ENOMEM;
 		goto cleanup;
 	}
-	disp_ctrl->numvencs = v_pdata->numvencs;
-	venc_info.numvencs = disp_ctrl->numvencs;
-	disp_ctrl->vencmask = v_pdata->vencmask;
 
-	assign_payload_addr(disp_ctrl, dc_payload_info, &offset);
+	disp_ctrl->vencmask = v_pdata->vencmask & 0xF;
+	/*get the id of VENC to be mask*/
+	i = 0;
+	vinfo.numvencs = 0;
+	while (disp_ctrl->vencmask >> i) {
+		if ((disp_ctrl->vencmask  >> i++) & 1) {
+			if (i == 2)
+				disp_ctrl->blenders[HDCOMP].mask = 1;
+			else if (i == 1)
+				disp_ctrl->blenders[HDMI].mask = 1;
+			else
+				disp_ctrl->blenders[i - 2].mask = 1;
+			vinfo.numvencs++;
+		}
+	}
+	if (vinfo.numvencs != v_pdata->numvencs)
+		v_pdata->numvencs = vinfo.numvencs;
 
+	disp_ctrl->numvencs = v_pdata->numvencs;
+	assign_payload_addr(disp_ctrl, dc_payload_info, &offset);
 	vps_dc_ctrl_init(disp_ctrl);
 	/*get dc handle*/
 	dc_handle = vps_fvid2_create(FVID2_VPS_DCTRL_DRV,
@@ -2706,14 +2926,15 @@
 		VPSSERR("failed to create dctrl sysfs file.\n");
 
 	/*create sysfs*/
-	for (i = 0; i < disp_ctrl->numvencs; i++) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
 		struct dc_blender_info *blend = &disp_ctrl->blenders[i];;
-
+		if (!blend->mask)
+			continue;
 		blend->idx = i;
 		blend->actnodes = 0;
 		blend->name = (char *)venc_name[i].name;
 		blend->dctrl = disp_ctrl;
-		blend->isdeviceon = true;
+		blend->isdeviceon = false;
 		INIT_LIST_HEAD(&blend->dev_list);
 		r = kobject_init_and_add(
 			&blend->kobj, &blender_ktype,
@@ -2725,9 +2946,12 @@
 			continue;
 		}
 	}
-
-	disp_ctrl->tiedvenc = tied_vencs;
-	venc_info.tiedvencs = disp_ctrl->tiedvenc;
+	if ((tied_vencs & disp_ctrl->vencmask) == tied_vencs) {
+		disp_ctrl->tiedvenc = tied_vencs;
+		venc_info.tiedvencs = disp_ctrl->tiedvenc;
+		vinfo.tiedvencs = venc_info.tiedvencs;
+	} else
+		VPSSERR("tied venc 0x%x is not supported\n", tied_vencs);
 
 
 	/*parse the mode*/
@@ -2737,22 +2961,25 @@
 		goto cleanup;
 	}
 	/*set up the default clksrc and output format*/
-	for (i = 0; i < disp_ctrl->numvencs; i++) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
 		struct vps_dcvencclksrc *clksrcp =
 				&disp_ctrl->blenders[i].clksrc;
 		struct vps_dcoutputinfo opinfo;
-
+		if (!disp_ctrl->blenders[i].mask)
+			continue;
 		clksrcp->venc = venc_name[i].vid;
 		/*set the venc output*/
 		opinfo.dvofidpolarity = VPS_DC_POLARITY_ACT_HIGH;
 		opinfo.dvohspolarity = VPS_DC_POLARITY_ACT_HIGH;
 		opinfo.dvovspolarity = VPS_DC_POLARITY_ACT_HIGH;
 		opinfo.dvoactvidpolarity = VPS_DC_POLARITY_ACT_HIGH;
-
 		switch (i) {
 		case HDMI:
 			opinfo.vencnodenum = VPS_DC_VENC_HDMI;
-			opinfo.dvofmt = VPS_DC_DVOFMT_TRIPLECHAN_EMBSYNC;
+			if(v_pdata->cpu == CPU_DM811X)
+				opinfo.dvofmt = VPS_DC_DVOFMT_TRIPLECHAN_DISCSYNC;
+			else
+				opinfo.dvofmt = VPS_DC_DVOFMT_TRIPLECHAN_EMBSYNC;
 			opinfo.dataformat = FVID2_DF_RGB24_888;
 			if ((v_pdata->cpu == CPU_DM816X) && (TI8168_REV_ES1_0 ==
 			    omap_rev()))
@@ -2789,6 +3016,7 @@
 			opinfo.vencnodenum = VPS_DC_VENC_HDCOMP;
 			opinfo.afmt = VPS_DC_A_OUTPUT_COMPONENT;
 			opinfo.dataformat = FVID2_DF_YUV422SP_UV;
+			opinfo.dvofmt = VPS_DC_DVOFMT_TRIPLECHAN_EMBSYNC;
 
 			clksrcp->clksrc = VPS_DC_CLKSRC_VENCA;
 			break;
@@ -2811,7 +3039,7 @@
 	/*for DM813X, HDCOMP share the frequency with either HDMI or DVO2
 	so if HDCOMP's pixel clock does not match either HDMI or DVO2,
 	we need force HDCOMP to one based on the clock mux*/
-	if (v_pdata->cpu == CPU_DM813X) {
+	if (v_pdata->cpu == CPU_DM813X && (disp_ctrl->blenders[HDCOMP].mask)) {
 		u8 hdcomp_clk;
 		hdcomp_clk = hdcomppll(HDCOMP);
 		switch (hdcomp_clk) {
@@ -2845,8 +3073,12 @@
 		}
 	}
 	/*set the clock source*/
-	for (i = 0; i < venc_info.numvencs; i++) {
-		if (disp_ctrl->blenders[i].idx != SDVENC) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
+
+		if (!disp_ctrl->blenders[i].mask)
+			continue;
+
+		if ((disp_ctrl->blenders[i].idx != SDVENC) && (disp_ctrl->blenders[i].idx != HDCOMP ))	{
 			r = dc_set_clksrc(
 				&disp_ctrl->blenders[i].clksrc);
 
@@ -2857,10 +3089,13 @@
 		}
 	}
 	/*config the PLL*/
-	for (i = 0; i < venc_info.numvencs; i++) {
+	for (i = 0; i < VPS_DC_MAX_VENC; i++) {
+		if (!disp_ctrl->blenders[i].mask)
+			continue;
 		if ((SDVENC == i) && (v_pdata->cpu != CPU_DM816X))
 			venc_info.modeinfo[i].minfo.pixelclock = 54000;
 
+	if(disp_ctrl->blenders[i].idx != HDCOMP )	{
 		r = dc_set_pllclock(i,
 				    venc_info.modeinfo[i].minfo.pixelclock);
 		if (r) {
@@ -2868,35 +3103,23 @@
 			goto cleanup;
 		}
 	}
-
-	/*set the venc mode*/
-	r = dc_set_vencmode(&venc_info);
-	if (r) {
-		VPSSERR("Failed to set venc mode.\n");
-		goto cleanup;
 	}
-	/*set the the THS filter, device is still registered even
-	if THS setup is failed*/
-	if ((v_pdata->cpu == CPU_DM816X) && (!def_i2cmode)) {
-		r = pcf8575_ths7375_enable(TI816X_THSFILTER_ENABLE_MODULE);
-		if ((venc_info.modeinfo[HDCOMP].minfo.standard ==
-		    FVID2_STD_1080P_60)  ||
-		    (venc_info.modeinfo[HDCOMP].minfo.standard ==
-		    FVID2_STD_1080P_50))
-			r |= pcf8575_ths7360_hd_enable(
-				TI816X_THS7360_SF_TRUE_HD_MODE);
-		else
-			r |= pcf8575_ths7360_hd_enable(
-				TI816X_THS7360_SF_HD_MODE);
-		if (r < 0) {
-			VPSSERR("setup 7375 filter failed\n");
-			disp_ctrl->blenders[HDCOMP].isdeviceon = false;
-		}
-		r = pcf8575_ths7360_sd_enable(TI816X_THSFILTER_ENABLE_MODULE);
-		if (r < 0) {
-			VPSSERR("setup 7360 filter failed.\n");
-			disp_ctrl->blenders[SDVENC].isdeviceon = false;
-
+	/*only enable the required VENCs, now these are based
+	 on the mask information, but it can expand in the future*/
+	idx = 0;
+	if (vinfo.numvencs) {
+		for (i = 0; i < VPS_DC_MAX_VENC; i++) {
+			if (!disp_ctrl->blenders[i].mask)
+				continue;
+			memcpy(&vinfo.modeinfo[idx++],
+				&venc_info.modeinfo[i],
+				sizeof(struct vps_dcmodeinfo));
+		}
+		/*set the venc mode*/
+		r = dc_set_vencmode(&vinfo);
+		if (r) {
+			VPSSERR("Failed to set venc mode.\n");
+			goto cleanup;
 		}
 	}
 	return 0;
@@ -2925,8 +3148,11 @@
 		kobject_del(&disp_ctrl->kobj);
 		kobject_put(&disp_ctrl->kobj);
 
-		for (i = 0; i < disp_ctrl->numvencs; i++) {
+		for (i = 0; i < VPS_DC_MAX_VENC; i++) {
 			struct ti81xx_external_encoder *extenc;
+			if (!disp_ctrl->blenders[i].mask)
+				continue;
+
 			kobject_del(&disp_ctrl->blenders[i].kobj);
 			kobject_put(&disp_ctrl->blenders[i].kobj);
 			/*remove all register devices, should not happen*/
@@ -2965,8 +3191,8 @@
 		dc_handle = NULL;
 	}
 
-	if ((v_pdata->cpu == CPU_DM816X) && (!def_i2cmode))
-		ti816x_pcf8575_exit();
+	if ((!def_i2cmode) && (v_pdata->pcf_ths_exit))
+		v_pdata->pcf_ths_exit();
 
 	return r;
 }
@@ -2994,6 +3220,10 @@
 	if (display_num >= disp_ctrl->numvencs) {
 		return -1;
 	}
+	if (!disp_ctrl->blenders[display_num].mask) {
+		VPSSERR("the VENC is not enabled in the platform level\n");
+		return -1;
+	}
 	dc_lock(disp_ctrl);
 	binfo = &disp_ctrl->blenders[display_num];
 	list_for_each_entry(enc, &binfo->dev_list, list) {
@@ -3101,6 +3331,18 @@
 		}
 
 	}
+
+	if (((v_pdata->cpu != CPU_DM816X) && (HDMI == display_num) &&
+		(panel_driver->type ==
+		TI81xx_DEVICE_TYPE_MASTER))) {
+		/*reconfigure the PLL*/
+		r = dc_set_pllclock(display_num,
+			    venc_info.modeinfo[display_num].
+				minfo.pixelclock);
+		if (r)
+			VPSSERR("failed to set pll");
+	}
+
 exit:
 	dc_unlock(disp_ctrl);
 	return r;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/fvid2.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/fvid2.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/fvid2.c	2014-08-07 11:51:56.894748484 -0600
@@ -82,7 +82,7 @@
 #define VPS_FVID2_RESERVED_NOTIFY	0x09
 #define VPS_FVID2_M3_INIT_VALUE      (0xAAAAAAAA)
 #define VPS_FVID2_PS_LINEID          0
-#define CURRENT_VPS_FIRMWARE_VERSION        (0x01000137)
+#define CURRENT_VPS_FIRMWARE_VERSION        (0x01000144)
 
 static inline int get_payload_size(void);
 static inline void assign_payload_addr(struct vps_fvid2_ctrl *fctrl,
@@ -851,9 +851,11 @@
 		 that M3 is ready to receive the command from A8,
 		 10s is way enough to do*/
 		r = get_firmware_version(pdev, procid, &fwversion, NULL);
-		if (r)
-			msleep(500);
-	} while ((r != 0) && (++i < 20));
+		if (r) {
+			VPSSDBG("Trying to get firmware version\n");
+			msleep(50);
+		}
+	} while ((r != 0) && (++i < 200));
 
 	if (r == 0) {
 		if (fwversion != CURRENT_VPS_FIRMWARE_VERSION) {
@@ -876,6 +878,7 @@
 				fwversion);
 	} else {
 		r = -EINVAL;
+		VPSSERR("Unable to get firmware version\n");
 		goto exit;
 	}
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/grpx.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/grpx.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/grpx.c	2014-08-07 11:51:56.922748483 -0600
@@ -1392,7 +1392,7 @@
 	struct vps_payload_info *pinfo;
 	u32 size = 0;
 	u32 offset = 0;
-	u8 numends = 0;
+	int numends = 0, numgrpx;
 	VPSSDBG("grpx init\n");
 	INIT_LIST_HEAD(&gctrl_list);
 
@@ -1421,9 +1421,11 @@
 
 	pinfo->size = PAGE_ALIGN(size);
 	memset(pinfo->vaddr, 0, pinfo->size);
-
-	for (i = 0; i < VPS_DISP_GRPX_MAX_INST; i++) {
+	numgrpx = v_pdata->numgrpx > VPS_DISP_GRPX_MAX_INST ? \
+		VPS_DISP_GRPX_MAX_INST : v_pdata->numgrpx;
+	for (i = 0; i < numgrpx; i++) {
 		struct vps_grpx_ctrl *gctrl;
+		int j;
 		gctrl = kzalloc(sizeof(*gctrl), GFP_KERNEL);
 
 		if (gctrl == NULL) {
@@ -1440,37 +1442,12 @@
 		gctrl->grpx_num = i;
 		vps_grpx_add_ctrl(gctrl);
 		mutex_init(&gctrl->gmutex);
-		numends = 1;
+		numends = v_pdata->gdata[i].numends;
 		INIT_LIST_HEAD(&gctrl->cb_list);
-		switch (i) {
-		case 0:
+		gctrl->snode = v_pdata->gdata[i].snode;
+		for (j = 0; j < numends; j++)
+			gctrl->enodes[j] = v_pdata->gdata[i].enode[j];
 
-			gctrl->snode = VPS_DC_GRPX0_INPUT_PATH;
-			gctrl->enodes[0] = VPS_DC_HDMI_BLEND;
-			break;
-		case 1:
-			gctrl->snode = VPS_DC_GRPX1_INPUT_PATH;
-			if (v_pdata->cpu == CPU_DM816X)
-				gctrl->enodes[0] = VPS_DC_HDCOMP_BLEND;
-			else
-				gctrl->enodes[0] = VPS_DC_DVO2_BLEND;
-
-			break;
-		case 2:
-			gctrl->snode = VPS_DC_GRPX2_INPUT_PATH;
-			gctrl->enodes[0] = VPS_DC_SDVENC_BLEND;
-			break;
-		}
-#if 0
-		r = vps_dc_set_node(gctrl->enodes[0],
-				    gctrl->snode,
-				    1);
-		if (r) {
-			VPSSERR("failed to set grpx%d nodes\n",
-				i);
-			goto cleanup;
-		}
-#endif
 		gctrl->numends = numends;
 		r = vps_grpx_create_sysfs(gctrl);
 		if (r)
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/sysfs.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/sysfs.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/sysfs.h	2014-08-07 11:51:56.958748481 -0600
@@ -265,7 +265,7 @@
 	{"aclkdiff", VPS_DC_CLKSRC_VENCA_DIV2_DIFF}
 };
 /*used for output sysfs*/
-static const struct vps_sname_info dfmt_name[VPS_DC_DVOFMT_MAX] = {
+static const struct vps_sname_info dfmt_name[] = {
 	{"single", VPS_DC_DVOFMT_SINGLECHAN},
 	{"double", VPS_DC_DVOFMT_DOUBLECHAN},
 	{"triple", VPS_DC_DVOFMT_TRIPLECHAN_EMBSYNC},
@@ -274,10 +274,11 @@
 
 };
 /*used for output sysfs*/
-static const struct vps_sname_info afmt_name[VPS_DC_A_OUTPUT_MAX] = {
+static const struct vps_sname_info afmt_name[] = {
 	{"composite", VPS_DC_A_OUTPUT_COMPOSITE},
 	{"svideo", VPS_DC_A_OUTPUT_SVIDEO},
 	{"component", VPS_DC_A_OUTPUT_COMPONENT},
+	{"vga", VPS_DC_OUTPUT_VGA},
 };
 /*used for output sysfs*/
 static const struct vps_sname_info datafmt_name[] = {
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/system.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/system.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/system.c	2014-08-07 11:51:56.990748480 -0600
@@ -681,16 +681,23 @@
 		if (!(pid == VPS_PLATFORM_ID_EVM_TI8107)) {
 			VPSSERR("Wrong M3 firmware,"
 				" please use Dm385 M3 firmware\n");
-			goto exit;
+//			goto exit;
 		}
-	} else {
+	} else if (v_pdata->cpu == CPU_DM814X) {
 		if (!((pid == VPS_PLATFORM_ID_EVM_TI814x) ||
 			(pid == VPS_PLATFORM_ID_SIM_TI814x))) {
 			VPSSERR("Wrong firmware,"
 				" please use TI814x M3 firmware\n");
 			goto exit;
 		}
-	}
+	} else if (v_pdata->cpu == CPU_DM811X) {
+		if (!(pid == VPS_PLATFORM_ID_EVM_TI811x)) {
+
+			VPSSERR("Wrong firmware,"
+				" please use TI811x M3 firmware\n");
+			goto exit;
+		}
+       }
 	if (v_pdata->cpu != CPU_DM816X) {
 		sys_ctrl->pbase = ioremap(TI814X_PLL_BASE + VIDPLL_OFFSET,
 					VIDPLL_SIZE * 3);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/system.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/system.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/system.h	2014-08-07 11:51:56.994748480 -0600
@@ -101,7 +101,9 @@
 	VPS_PLATFORM_ID_SIM_TI814x,
 	/**< TI814x Simulator. */
 	VPS_PLATFORM_ID_EVM_TI8107,
-	/** < TI8107 EVMs */
+	/**< TI8107 EVMs. */
+	VPS_PLATFORM_ID_EVM_TI811x,
+	/**< TI811x Simulator. */
 	VPS_PLATFORM_ID_MAX
 	/**< Max Platform ID. */
 };
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/video.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/video.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/video/ti81xx/vpss/video.c	2014-08-07 11:51:57.074748476 -0600
@@ -824,15 +824,17 @@
 	int r;
 	VPSSDBG("Set dei/scalar config params\n");
 
-	vctrl->vdeiprm->startx  = deiparams->startx;
-	vctrl->vdeiprm->starty = deiparams->starty;
+	vctrl->vdeicrpcfg->cropstartx = deiparams->deisccropcfg->cropstartx;
+	vctrl->vdeicrpcfg->cropstarty = deiparams->deisccropcfg->cropstarty;
 	vctrl->vdeiprm->sctarwidth = w;
 	vctrl->vdeiprm->sctarheight = h;
 	vctrl->vdeiprm->fmt.height = scalar_prm.inframe_height;
 	vctrl->vdeiprm->fmt.width = scalar_prm.inframe_width;
-	vctrl->vdeiprm->scenable = scalar_prm.scalar_enable;
+	vctrl->vdeiprm->sccfg.bypass = !scalar_prm.scalar_enable;
 	vctrl->vdeiprm->deicfg = NULL;
 	vctrl->vdeiprm->deihqcfg = NULL;
+	vctrl->vdeiprm->deisccropcfg = (struct vps_cropconfig *)
+					vctrl->vdeicr_phy;
 	r = vps_fvid2_control(
 		vctrl->handle,
 		IOCTL_VPS_DEI_DISP_SET_PARAMS,
@@ -1662,6 +1664,7 @@
 	size += sizeof(struct vps_frameparams);
 	size += sizeof(struct vps_dispstatus);
 	size += sizeof(struct vps_dei_disp_params);
+	size += sizeof(struct vps_cropconfig);
 
 	size += sizeof(struct fvid2_cbparams);
 	size += sizeof(struct fvid2_format);
@@ -1718,6 +1721,12 @@
 				&vctrl->vdei_phy,
 				sizeof(struct vps_dei_disp_params));
 
+	vctrl->vdeicrpcfg = (struct vps_cropconfig *)
+				setaddr(pinfo,
+				buf_offset,
+				&vctrl->vdeicr_phy,
+				sizeof(struct vps_cropconfig));
+
 	vctrl->cbparams = (struct fvid2_cbparams *)
 				setaddr(pinfo,
 					buf_offset,
@@ -1749,8 +1758,7 @@
 	struct vps_payload_info *pinfo;
 	u32 size = 0;
 	u32 offset = 0;
-	u8 num_edges = 0;
-	u8 num_outputs = 0;
+	int numvid;
 	VPSSDBG("video init\n");
 	INIT_LIST_HEAD(&vctrl_list);
 
@@ -1778,9 +1786,11 @@
 
 	pinfo->size = PAGE_ALIGN(size);
 	memset(pinfo->vaddr, 0, pinfo->size);
-
-	for (i = 0; i < VPS_DISPLAY_INST_MAX; i++) {
+	numvid = v_pdata->numvideo > VPS_DISPLAY_INST_MAX ? \
+		VPS_DISPLAY_INST_MAX : v_pdata->numvideo;
+	for (i = 0; i < numvid; i++) {
 		struct vps_video_ctrl *vctrl;
+		int j;
 		vctrl = kzalloc(sizeof(*vctrl), GFP_KERNEL);
 
 		if (vctrl == NULL) {
@@ -1794,64 +1804,42 @@
 				    &offset);
 		/*init video control*/
 		vps_fvid2_video_ctrl_init(vctrl);
-		vctrl->idx = i;
+		vctrl->idx = v_pdata->vdata[i].idx;
 		vps_video_add_ctrl(vctrl);
 		mutex_init(&vctrl->vmutex);
 
 		INIT_LIST_HEAD(&vctrl->cb_list);
 		/*setup the nodes*/
+		vctrl->num_edges = v_pdata->vdata[i].numedges;
+		vctrl->num_outputs = v_pdata->vdata[i].numoutput;
+		for (j = 0; j < vctrl->num_edges; j++) {
+			vctrl->nodes[j].inputid =
+				v_pdata->vdata[i].snodes_inputid[j];
+			vctrl->nodes[j].nodeid = v_pdata->vdata[i].snodes[j];
+		}
+
+		for (j = 0; j < vctrl->num_outputs; j++) {
+			vctrl->enodes[j].inputid =
+				v_pdata->vdata[i].enodes_inputid[j];
+			vctrl->enodes[j].nodeid = v_pdata->vdata[i].enodes[j];
+
+		}
 		switch (i) {
 		case 0:
-			num_edges = 2;
-			vctrl->nodes[0].nodeid = VPS_DC_VCOMP_MUX;
-			vctrl->nodes[0].inputid = VPS_DC_BP0_INPUT_PATH;
-
-			vctrl->nodes[1].nodeid =  VPS_DC_VCOMP;
-			vctrl->nodes[1].inputid = VPS_DC_VCOMP_MUX;
-
-			num_outputs = 1;
-			vctrl->enodes[0].nodeid =  VPS_DC_HDMI_BLEND;
-			vctrl->enodes[0].inputid =
-				VPS_DC_CIG_NON_CONSTRAINED_OUTPUT;
-
 			vctrl->caps = VPSS_VID_CAPS_POSITIONING |
 				VPSS_VID_CAPS_COLOR | VPSS_VID_CAPS_CROPING |
 				VPSS_VID_CAPS_SCALING;
 			break;
 		case 1:
-			num_edges = 2;
-			vctrl->nodes[0].nodeid = VPS_DC_HDCOMP_MUX;
-			vctrl->nodes[0].inputid = VPS_DC_BP1_INPUT_PATH;
-
-			vctrl->nodes[1].nodeid =  VPS_DC_CIG_PIP_INPUT;
-			vctrl->nodes[1].inputid = VPS_DC_HDCOMP_MUX;
-
-			num_outputs = 1;
-			if (v_pdata->cpu == CPU_DM816X)
-				vctrl->enodes[0].nodeid = VPS_DC_HDCOMP_BLEND;
-			else
-				vctrl->enodes[0].nodeid = VPS_DC_DVO2_BLEND;
-
-			vctrl->enodes[0].inputid = VPS_DC_CIG_PIP_OUTPUT;
 			vctrl->caps = VPSS_VID_CAPS_POSITIONING |
-				VPSS_VID_CAPS_COLOR | VPSS_VID_CAPS_CROPING;
+				VPSS_VID_CAPS_COLOR | VPSS_VID_CAPS_CROPING |
+				VPSS_VID_CAPS_SCALING;
 			break;
 		case 2:
-			num_edges = 1;
-			vctrl->nodes[0].nodeid = VPS_DC_SDVENC_MUX;
-			vctrl->nodes[0].inputid = VPS_DC_SEC1_INPUT_PATH;
-
-			num_outputs = 1;
-			vctrl->enodes[0].nodeid = VPS_DC_SDVENC_BLEND;
-			vctrl->enodes[0].inputid = VPS_DC_SDVENC_MUX;
 			vctrl->caps = VPSS_VID_CAPS_POSITIONING |
 					 VPSS_VID_CAPS_CROPING;
-
 			break;
 		}
-		vctrl->num_edges = num_edges;
-		vctrl->num_outputs = num_outputs;
-
 		r = video_create_sysfs(vctrl);
 		if (r)
 			goto cleanup;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/watchdog/omap_wdt.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/watchdog/omap_wdt.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/watchdog/omap_wdt.c	2014-08-07 11:51:57.122748474 -0600
@@ -85,6 +85,7 @@
 static void omap_wdt_enable(struct omap_wdt_dev *wdev)
 {
 	void __iomem *base = wdev->base;
+	printk("ROH::::::::::::::::: IN watchdog enable \n");
 
 	/* Sequence to enable the watchdog */
 	__raw_writel(0xBBBB, base + OMAP_WATCHDOG_SPR);
@@ -112,18 +113,44 @@
 
 static void omap_wdt_adjust_timeout(unsigned new_timeout)
 {
+
+	printk("ROH::::: in adjust timeout\n");
 	if (new_timeout < TIMER_MARGIN_MIN)
 		new_timeout = TIMER_MARGIN_DEFAULT;
 	if (new_timeout > TIMER_MARGIN_MAX)
 		new_timeout = TIMER_MARGIN_MAX;
 	timer_margin = new_timeout;
+	printk("ROH::::: time margin = %d\n",timer_margin);
 }
 
 static void omap_wdt_set_timeout(struct omap_wdt_dev *wdev)
 {
 	u32 pre_margin = GET_WLDR_VAL(timer_margin);
+	u32 prescalar,ldrreg;
 	void __iomem *base = wdev->base;
 
+	printk("ROH::::: in set timeout\n");
+
+	printk("ROH:::: premargin is %x\n", pre_margin);
+
+	while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)
+                cpu_relax();
+
+        prescalar= __raw_readl(base + OMAP_WATCHDOG_CNTRL);
+	printk("Prescalar value at control register is %x\n",prescalar);
+        while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)
+                cpu_relax();
+
+	while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)
+                cpu_relax();
+
+        ldrreg= __raw_readl(base + OMAP_WATCHDOG_LDR);
+        printk("LDR value at control register is %x\n",ldrreg);
+        while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)
+                cpu_relax();
+
+
+
 	/* just count up at 32 KHz */
 	while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x04)
 		cpu_relax();
@@ -304,7 +331,9 @@
 
 	omap_wdt_disable(wdev);
 	omap_wdt_adjust_timeout(timer_margin);
+//	omap_wdt_set_timeout(wdev);
 
+	//omap_wdt_enable(wdev);
 	wdev->omap_wdt_miscdev.parent = &pdev->dev;
 	wdev->omap_wdt_miscdev.minor = WATCHDOG_MINOR;
 	wdev->omap_wdt_miscdev.name = "watchdog";
@@ -314,6 +343,8 @@
 	if (ret)
 		goto err_misc;
 
+
+
 	pr_info("OMAP Watchdog Timer Rev 0x%02x: initial timeout %d sec\n",
 		__raw_readl(wdev->base + OMAP_WATCHDOG_REV) & 0xFF,
 		timer_margin);
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/Kconfig	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/Kconfig	2014-08-07 14:42:24.000000000 -0600
@@ -331,6 +331,11 @@
 	default y
 	depends on ARCH_TI814X
 
+config MACH_TI811XEVM
+	bool "TI811X Evaluation Module"
+	default n
+	depends on ARCH_TI814X
+
 config MACH_TI8168EVM
 	bool "TI8168 Evaluation Module"
 	default y
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-ti811xevm.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-ti811xevm.c	2014-08-07 14:42:24.000000000 -0600
@@ -0,0 +1,782 @@
+/*
+ * Code for TI811X EVM.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/at24.h>
+#include <linux/i2c/qt602240_ts.h>
+#include <linux/i2c/pcf857x.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/tps65910.h>
+#include <linux/sii9022a.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <plat/mcspi.h>
+#include <plat/irqs.h>
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/asp.h>
+#include <plat/usb.h>
+#include <plat/mmc.h>
+#include <plat/gpmc.h>
+#include <plat/nand.h>
+#include <plat/hdmi_lib.h>
+#include <mach/board-ti814x.h>
+
+#include "board-flash.h"
+#include "clock.h"
+#include "mux.h"
+#include "hsmmc.h"
+#include "control.h"
+#include "cm81xx.h"
+
+#define GPIO_TSC               31
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
+
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define board_mux     NULL
+#endif
+
+static struct omap2_hsmmc_info mmc[] = {
+	{
+		.mmc		= 1,
+		.caps		= MMC_CAP_4_BIT_DATA,
+		.gpio_cd	= GPIO_TO_PIN(1, 6), /* Dedicated pins for CD and WP */
+		.gpio_wp	= GPIO_TO_PIN(1, 3),
+		.ocr_mask	= MMC_VDD_33_34,
+	},
+	{}	/* Terminator */
+};
+
+/* Touchscreen platform data */
+static struct qt602240_platform_data ts_platform_data = {
+	.x_line		= 18,
+	.y_line		= 12,
+	.x_size		= 800,
+	.y_size		= 480,
+	.blen		= 0x01,
+	.threshold	= 30,
+	.voltage	= 2800000,
+	.orient		= QT602240_HORIZONTAL_FLIP,
+};
+
+static struct at24_platform_data eeprom_info = {
+	.byte_len       = (256*1024) / 8,
+	.page_size      = 64,
+	.flags          = AT24_FLAG_ADDR16,
+};
+
+static struct regulator_consumer_supply ti811xevm_mpu_supply =
+	REGULATOR_SUPPLY("mpu", "mpu.0");
+
+/*
+ * DM814x/AM387x (TI814x) devices have restriction that none of the supply to
+ * the device should be turned of.
+ *
+ * NOTE: To prevent turning off regulators not explicitly consumed by drivers
+ * depending on it, ensure following:
+ *	1) Set always_on = 1 for them OR
+ *	2) Avoid calling regulator_has_full_constraints()
+ *
+ * With just (2), there will be a warning about incomplete constraints.
+ * E.g., "regulator_init_complete: incomplete constraints, leaving LDO8 on"
+ *
+ * In either cases, the supply won't be disabled.
+ *
+ * We are taking approach (1).
+ */
+static struct regulator_init_data tps65911_reg_data[] = {
+	/* VRTC */
+	{
+		.constraints = {
+			.min_uV = 1800000,
+			.max_uV = 1800000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* VIO -VDDA 1.8V */
+	{
+		.constraints = {
+			.min_uV = 1500000,
+			.max_uV = 1500000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* VDD1 - MPU */
+	{
+		.constraints = {
+			.min_uV = 600000,
+			.max_uV = 1500000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.always_on = 1,
+		},
+		.num_consumer_supplies	= 1,
+		.consumer_supplies	= &ti811xevm_mpu_supply,
+	},
+
+	/* VDD2 - DSP */
+	{
+		.constraints = {
+			.min_uV = 600000,
+			.max_uV = 1500000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* VDDCtrl - CORE */
+	{
+		.constraints = {
+			.min_uV = 600000,
+			.max_uV = 1400000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO1 - VDAC */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO2 - HDMI */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO3 - GPIO 3.3V */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO4 - PLL 1.8V */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO5 - SPARE */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO6 - CDC */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO7 - SPARE */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+
+	/* LDO8 - USB 1.8V */
+	{
+		.constraints = {
+			.min_uV = 1100000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+						REGULATOR_CHANGE_STATUS,
+			.always_on = 1,
+		},
+	},
+};
+
+static struct tps65910_board __refdata tps65911_pdata = {
+	.irq				= 0,	/* No support currently */
+	.gpio_base			= 0,	/* No support currently */
+	.tps65910_pmic_init_data	= tps65911_reg_data,
+};
+
+
+
+
+#define GPIO_LCD_PWR_DOWN       13
+#define GPIO_LCD_SELECT         14
+
+static int setup_gpio_ioexp(struct i2c_client *client, int gpio_base,
+	unsigned ngpio, void *context) {
+	int ret = 0;
+	int gpio = gpio_base + GPIO_LCD_PWR_DOWN;
+	ret = gpio_request(gpio, "lcd_power");
+
+	if (ret) {
+		printk(KERN_ERR "%s: failed to request GPIO for LCD Power"
+			": %d\n", __func__, ret);
+	return ret;
+	}
+	gpio_export(gpio, true);
+	gpio_direction_output(gpio, 0);
+
+	gpio = gpio_base + GPIO_LCD_SELECT;
+	ret = gpio_request(gpio, "lcd_select");
+
+	if (ret) {
+		printk(KERN_ERR "%s: failed to request GPIO for LCD Select"
+			": %d\n", __func__, ret);
+	return ret;
+	}
+	gpio_export(gpio, true);
+	gpio_direction_output(gpio, 1);
+	return 0;
+}
+
+static struct pcf857x_platform_data io_expander_data = {
+	.gpio_base      = 6 * 32,
+	.setup          = setup_gpio_ioexp,
+};
+
+
+static struct sii9022a_platform_data sii9022a_pdata = {
+	.hdmi_hot_plug_gpio_intr_line	= 0,
+	.sync_mode			= 0,
+	.clk_edge			= 1,
+};
+
+
+static struct i2c_board_info __initdata ti814x_i2c_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("eeprom", 0x50),
+		.platform_data	= &eeprom_info,
+	},
+	{
+		I2C_BOARD_INFO("cpld", 0x23),
+	},
+	{
+		I2C_BOARD_INFO("tlv320aic3x", 0x18),
+	},
+	{
+		I2C_BOARD_INFO("pcf8575", 0x20),
+		.platform_data = &io_expander_data,
+	},
+	{
+		I2C_BOARD_INFO("tlc59108", 0x40),
+	},
+	{
+		I2C_BOARD_INFO("qt602240_ts", 0x4A),
+		.platform_data = &ts_platform_data,
+	},
+	{
+		I2C_BOARD_INFO("tps65911", 0x2D),
+		.platform_data = &tps65911_pdata,
+	},
+};
+
+static struct i2c_board_info __initdata ti811x_i2c_boardinfo1[] = {
+	{
+		I2C_BOARD_INFO("sii9022a", 0x39),
+		.platform_data = &sii9022a_pdata,
+	},
+};
+
+static const struct i2c_device_id pcf8575_video_id[] = {
+	{ "pcf8575_1_ti811x", 0 },
+	{ }
+};
+static struct i2c_client *pcf8575_1_client;
+static unsigned char pcf8575_1_port[2] = {0x4F, 0x7F};
+
+#define VPS_PCF8575_PIN0                (0x10)
+#define VPS_PCF8575_PIN1                (0x20)
+#define VPS_PCF8575_PIN2                (0x4)
+#define VPS_PCF8575_PIN3                (0x8)
+#define VPS_PCF8575_PIN4                (0x2)
+#define VPS_PCF8575_PIN5                (0x1)
+#define VPS_PCF8575_PIN6                (0x40)
+#define VPS_PCF8575_PIN7                (0x80)
+
+#define VPS_PCF8575_PIN10               (0x1)
+#define VPS_PCF8575_PIN11               (0x2)
+
+#define VPS_PCF8575_LCD_PWR_DW          (0x20)
+#define VPS_THS7375_MASK                (VPS_PCF8575_PIN10 | VPS_PCF8575_PIN11)
+
+#define VPS_THS7360_SD_MASK             (VPS_PCF8575_PIN2 | VPS_PCF8575_PIN5)
+
+#define VPS_THS7360_SF_MASK             (VPS_PCF8575_PIN0 |                    \
+					VPS_PCF8575_PIN1 |                    \
+					VPS_PCF8575_PIN3 |                    \
+					VPS_PCF8575_PIN4)
+int ti811x_pcf8575_ths7360_sd_enable(enum ti81xx_ths_filter_ctrl ctrl)
+{
+	struct i2c_msg msg = {
+		.addr = pcf8575_1_client->addr,
+		.flags = 0,
+		.len = 2,
+	};
+	pcf8575_1_port[0] &= ~VPS_THS7360_SD_MASK;
+	switch (ctrl) {
+	case TI81XX_THSFILTER_ENABLE_MODULE:
+		pcf8575_1_port[0] &= ~(VPS_THS7360_SD_MASK);
+		break;
+	case TI81XX_THSFILTER_BYPASS_MODULE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN2;
+		break;
+	case TI81XX_THSFILTER_DISABLE_MODULE:
+		pcf8575_1_port[0] |= VPS_THS7360_SD_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	msg.buf = pcf8575_1_port;
+	return i2c_transfer(pcf8575_1_client->adapter, &msg, 1);
+}
+
+int ti811x_pcf8575_ths7360_hd_enable(enum ti81xx_ths7360_sf_ctrl ctrl)
+{
+	int ret_val;
+	struct i2c_msg msg = {
+		.addr = pcf8575_1_client->addr,
+		.flags = 0,
+		.len = 2,
+	};
+
+	pcf8575_1_port[0] &= ~VPS_THS7360_SF_MASK;
+	switch (ctrl) {
+	case TI81XX_THS7360_DISABLE_SF:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN4;
+		break;
+	case TI81XX_THS7360_BYPASS_SF:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN3;
+		break;
+	case TI81XX_THS7360_SF_SD_MODE:
+		pcf8575_1_port[0] &= ~(VPS_THS7360_SF_MASK);
+		break;
+	case TI81XX_THS7360_SF_ED_MODE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN0;
+		break;
+	case TI81XX_THS7360_SF_HD_MODE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN1;
+		break;
+	case TI81XX_THS7360_SF_TRUE_HD_MODE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN0|VPS_PCF8575_PIN1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	msg.buf = pcf8575_1_port;
+
+	ret_val = i2c_transfer(pcf8575_1_client->adapter, &msg, 1);
+	return ret_val;
+
+}
+static int pcf8575_video_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	pcf8575_1_client = client;
+	return 0;
+}
+
+static int __devexit pcf8575_video_remove(struct i2c_client *client)
+{
+	pcf8575_1_client = NULL;
+	return 0;
+}
+
+static struct i2c_driver pcf8575_driver = {
+	.driver = {
+		.name   = "pcf8575_1_ti811x",
+	},
+	.probe          = pcf8575_video_probe,
+	.remove         = pcf8575_video_remove,
+	.id_table       = pcf8575_video_id,
+};
+
+int ti811x_pcf8575_init(void)
+{
+	i2c_add_driver(&pcf8575_driver);
+	return 0;
+}
+
+int ti811x_pcf8575_exit(void)
+{
+	i2c_del_driver(&pcf8575_driver);
+	return 0;
+}
+
+/* The following four functions are stubs - Added to avoid compilation
+ error, refer CQ SDOCM00094243 for more details, Need to remove this code once the
+ CQ is fixed */
+int ti814x_pcf8575_init(void)
+{
+	return 0;
+}
+int ti814x_pcf8575_exit(void)
+{
+	return 0;
+}
+int vps_ti814x_select_video_decoder(int vid_decoder_id)
+{
+	return 0;
+}
+int vps_ti814x_set_tvp7002_filter(enum fvid2_standard standard)
+{
+	return 0;
+}
+/* Stubs Ends*/
+
+static void __init ti814x_tsc_init(void)
+{
+	int error;
+
+	omap_mux_init_signal("mlb_clk.gpio0_31", TI814X_PULL_DIS | (1 << 18));
+
+	error = gpio_request(GPIO_TSC, "ts_irq");
+	if (error < 0) {
+		printk(KERN_ERR "%s: failed to request GPIO for TSC IRQ"
+			": %d\n", __func__, error);
+		return;
+	}
+
+	gpio_direction_input(GPIO_TSC);
+	ti814x_i2c_boardinfo[5].irq = gpio_to_irq(GPIO_TSC);
+
+	gpio_export(31, true);
+}
+
+static void __init ti814x_evm_i2c_init(void)
+{
+	/* There are 4 instances of I2C in TI814X but currently only one
+	 * instance is being used on the TI8148 EVM
+	 */
+	omap_register_i2c_bus(1, 100, ti814x_i2c_boardinfo,
+				ARRAY_SIZE(ti814x_i2c_boardinfo));
+	omap_register_i2c_bus(3, 100, ti811x_i2c_boardinfo1,
+				ARRAY_SIZE(ti811x_i2c_boardinfo1));
+
+}
+
+static u8 ti811x_iis_serializer_direction[] = {
+	TX_MODE,	RX_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,	INACTIVE_MODE,
+};
+
+static struct snd_platform_data ti811x_evm_snd_data = {
+	.tx_dma_offset	= 0x46800000,
+	.rx_dma_offset	= 0x46800000,
+	.op_mode	= DAVINCI_MCASP_IIS_MODE,
+	.num_serializer = ARRAY_SIZE(ti811x_iis_serializer_direction),
+	.tdm_slots	= 2,
+	.serial_dir	= ti811x_iis_serializer_direction,
+	.asp_chan_q	= EVENTQ_2,
+	.version	= MCASP_VERSION_2,
+	.txnumevt	= 1,
+	.rxnumevt	= 1,
+	/* McASP2_AHCLKX out to feed CODEC CLK*/
+	.clk_input_pin	= MCASP_AHCLKX_OUT,
+};
+
+/* NOR Flash partitions */
+static struct mtd_partition ti814x_evm_norflash_partitions[] = {
+	/* bootloader (U-Boot, etc) in first 5 sectors */
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 2 * SZ_128K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	/* bootloader params in the next 1 sectors */
+	{
+		.name		= "env",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_128K,
+		.mask_flags	= 0,
+	},
+	/* kernel */
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 2 * SZ_2M,
+		.mask_flags	= 0
+	},
+	/* file system */
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 25 * SZ_2M,
+		.mask_flags	= 0
+	},
+	/* reserved */
+	{
+		.name		= "reserved",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0
+	}
+};
+
+/* NAND flash information */
+static struct mtd_partition ti814x_nand_partitions[] = {
+/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name           = "U-Boot-min",
+		.offset         = 0,    /* Offset = 0x0 */
+		.size           = SZ_128K,
+	},
+	{
+		.name           = "U-Boot",
+		.offset         = MTDPART_OFS_APPEND,/* Offset = 0x0 + 128K */
+		.size           = 18 * SZ_128K,
+	},
+	{
+		.name           = "U-Boot Env",
+		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0x260000 */
+		.size           = 1 * SZ_128K,
+	},
+	{
+		.name           = "Kernel",
+		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0x280000 */
+		.size           = 34 * SZ_128K,
+	},
+	{
+		.name           = "File System",
+		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0x6C0000 */
+		.size           = 1601 * SZ_128K,
+	},
+	{
+		.name           = "Reserved",
+		.offset         = MTDPART_OFS_APPEND,   /* Offset = 0xCEE0000 */
+		.size           = MTDPART_SIZ_FULL,
+	},
+};
+
+/* SPI fLash information */
+struct mtd_partition ti811x_spi_partitions[] = {
+	/* All the partition sizes are listed in terms of erase size */
+	{
+		.name		= "U-Boot-min",
+		.offset		= 0,	/* Offset = 0x0 */
+		.size		= 32 * SZ_4K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	{
+		.name		= "U-Boot",
+		.offset		= MTDPART_OFS_APPEND, /* 0x0 + (32*4K) */
+		.size		= 64 * SZ_4K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	{
+		.name		= "U-Boot Env",
+		.offset		= MTDPART_OFS_APPEND, /* 0x40000 + (32*4K) */
+		.size		= 2 * SZ_4K,
+	},
+	{
+		.name		= "Kernel",
+		.offset		= MTDPART_OFS_APPEND, /* 0x42000 + (32*4K) */
+		.size		= 640 * SZ_4K,
+	},
+	{
+		.name		= "File System",
+		.offset		= MTDPART_OFS_APPEND, /* 0x2C2000 + (32*4K) */
+		.size		= MTDPART_SIZ_FULL, /* size ~= 1.1 MiB */
+	}
+};
+
+const struct flash_platform_data ti811x_spi_flash = {
+	.type		= "w25x32",
+	.name		= "spi_flash",
+	.parts		= ti811x_spi_partitions,
+	.nr_parts	= ARRAY_SIZE(ti811x_spi_partitions),
+};
+
+struct spi_board_info __initdata ti811x_spi_slave_info[] = {
+	{
+		.modalias	= "m25p80",
+		.platform_data	= &ti811x_spi_flash,
+		.irq		= -1,
+		.max_speed_hz	= 75000000,
+		.bus_num	= 1,
+		.chip_select	= 0,
+	},
+};
+
+void __init ti811x_spi_init(void)
+{
+	spi_register_board_info(ti811x_spi_slave_info,
+				ARRAY_SIZE(ti811x_spi_slave_info));
+}
+
+static struct omap_musb_board_data musb_board_data = {
+	.interface_type		= MUSB_INTERFACE_ULPI,
+#ifdef CONFIG_USB_MUSB_OTG
+	.mode           = MUSB_OTG,
+#elif defined(CONFIG_USB_MUSB_HDRC_HCD)
+	.mode           = MUSB_HOST,
+#elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
+	.mode           = MUSB_PERIPHERAL,
+#endif
+	.power		= 500,
+	.instances	= 1,
+};
+
+static void __init ti811x_evm_init_irq(void)
+{
+	omap2_init_common_infrastructure();
+	omap2_init_common_devices(NULL, NULL);
+	omap_init_irq();
+	gpmc_init();
+}
+
+#ifdef CONFIG_SND_SOC_TI81XX_HDMI
+static struct snd_hdmi_platform_data ti811x_snd_hdmi_pdata = {
+	.dma_addr = TI81xx_HDMI_WP + HDMI_WP_AUDIO_DATA,
+	.channel = 53,
+	.data_type = 4,
+	.acnt = 4,
+	.fifo_level = 0x20,
+};
+
+static struct platform_device ti811x_hdmi_audio_device = {
+	.name   = "hdmi-dai",
+	.id     = -1,
+	.dev = {
+		.platform_data = &ti811x_snd_hdmi_pdata,
+	}
+};
+
+static struct platform_device ti811x_hdmi_codec_device = {
+	.name   = "hdmi-dummy-codec",
+	.id     = -1,
+};
+
+static struct platform_device *ti811x_devices[] __initdata = {
+	&ti811x_hdmi_audio_device,
+	&ti811x_hdmi_codec_device,
+};
+#endif
+
+static void ti811x_interrupt_xbar_config(void)
+{
+	u32 tmp;
+
+	/* Configure A8 interrupt mux 95_92 to receive GPIO4/5 interrupts */
+	tmp = __raw_readl(TI811X_A8_INT_MUX_95_92);
+	__raw_writel(0x1F1E1D1C, TI811X_A8_INT_MUX_95_92);
+	tmp = __raw_readl(TI811X_A8_INT_MUX_95_92);
+
+}
+
+static void __init ti811x_evm_init(void)
+{
+	int bw; /* bus-width */
+
+	ti814x_mux_init(board_mux);
+	omap_serial_init();
+	ti814x_tsc_init();
+	ti814x_evm_i2c_init();
+	ti81xx_register_mcasp(0, &ti811x_evm_snd_data);
+
+	omap2_hsmmc_init(mmc);
+
+	/* nand initialisation */
+	board_nand_init(ti814x_nand_partitions,
+	ARRAY_SIZE(ti814x_nand_partitions), 0, NAND_OMAP_BUS_16);
+
+	/* initialize usb */
+	usb_musb_init(&musb_board_data);
+
+	ti811x_spi_init();
+#ifdef CONFIG_SND_SOC_TI81XX_HDMI
+	platform_add_devices(ti811x_devices, ARRAY_SIZE(ti811x_devices));
+#endif
+	regulator_use_dummy_regulator();
+	board_nor_init(ti814x_evm_norflash_partitions,
+		ARRAY_SIZE(ti814x_evm_norflash_partitions), 0);
+
+	ti811x_interrupt_xbar_config();
+
+}
+
+static void __init ti811x_evm_map_io(void)
+{
+	omap2_set_globals_ti816x();
+	ti81xx_map_common_io();
+}
+
+MACHINE_START(TI811XEVM, "ti811xevm")
+	/* Maintainer: Texas Instruments */
+	.boot_params	= 0x80000100,
+	.map_io		= ti811x_evm_map_io,
+	.reserve         = ti81xx_reserve,
+	.init_irq	= ti811x_evm_init_irq,
+	.init_machine	= ti811x_evm_init,
+	.timer		= &omap_timer,
+MACHINE_END
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-ti8168evm.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-ti8168evm.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-ti8168evm.c	2014-08-07 14:42:24.000000000 -0600
@@ -28,6 +28,7 @@
 #include <linux/gpio.h>
 #include <linux/regulator/machine.h>
 #include <linux/regulator/gpio-regulator.h>
+#include <linux/sii9022a.h>
 #include <linux/clk.h>
 
 #include <mach/hardware.h>
@@ -248,6 +249,12 @@
 static inline void ti816x_gpio_vr_init(void) {}
 #endif
 
+static struct sii9022a_platform_data sii9022a_pdata = {
+	.hdmi_hot_plug_gpio_intr_line   = 0,
+	.sync_mode                      = 0,
+	.clk_edge                       = 0,
+};
+
 static struct i2c_board_info __initdata ti816x_i2c_boardinfo0[] = {
 	{
 		I2C_BOARD_INFO("eeprom", 0x50),
@@ -271,6 +278,7 @@
 	},
 	{
 		I2C_BOARD_INFO("sii9022a", 0x39),
+		.platform_data	= &sii9022a_pdata,
 	},
 	{
 		I2C_BOARD_INFO("pcf8575_1", 0x21),
@@ -468,7 +476,7 @@
 #endif
 }
 EXPORT_SYMBOL(vps_ti816x_set_tvp7002_filter);
-int pcf8575_ths7375_enable(enum ti816x_ths_filter_ctrl ctrl)
+int pcf8575_ths7375_enable(enum ti81xx_ths_filter_ctrl ctrl)
 {
 	struct i2c_msg msg = {
 			.addr = pcf8575_1_client->addr,
@@ -482,9 +490,8 @@
 
 	return i2c_transfer(pcf8575_1_client->adapter, &msg, 1);
 }
-EXPORT_SYMBOL(pcf8575_ths7375_enable);
 
-int pcf8575_ths7360_sd_enable(enum ti816x_ths_filter_ctrl ctrl)
+int pcf8575_ths7360_sd_enable(enum ti81xx_ths_filter_ctrl ctrl)
 {
 	struct i2c_msg msg = {
 		.addr = pcf8575_1_client->addr,
@@ -493,13 +500,13 @@
 	};
 	pcf8575_1_port[0] &= ~VPS_THS7360_SD_MASK;
 	switch (ctrl) {
-	case TI816X_THSFILTER_ENABLE_MODULE:
+	case TI81XX_THSFILTER_ENABLE_MODULE:
 		pcf8575_1_port[0] &= ~(VPS_THS7360_SD_MASK);
 		break;
-	case TI816X_THSFILTER_BYPASS_MODULE:
+	case TI81XX_THSFILTER_BYPASS_MODULE:
 		pcf8575_1_port[0] |= VPS_PCF8575_PIN2;
 		break;
-	case TI816X_THSFILTER_DISABLE_MODULE:
+	case TI81XX_THSFILTER_DISABLE_MODULE:
 		pcf8575_1_port[0] |= VPS_THS7360_SD_MASK;
 		break;
 	default:
@@ -509,9 +516,8 @@
 	msg.buf = pcf8575_1_port;
 	return i2c_transfer(pcf8575_1_client->adapter, &msg, 1);
 }
-EXPORT_SYMBOL(pcf8575_ths7360_sd_enable);
 
-int pcf8575_ths7360_hd_enable(enum ti816x_ths7360_sf_ctrl ctrl)
+int pcf8575_ths7360_hd_enable(enum ti81xx_ths7360_sf_ctrl ctrl)
 {
 	int ret_val;
 	struct i2c_msg msg = {
@@ -522,22 +528,22 @@
 
 	pcf8575_1_port[0] &= ~VPS_THS7360_SF_MASK;
 	switch (ctrl) {
-	case TI816X_THS7360_DISABLE_SF:
+	case TI81XX_THS7360_DISABLE_SF:
 		pcf8575_1_port[0] |= VPS_PCF8575_PIN4;
 		break;
-	case TI816X_THS7360_BYPASS_SF:
+	case TI81XX_THS7360_BYPASS_SF:
 		pcf8575_1_port[0] |= VPS_PCF8575_PIN3;
 		break;
-	case TI816X_THS7360_SF_SD_MODE:
+	case TI81XX_THS7360_SF_SD_MODE:
 		pcf8575_1_port[0] &= ~(VPS_THS7360_SF_MASK);
 		break;
-	case TI816X_THS7360_SF_ED_MODE:
+	case TI81XX_THS7360_SF_ED_MODE:
 		pcf8575_1_port[0] |= VPS_PCF8575_PIN0;
 		break;
-	case TI816X_THS7360_SF_HD_MODE:
+	case TI81XX_THS7360_SF_HD_MODE:
 		pcf8575_1_port[0] |= VPS_PCF8575_PIN1;
 		break;
-	case TI816X_THS7360_SF_TRUE_HD_MODE:
+	case TI81XX_THS7360_SF_TRUE_HD_MODE:
 		pcf8575_1_port[0] |= VPS_PCF8575_PIN0|VPS_PCF8575_PIN1;
 		break;
 	default:
@@ -549,7 +555,6 @@
 	return ret_val;
 
 }
-EXPORT_SYMBOL(pcf8575_ths7360_hd_enable);
 
 static int pcf8575_video_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
@@ -571,7 +576,45 @@
 	pcf8575_2_client = NULL;
 	return 0;
 }
+static const struct i2c_device_id pcf8575_cir_id[] = {
+	{ "IO Expander", 0 },
+	{ }
+};
+static struct i2c_client *pcf8575_cir_client;
+static unsigned char pcf8575_cir_port[2] = {0, 0xbf};
+static int pcf8575_cir_enable(void);
+static int pcf8575_cir_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	pcf8575_cir_client = client;
+	pcf8575_cir_enable();
+	return 0;
+}
+
+static int __devexit pcf8575_cir_remove(struct i2c_client *client)
+{
+	pcf8575_cir_client = NULL;
+	return 0;
+}
+static struct i2c_driver pcf8575_cir_driver = {
+	.driver = {
+		.name	= "IO Expander",
+	},
+	.probe		= pcf8575_cir_probe,
+	.remove		= pcf8575_cir_remove,
+	.id_table		= pcf8575_cir_id,
+};
+int ti816x_pcf8575_cir_init(void)
+{
+	i2c_add_driver(&pcf8575_cir_driver);
+	return 0;
+}
 
+int ti816x_pcf8575_cir_exit(void)
+{
+	i2c_del_driver(&pcf8575_cir_driver);
+	return 0;
+}
 static const struct i2c_device_id pcf8575_video_id[] = {
 	{ "pcf8575_1", 0 },
 	{ }
@@ -591,20 +634,43 @@
 	i2c_add_driver(&pcf8575_driver);
 	return 0;
 }
-EXPORT_SYMBOL(ti816x_pcf8575_init);
 
 int ti816x_pcf8575_exit(void)
 {
 	i2c_del_driver(&pcf8575_driver);
 	return 0;
 }
-EXPORT_SYMBOL(ti816x_pcf8575_exit);
+
 /* FIX ME: Check on the Bit Value */
 
 #define TI816X_EVM_CIR_UART BIT(5)
+#define pcf8575_IR_REMOTE_OFF (0x40)
 
 static struct i2c_client *cpld_reg0_client;
 
+int pcf8575_cir_enable(void)
+{
+	int ret = 0;
+	struct i2c_msg msg = {
+		.addr = pcf8575_cir_client->addr,
+		.flags = 1,
+		.len = 2,
+	};
+	msg.buf = pcf8575_cir_port;
+	ret = i2c_transfer(pcf8575_cir_client->adapter, &msg, 1);
+	msg.flags = 0;
+	if (ret < 0)
+		printk(KERN_ERR "I2C: Read failed at %s %d with error code: %d\n",
+			__func__, __LINE__, ret);
+	pcf8575_cir_port[0] = msg.buf[0];
+	pcf8575_cir_port[1] = (msg.buf[1] & ~(pcf8575_IR_REMOTE_OFF));
+	ret = i2c_transfer(pcf8575_cir_client->adapter, &msg, 1);
+	if (ret < 0)
+		printk(KERN_ERR "I2C: Transfer failed at %s %d with error code: %d\n",
+			__func__, __LINE__, ret);
+	return ret;
+
+}
 /* CPLD Register 0 Client: used for I/O Control */
 static int cpld_reg0_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
@@ -728,8 +794,8 @@
 	.serial_dir	= ti8168_iis_serializer_direction,
 	.asp_chan_q	= EVENTQ_2,
 	.version	= MCASP_VERSION_2,
-	.txnumevt	= 1,
-	.rxnumevt	= 1,
+	.txnumevt	= 64,
+	.rxnumevt	= 64,
 };
 
 static struct omap_musb_board_data musb_board_data = {
@@ -779,6 +845,7 @@
 static struct snd_hdmi_platform_data ti8168_snd_hdmi_pdata = {
 	.dma_addr = TI81xx_HDMI_WP + HDMI_WP_AUDIO_DATA,
 	.channel = 53,
+	.dma_chan_q = EVENTQ_0,
 	.data_type = 4,
 	.acnt = 4,
 	.fifo_level = 0x20,
@@ -848,18 +915,8 @@
 	usb_musb_init(&musb_board_data);
 
 	/* nand initialisation */
-	if (cpu_is_ti81xx()) {
-		u32 *control_status = TI81XX_CTRL_REGADDR(0x40);
-		if (*control_status & (1<<16))
-			bw = 2;	/*16-bit nand if BTMODE BW pin on board is ON*/
-		else
-			bw = 0;	/*8-bit nand if BTMODE BW pin on board is OFF*/
-
-		board_nand_init(ti816x_nand_partitions,
-			ARRAY_SIZE(ti816x_nand_partitions), 0, bw);
-	} else
-		board_nand_init(ti816x_nand_partitions,
-		ARRAY_SIZE(ti816x_nand_partitions), 0, NAND_BUSWIDTH_16);
+	board_nand_init(ti816x_nand_partitions,
+	ARRAY_SIZE(ti816x_nand_partitions), 0, NAND_OMAP_BUS_16);
 
 	omap2_hsmmc_init(mmc);
 	board_nor_init(ti816x_evm_norflash_partitions,
@@ -871,6 +928,7 @@
 #endif
 	regulator_has_full_constraints();
 	regulator_use_dummy_regulator();
+	ti816x_pcf8575_cir_init();
 }
 
 static int __init ti8168_evm_gpio_setup(void)
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-zoom.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-zoom.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-zoom.c	2014-08-07 14:42:24.000000000 -0600
@@ -130,7 +130,7 @@
 	}
 
 	board_nand_init(zoom_nand_partitions, ARRAY_SIZE(zoom_nand_partitions),
-						ZOOM_NAND_CS, NAND_BUSWIDTH_16);
+						ZOOM_NAND_CS, NAND_OMAP_BUS_16);
 	zoom_debugboard_init();
 	zoom_peripherals_init();
 }
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock.c	2014-08-07 14:42:24.000000000 -0600
@@ -33,7 +33,7 @@
 #include "cm-regbits-24xx.h"
 #include "cm-regbits-34xx.h"
 
-u8 cpu_mask;
+u16 cpu_mask;
 
 /*
  * OMAP2+ specific clock functions
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock.h	2014-08-07 14:42:24.000000000 -0600
@@ -176,7 +176,7 @@
 			       const char *core_ck_name,
 			       const char *mpu_ck_name);
 
-extern u8 cpu_mask;
+extern u16 cpu_mask;
 
 extern const struct clkops clkops_omap2_dflt_wait;
 extern const struct clkops clkops_dummy;
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock814x_data.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock814x_data.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clock814x_data.c	2014-08-07 14:42:24.000000000 -0600
@@ -30,10 +30,8 @@
 #include "prm.h"
 
 /* Maximum multiplier divider values for Modena ADPLL */
-#define TI814X_MODENA_ADPLLS_MAX_MULT	2047
 #define TI814X_MODENA_ADPLLS_MAX_DIV	127
 #define TI814X_MODENA_ADPLLS_FIX_N	1
-#define TI814X_ADPLLJ_MAX_MULT		4095
 #define TI814X_ADPLLJ_MAX_DIV		255
 #define TI814X_ADPLLJ_FIX_N		19
 #define TI814X_ADPLL_MIN_DIV		0
@@ -42,6 +40,7 @@
 #define TI814X_ADPLL_POST_DIV_M2_4	4
 #define TI814X_ADPLL_POST_DIV_M2_5	5
 
+
 /*
  * Notes:
  *
@@ -75,13 +74,23 @@
  */
 
 /************************** Dummy Clocks *********************************/
+/* On chip 32K RC Oscillator */
 static struct clk rcosc_32k_ck = {
 	.name		= "rcosc_32k_ck",
 	.ops		= &clkops_null,
 	.rate		= 32768,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
+};
+
+/* TI811X has an onchip 32K oscillator */
+static struct clk osc_32k_ck = {
+	.name		= "osc_32k_ck",
+	.ops		= &clkops_null,
+	.rate		= 32768,
+	.flags		= RATE_IN_TI811X,
 };
 
+/* External 32K input for RTC, gpio, etc */
 static struct clk sys_32k_clkin_ck = {
 	.name		= "sys_32k_clkin_ck",
 	.ops		= &clkops_null,
@@ -89,63 +98,71 @@
 	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
 };
 
+/* External tclk input for TIMERS, rate must be updated
+based on what is connected to input pin (TCLKIN) */
 static struct clk tclkin_ck = {
 	.name		= "tclkin_ck",
 	.ops		= &clkops_null,
-	.rate		= 32768,	/* TODO: Check */
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.rate		= 32768,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
+/* Main clock source: 20 MHz */
 static struct clk osc0_clkin_ck = {
 	.name		= "osc0_clkin_ck",
 	.ops		= &clkops_null,
 	.rate		= 20000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
+/* Additional clock source */
 static struct clk osc1_clkin_ck = {
 	.name		= "osc1_clkin_ck",
 	.ops		= &clkops_null,
 	.rate		= 22579000, /* Typically at 27M or 22.579MHz */
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
+/* Fixed divider brings down rate from 20 MHz to 32K */
 static struct clk rtc_divider_ck = {
 	.name		= "rtc_divider_ck",
 	.parent		= &osc0_clkin_ck,
 	.ops		= &clkops_null,
 	.rate		= 32768,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
-static struct clk osc1_x1_ck = {
-	.name		= "osc1_x1_ck",
+/* OSC1 External Input clock, rate must be updated based on brd schematics */
+static struct clk osc1_xi_ck = {
+	.name		= "osc1_xi_ck",
 	.ops		= &clkops_null,
-	.rate		= 20000000, /* ?? */
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.rate		= 20000000,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
+/* External Ref Input clocks, rate must be updated based on brd schematics */
 static struct clk xref0_ck = {
 	.name		= "xref0_ck",
 	.ops		= &clkops_null,
 	.rate		= 27000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 static struct clk xref1_ck = {
 	.name		= "xref1_ck",
 	.ops		= &clkops_null,
 	.rate		= 27000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 static struct clk xref2_ck = {
 	.name		= "xref2_ck",
 	.ops		= &clkops_null,
 	.rate		= 27000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
+/* Transport Input clocks, rate must be updated based on brd schematics */
 static struct clk tsi0_dck_ck = {
 	.name		= "tsi0_dck_ck",
 	.ops		= &clkops_null,
@@ -160,125 +177,126 @@
 	.flags		= RATE_IN_TI814X,
 };
 
+/* External Input for RMII, rate must be updated based on actual connetcion */
 static struct clk external_ck = {
 	.name		= "external_ck",
 	.ops		= &clkops_null,
 	.rate		= 50000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
-/* ATL dummy output clocks  */
+/* ATL dummy output clocks, rate must be updated based on actual connetcion */
 static struct clk atl0_clk_ck = {
 	.name		= "atl0_clk_ck",
 	.ops		= &clkops_null,
-	.rate		= 22579000, /* ?? */
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.rate		= 22579000,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 static struct clk atl1_clk_ck = {
 	.name		= "atl1_clk_ck",
 	.ops		= &clkops_null,
 	.rate		= 22579000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 static struct clk atl2_clk_ck = {
 	.name		= "atl2_clk_ck",
 	.ops		= &clkops_null,
 	.rate		= 22579000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 static struct clk atl3_clk_ck = {
 	.name		= "atl3_clk_ck",
 	.ops		= &clkops_null,
 	.rate		= 22579000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 /********************* MUX Inputs ************************************/
 static const struct clksel_rate div_1_0_rates[] = {
-	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_1_rates[] = {
-	{ .div = 1, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_2_rates[] = {
-	{ .div = 1, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_3_rates[] = {
-	{ .div = 1, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_4_rates[] = {
-	{ .div = 1, .val = 4, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 4, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_5_rates[] = {
-	{ .div = 1, .val = 5, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 5, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_6_rates[] = {
-	{ .div = 1, .val = 6, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 6, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_7_rates[] = {
-	{ .div = 1, .val = 7, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 7, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_8_rates[] = {
-	{ .div = 1, .val = 8, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 8, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_9_rates[] = {
-	{ .div = 1, .val = 9, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 9, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div_1_10_rates[] = {
-	{ .div = 1, .val = 10, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 10, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 /************************ Clock divisions ********************************/
 /* Divide by 8 clock rates with default clock is 1/1*/
 static const struct clksel_rate div8_rates[] = {
-	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 2, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 3, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 4, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 5, .val = 4, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 6, .val = 5, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 7, .val = 6, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 8, .val = 7, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 4, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 5, .val = 4, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 6, .val = 5, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 7, .val = 6, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 8, .val = 7, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 /* Divide by 8 clock rates with default clock is 1/1*/
 static const struct clksel_rate div5_prcmckout_rates[] = {
-	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 2, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 4, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 8, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 16, .val = 4, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 4, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 8, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 16, .val = 4, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
 static const struct clksel_rate div2_sysclk6_rates[] = {
-	{ .div = 2, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 4, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
+	{ .div = 2, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 4, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 
@@ -286,10 +304,10 @@
  * reset value of the register is 0x3 which is unused so re-program it to div 1
  */
 static const struct clksel_rate div4_b3c1_rates[] = {
-	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 2, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 22, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 },
-	{ .div = 1, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 }, /* Hack for default val in reg */
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 22, .val = 2, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
+	{ .div = 1, .val = 3, .flags = RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X },
 	{ .div = 0 },
 };
 /************************** Clocking Started *********************************/
@@ -346,7 +364,7 @@
 	.recalc		= &followparent_recalc,
 };
 
-/*********************************Main Module*********************************/
+/* TSC_ADC clock */
 static struct clk adc_clk_ck = {
 	.name		= "adc_clk_ck",
 	.parent		= &osc0_clkin_ck,
@@ -354,6 +372,7 @@
 	.recalc		= &followparent_recalc,
 };
 
+/*********************************Main Module*********************************/
 /* ARM DPLL/Modena/Sabertooth */
 static const struct clksel arm_dpll_mux_sel[] = {
 	{ .parent = &osc0_clkin_ck, .rates = div_1_0_rates },
@@ -376,35 +395,14 @@
 static struct dpll_data arm_dpll_dd = {
 	.dpll_id	= TI814X_ARM_DPLL_ID,
 	.flags		= TI814X_ADPLL_LS_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &arm_dpll_clkin_ck,
 	.clk_ref	= &arm_dpll_clkin_ck,
 	.pre_div_n	= TI814X_MODENA_ADPLLS_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
 	.base		= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.auto_recal_bit	= TI814X_EN_MODENA_ADPLL_DRIFTGUARD_SHIFT,
-	.idlest_reg	= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_MODENA_ADPLLS_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLLS_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLLS_N_DIV_MASK,
-	.pre_div_n	= TI814X_MODENA_ADPLLS_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.stop_mode_bit	= TI814X_EN_MODENA_ADPLL_STOPMODE_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(MODENA_PLL_BASE, ADPLLJ_TENDIV),
 };
 
 /* ARM_DPLL clock out(DPLL out) */
@@ -432,34 +430,14 @@
 /* DSP_PLL ADPLLLJ data */
 static struct dpll_data dsp_dpll_dd  = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &osc0_clkin_ck,
 	.clk_ref	= &osc0_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
 	.base		= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier = TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance = DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(DSP_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* DSP_DPLL for clock1(in)*/
@@ -487,34 +465,14 @@
 /* DPLL_SGX ADPLLLJ data */
 static struct dpll_data sgx_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &osc0_clkin_ck,
 	.clk_ref	= &osc0_clkin_ck,
 	.pre_div_n      = TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
 	.base		= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier = TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n      = TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(SGX_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* GFX_DPLL for clock3(PRCM in) */
@@ -523,8 +481,6 @@
 	.ops		= &clkops_ti814x_dpll_ops,
 	.parent		= &osc0_clkin_ck,
 	.dpll_data	= &sgx_dpll_dd,
-	.round_rate	= &ti814x_dpll_round_rate,
-	.set_rate	= &ti814x_dpll_set_rate,
 	.clkdm_name	= "sgx_clkdm",
 	.recalc		= &ti814x_dpll_recalc,
 	.round_rate	= &ti814x_dpll_round_rate,
@@ -582,34 +538,14 @@
 /* DPLL_IVA (HDVICP) ADPLLLJ data */
 static struct dpll_data hdvicp_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &osc0_clkin_ck,
 	.clk_ref	= &osc0_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
 	.base		= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(IVA_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* HDVICP_DPLL for clock3(PRCM in) */
@@ -673,34 +609,14 @@
 
 static struct dpll_data l3_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &l3_dpll_clkin_ck,
 	.clk_ref	= &l3_dpll_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_4,
 	.base		= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_4,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(L3_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* L3 DPLL for clock4(PRCM in) */
@@ -781,7 +697,7 @@
 	.ops		= &clkops_ti81xx_dflt_wait,
 	.enable_reg	= TI81XX_CM_ALWON_TPTC0_CLKCTRL,
 	.enable_bit	= TI81XX_MODULEMODE_SWCTRL,
-	.clkdm_name	= "alwon_l3_med_clkdm",
+	.clkdm_name	= "alwon_l3_fast_clkdm",
 	.recalc		= &followparent_recalc,
 };
 
@@ -895,7 +811,7 @@
 	.ops		= &clkops_omap2_dflt,
 	.enable_reg	= TI81XX_CM_ALWON_SECSS_CLKCTRL,
 	.enable_bit	= TI81XX_MODULEMODE_SWCTRL,
-	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.clkdm_name	= "alwon_l3_med_clkdm",
 	.recalc		= &followparent_recalc,
 };
 
@@ -947,7 +863,7 @@
 	.ops		= &clkops_ti81xx_dflt_wait,
 	.enable_reg	= TI814X_CM_ALWON_VCP_CLKCTRL,
 	.enable_bit	= TI81XX_MODULEMODE_SWCTRL,
-	.clkdm_name	= "alwon_l3_med_clkdm",
+	.clkdm_name	= "alwon_l3_fast_clkdm",
 	.recalc		= &followparent_recalc,
 };
 
@@ -1359,7 +1275,7 @@
 	.recalc		= &followparent_recalc,
 };
 
-/* PRCM Clock(final) */
+/* GPIO4 Clock(final) - same as GPIO1 */
 static struct clk gpio5_ick = {
 	.name		= "gpio5_ick",
 	.parent		= &gpio234_ick,
@@ -1376,6 +1292,8 @@
 	.clkdm_name	= "alwon_l3_slow_clkdm",
 	.recalc		= &followparent_recalc,
 };
+
+/* PRCM Clock(final) */
 static struct clk prcm_ick = {
 	.name		= "prcm_ick",
 	.parent		= &sysclk6_ck,
@@ -1534,6 +1452,8 @@
 	.clkdm_name	= "alwon_l3_slow_clkdm",
 	.recalc		= &followparent_recalc,
 };
+
+/* VLYNQ clock */
 static struct clk vlynq_ick = {
 	.name		= "vlynq_ick",
 	.parent		= &sysclk6_ck,
@@ -1543,6 +1463,7 @@
 	.recalc		= &followparent_recalc,
 };
 
+
 /* SmartReflex 0 mclk Clock(final) */
 static struct clk sr1_ick = {
 	.name		= "sr1_ick",
@@ -1703,34 +1624,14 @@
 /* DPLL_ISS ADPLLLJ data */
 static struct dpll_data iss_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &osc0_clkin_ck,
 	.clk_ref	= &osc0_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
 	.base		= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(ISS_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* ISP_DPLL for clock1(in)*/
@@ -1773,7 +1674,7 @@
 	.name		= "tppss_tso_ick",
 	.parent		= &iss_dpll_ck,
 	.ops		= &clkops_null,
-	.clkdm_name	= "iss_clkdm",
+	.clkdm_name	= "alwon_l3_slow_clkdm",
 	.recalc		= &followparent_recalc,
 	.set_rate	= &ti814x_clksel_set_rate,
 };
@@ -1783,7 +1684,7 @@
 	.name		= "iss_dpll_d2_ck",
 	.parent		= &iss_dpll_ck,
 	.ops		= &clkops_null,
-	.clkdm_name	= "iss_clkdm",
+	.clkdm_name	= "alwon_l3_slow_clkdm",
 	.fixed_div	= 2,
 	.recalc		= &omap_fixed_divisor_recalc,
 };
@@ -1802,33 +1703,14 @@
 /* DPLL_DSS (HDVPSS) ADPLLLJ data */
 static struct dpll_data hdvpss_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &osc0_clkin_ck,
 	.clk_ref	= &osc0_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_4,
 	.base		= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_4,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(DSS_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* HDVPSS_DPLL for clock1(in)*/
@@ -1923,34 +1805,14 @@
 /* DPLL_USB ADPLLLJ data */
 static struct dpll_data usb_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &usb_dpll_clkin_ck,
 	.clk_ref	= &usb_dpll_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
 	.base		= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(USB_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* USB DPLL Clock */
@@ -2322,34 +2184,14 @@
 static struct dpll_data ddr_dpll_dd = {
 	.dpll_id	= TI814X_DDR_DPLL_ID,
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &ddr_dpll_clkin_ck,
 	.clk_ref	= &ddr_dpll_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
 	.base		= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(DDR_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* DDR DPLL Clock */
@@ -2474,34 +2316,14 @@
 /* DPLL_VIDEO0 ADPLLLJ data */
 static struct dpll_data video0_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &video0_dpll_clkin_ck,
 	.clk_ref	= &video0_dpll_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
 	.base		= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(VIDEO0_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* Video0 DPLL clock(DPLL out) */
@@ -2537,34 +2359,14 @@
 /* DPLL_VIDEO1 ADPLLLJ data */
 static struct dpll_data video1_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &video1_dpll_clkin_ck,
 	.clk_ref	= &video1_dpll_clkin_ck,
 	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
 	.base		= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 			(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier	= TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance	= DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n	= TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(VIDEO1_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* Video1 DPLL clock (DPLL out) */
@@ -2600,34 +2402,14 @@
 /* DPLL_HDMI ADPLLLJ data */
 static struct dpll_data hdmi_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &hdmi_dpll_clkin_ck,
 	.clk_ref	= &hdmi_dpll_clkin_ck,
 	.pre_div_n      = TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
 	.base		= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 				(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier = TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance = DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n      = TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(HDMI_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* HDMI DPLL for clock2 (mux in) */
@@ -2803,7 +2585,7 @@
 	.recalc		= &followparent_recalc,
 };
 
-/* HDVENC A MUX clock sel */
+/* DTC0 logic clock */
 static struct clk dtc0_logic_ck = {
 	.name		= "dtc0_logic_ck",
 	.parent		= &hd_venc_g_ck,
@@ -2820,6 +2602,8 @@
 	.clkdm_name	= "alwon_l3_slow_clkdm",
 	.recalc		= &followparent_recalc,
 };
+
+/* HDVENC A MUX clock sel */
 static const struct clksel hd_venc_a_mux_sel[] = {
 	{ .parent = &hdmi_dpll_muxout_ck, .rates = div_1_0_rates },
 	{ .parent = &video1_dpll_ck, .rates = div_1_1_rates },
@@ -2946,34 +2730,14 @@
 /* DPLL_AUDIO ADPLLLJ data */
 static struct dpll_data audio_dpll_dd = {
 	.flags		= TI814X_ADPLL_LJ_TYPE,
-	.mult_div1_reg	= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_MN2DIV),
-	.mult_mask	= TI814X_ADPLL_M_MULT_MASK,
-	.div1_mask	= TI814X_ADPLL_N2_DIV_MASK,
 	.clk_bypass	= &audio_dpll_clkin_ck,
 	.clk_ref	= &audio_dpll_clkin_ck,
 	.pre_div_n      = TI814X_ADPLLJ_FIX_N,
 	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
 	.base		= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_BASE),
 	.control_reg	= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_CLKCTRL),
-	.enable_mask	= TI814X_EN_ADPLL_CLKOUT_MASK,
 	.modes		= (1 << ADPLL_LOW_POWER_BYPASS) | (1 << ADPLL_LOCKED) |
 				(1 << ADPLL_LOW_POWER_STOP),
-	.idlest_reg	= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_STATUS),
-	.idlest_mask	= TI814X_ST_ADPLL_MASK,
-	.max_multiplier = TI814X_ADPLLJ_MAX_MULT,
-	.rate_tolerance = DEFAULT_DPLL_RATE_TOLERANCE,
-	.div_m2n_reg	= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_M2NDIV),
-	.div_m2_mask	= TI814X_ADPLL_M2_DIV_MASK,
-	.div_n_mask	= TI814X_ADPLL_N_DIV_MASK,
-	.pre_div_n      = TI814X_ADPLLJ_FIX_N,
-	.post_div_m2	= TI814X_ADPLL_POST_DIV_M2_2,
-	.frac_mult_reg	= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_FRACDIV),
-	.frac_mult_mask	= TI814X_ADPLL_FRACT_MULT_MASK,
-	.bypass_bit	= TI814X_EN_ADPLL_BYPASS_SHIFT,
-	.stby_ret_bit	= TI814X_EN_ADPLL_STBYRET_SHIFT,
-	.load_mn_reg	= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_TENABLE),
-	.load_m2n2_reg	= TI814X_ADPLL_REGADDR(AUDIO_PLL_BASE, ADPLLJ_TENDIV),
-	.sddiv_mask	= TI814X_ADPLLJ_SDDIV_MASK,
 };
 
 /* Audio DPLL for clock3(PRCM in) */
@@ -2988,6 +2752,7 @@
 	.set_rate	= &ti814x_dpll_set_rate,
 };
 
+/* Ducati fucntional clk selection mux */
 static const struct clksel ducati_mux_sel[] = {
 	{ .parent = &iss_dpll_ck, .rates = div_1_0_rates },
 	{ .parent = &sgx_dpll_ck, .rates = div_1_1_rates },
@@ -3036,6 +2801,8 @@
 	.clkdm_name	= "alwon_l3_slow_clkdm",
 	.recalc		= &omap2_clksel_recalc,
 };
+
+
 static const struct clksel sysclk18_a_div[] = {
 	{ .parent = &rtc_divider_ck, .rates = div8_rates },
 	{ .parent = NULL },
@@ -3061,6 +2828,13 @@
 	{ .parent = NULL}
 };
 
+/* TI811X has an on chip 32K osc, that drives RTC */
+static const struct clksel rtc_clkin32_mux_811x_sel[] = {
+	{ .parent = &rtc_divider_ck, .rates = div_1_0_rates },
+	{ .parent = &osc_32k_ck, .rates = div_1_1_rates },
+	{ .parent = NULL}
+};
+
 /* Clock input select for audio PRCM signal */
 static struct clk audio_prcm_clkin_ck = {
 	.name		= "audio_prcm_clkin_ck",
@@ -3099,6 +2873,7 @@
 	.recalc		= &followparent_recalc,
 };
 
+/* RTC Auxillary clock */
 static struct clk rtcss_aux_ck = {
 	.name		= "rtcss_aux_ck",
 	.parent		= &sysclk18_ck,
@@ -3106,6 +2881,7 @@
 	.clkdm_name	= "alwon_l3_slow_clkdm",
 	.recalc		= &followparent_recalc,
 };
+
 static const struct clksel sysclk19_b_div[] = {
 	{ .parent = &audio_dpll_clk2_ck, .rates = div8_rates },
 	{ .parent = NULL },
@@ -3197,7 +2973,6 @@
 	.clksel_reg	= TI81XX_CM_DPLL_AUDIOCLK_MCBSP_CLKSEL,
 	.clksel_mask	= TI81XX_CLKSEL_0_1_MASK,
 	.recalc		= &omap2_clksel_recalc,
-	.set_rate	= &ti814x_clksel_set_rate,
 };
 
 static const struct clksel mcbsp_clks_mux_sel[] = {
@@ -3205,7 +2980,7 @@
 	{ .parent = &xref0_ck, .rates = div_1_1_rates },
 	{ .parent = &xref1_ck, .rates = div_1_2_rates },
 	{ .parent = &xref2_ck, .rates = div_1_3_rates },
-	{ .parent = &osc1_x1_ck, .rates = div_1_4_rates },
+	{ .parent = &osc1_xi_ck, .rates = div_1_4_rates },
 	{ .parent = NULL}
 };
 
@@ -3275,9 +3050,6 @@
 	.init		= &omap2_init_clksel_parent,
 	.ops		= &clkops_null,
 	.clksel		= audio_prcm_mux_sel,
-	.ops		= &clkops_ti81xx_dflt_wait,
-	.enable_reg	= TI814X_CM_HDVPSS_HDMI_CLKCTRL,
-	.enable_bit	= TI81XX_MODULEMODE_SWCTRL,
 	.clksel_reg	= TI81XX_CM_DPLL_HDMI_CLKSEL,
 	.clksel_mask	= TI81XX_CLKSEL_0_1_MASK,
 	.clkdm_name	= "alwon_l3_slow_clkdm",
@@ -3290,7 +3062,7 @@
 	{ .parent = &xref0_ck, .rates = div_1_1_rates },
 	{ .parent = &xref1_ck, .rates = div_1_2_rates },
 	{ .parent = &xref2_ck, .rates = div_1_3_rates },
-	{ .parent = &osc1_x1_ck, .rates = div_1_4_rates },
+	{ .parent = &osc1_xi_ck, .rates = div_1_4_rates },
 	{ .parent = NULL}
 };
 
@@ -3463,15 +3235,6 @@
 	.recalc		= &followparent_recalc,
 };
 
-/* arm operational Func clk (MUX out) */
-static struct clk arm_oper_fck = {
-	.name		= "arm_oper_fck",
-	.parent		= &sysclk18_ck,
-	.ops		= &clkops_null,
-	.clkdm_name	= "alwon_l3_slow_clkdm",
-	.recalc		= &followparent_recalc,
-};
-
 /* arm optional Func clk (MUX out) */
 static struct clk arm_opt_fck = {
 	.name		= "arm_opt_fck",
@@ -3487,8 +3250,22 @@
 	{ .parent = &xref1_ck, .rates = div_1_2_rates },
 	{ .parent = &xref2_ck, .rates = div_1_3_rates },
 	{ .parent = &osc0_clkin_ck, .rates = div_1_4_rates },
-	{ .parent = &osc1_x1_ck, .rates = div_1_5_rates },
+	{ .parent = &osc1_xi_ck, .rates = div_1_5_rates },
+	{ .parent = &tclkin_ck, .rates = div_1_6_rates },
+	{ .parent = NULL}
+};
+
+/* On TI811X, an extra input was added */
+static const struct clksel gpt0to8_fclk_mux_811x_sel[] = {
+	{ .parent = &sysclk18_ck, .rates = div_1_0_rates },
+	{ .parent = &xref0_ck, .rates = div_1_1_rates },
+	{ .parent = &xref1_ck, .rates = div_1_2_rates },
+	{ .parent = &xref2_ck, .rates = div_1_3_rates },
+	{ .parent = &osc0_clkin_ck, .rates = div_1_4_rates },
+	{ .parent = &osc1_xi_ck, .rates = div_1_5_rates },
 	{ .parent = &tclkin_ck, .rates = div_1_6_rates },
+	{ .parent = &sysclk16_ck, .rates = div_1_7_rates },
+	{ .parent = &sysclk14_ck, .rates = div_1_8_rates },
 	{ .parent = NULL}
 };
 
@@ -3605,7 +3382,7 @@
 	{ .parent = &xref0_ck, .rates = div_1_3_rates },
 	{ .parent = &xref1_ck, .rates = div_1_4_rates },
 	{ .parent = &xref2_ck, .rates = div_1_5_rates },
-	{ .parent = &osc1_x1_ck, .rates = div_1_6_rates },
+	{ .parent = &osc1_xi_ck, .rates = div_1_6_rates },
 	{ .parent = NULL}
 };
 
@@ -3649,7 +3426,7 @@
 	{ .parent = &xref0_ck, .rates = div_1_0_rates },
 	{ .parent = &xref1_ck, .rates = div_1_1_rates },
 	{ .parent = &xref2_ck, .rates = div_1_2_rates },
-	{ .parent = &osc1_x1_ck, .rates = div_1_3_rates },
+	{ .parent = &osc1_xi_ck, .rates = div_1_3_rates },
 	{ .parent = &atl0_clk_ck, .rates = div_1_4_rates },
 	{ .parent = &atl1_clk_ck, .rates = div_1_5_rates },
 	{ .parent = &atl2_clk_ck, .rates = div_1_6_rates },
@@ -3763,6 +3540,16 @@
 	{ .parent = NULL}
 };
 
+/* On TI811X, input from l3_dpll was replaced by l3_fast clock */
+static const struct clksel cpts0to4_rft_clk_mux_811x_sel[] = {
+	{ .parent = &video0_dpll_ck, .rates = div_1_0_rates },
+	{ .parent = &video1_dpll_ck, .rates = div_1_1_rates },
+	{ .parent = &audio_dpll_ck, .rates = div_1_2_rates },
+	{ .parent = &hdmi_dpll_ck, .rates = div_1_3_rates },
+	{ .parent = &l3_fast_ick, .rates = div_1_4_rates },
+	{ .parent = NULL}
+};
+
 /* cpts rft clk (mux out to GMAC switch) */
 static struct clk cpts_rft_clk_ck = {
 	.name		= "cpts_rft_clk_ck",
@@ -3801,7 +3588,7 @@
 	.name		= "ljcb_serdesp_ck",
 	.ops		= &clkops_null,
 	.rate		= 100000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 /* LJCB input1 clk serdes_xrefclkin_ck */
@@ -3809,7 +3596,7 @@
 	.name		= "ljcb_serdesn_ck",
 	.ops		= &clkops_null,
 	.rate		= 100000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 /* pciess_20_refin_ck */
@@ -3841,7 +3628,7 @@
 	.name		= "pciess_50m_ck",
 	.ops		= &clkops_null,
 	.rate		= 50000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 /* 125MHz PCIe SS out */
@@ -3849,7 +3636,7 @@
 	.name		= "pciess_125m_ck",
 	.ops		= &clkops_null,
 	.rate		= 125000000,
-	.flags		= RATE_IN_TI814X | RATE_IN_DM385,
+	.flags		= RATE_IN_TI814X | RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 /* 100MHz diff ref clk out from PCIe  */
@@ -4011,6 +3798,82 @@
 	{ .parent = NULL}
 };
 
+/* gmac 125 clk source selection mux */
+static const struct clksel gmac_125_clk_mux_sel[] = {
+	{ .parent = &l3_fast_ick, .rates = div_1_0_rates },
+	{ .parent = &cpts_rft_clk_ck, .rates = div_1_1_rates },
+	{ .parent = NULL}
+};
+
+/*  gmac 125 mux out clock - for 811x */
+static struct clk gmac_125_clk_mux_out_ck = {
+	.name		= "gmac_125_clk_mux_out_ck",
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel		= gmac_125_clk_mux_sel,
+	.clksel_reg	= TI814X_PLL_CMGC_RMII_REF_CLKSRC,
+	.clksel_mask	= TI811X_GMAC_125_MUX_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+/* gmac 125 clk div4 Clock */
+static struct clk gmac_125_clk_d4_ck = {
+	.name		= "gmac_125_clk_d4_ck",
+	.parent		= &gmac_125_clk_mux_out_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.fixed_div	= 4,
+	.recalc		= &omap_fixed_divisor_recalc,
+};
+
+/* gmac 125 clk div5 Clock */
+static struct clk gmac_125_clk_d5_ck = {
+	.name		= "gmac_125_clk_d5_ck",
+	.parent		= &gmac_125_clk_mux_out_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.fixed_div	= 5,
+	.recalc		= &omap_fixed_divisor_recalc,
+};
+
+/* gmac 125 clk div2 Clock */
+static struct clk gmac_125_clk_d2_ck = {
+	.name		= "gmac_125_clk_d2_ck",
+	.parent		= &gmac_125_clk_mux_out_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.fixed_div	= 2,
+	.recalc		= &omap_fixed_divisor_recalc,
+};
+
+/* gmac 50 clk source selection mux */
+static const struct clksel gmac_50_clk_mux_sel[] = {
+	{ .parent = &gmac_125_clk_d4_ck, .rates = div_1_0_rates },
+	{ .parent = &gmac_125_clk_d5_ck, .rates = div_1_1_rates },
+	{ .parent = NULL}
+};
+
+/*  gmac 50 mux out clock - for 811x */
+static struct clk gmac_50_clk_mux_out_ck = {
+	.name		= "gmac_50_clk_mux_out_ck",
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel		= gmac_125_clk_mux_sel,
+	.clksel_reg	= TI814X_PLL_CMGC_RMII_REF_CLKSRC,
+	.clksel_mask	= TI811X_GMAC_50_MUX_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+/* rmii ref clk source selection mux */
+static const struct clksel rmii_811x_mux_sel[] = {
+	{ .parent = &gmac_50_clk_mux_out_ck, .rates = div_1_0_rates },
+	{ .parent = &external_ck, .rates = div_1_1_rates },
+	{ .parent = NULL}
+};
+
+/* RMII ref clk */
 static struct clk emac_rmii_fck = {
 	.name		= "emac_rmii_fck",
 	.init		= &omap2_init_clksel_parent,
@@ -4095,7 +3958,7 @@
 static struct clk dummy_clk_ck = {
 	.name		= "dummy_clk_ck",
 	.ops		= &clkops_null,
-	.flags		= RATE_IN_DM385,
+	.flags		= RATE_IN_DM385 | RATE_IN_TI811X,
 };
 
 static const struct clksel clkout0to3_385_mux_sel[] = {
@@ -4175,6 +4038,23 @@
 	{ .parent = &rcosc_32k_ck, .rates = div_1_10_rates },
 	{ .parent = NULL}
 };
+
+/* sys clkout source selection for TI811X */
+static const struct clksel clkout0to10_811x_mux_sel[] = {
+	{ .parent = &clkout_prcm_ck, .rates = div_1_0_rates },
+	{ .parent = &dummy_clk_ck, .rates = div_1_1_rates },
+	{ .parent = &pciess_125m_ck, .rates = div_1_2_rates },
+	{ .parent = &osc_32k_ck, .rates = div_1_3_rates },
+	{ .parent = &dummy_clk_ck, .rates = div_1_4_rates },
+	{ .parent = &dummy_clk_ck, .rates = div_1_5_rates },
+	{ .parent = &osc0_clkin_ck, .rates = div_1_6_rates },
+	{ .parent = &osc1_clkin_ck, .rates = div_1_7_rates },
+	{ .parent = &mpu_ck, .rates = div_1_8_rates },
+	{ .parent = &sgx_dpll_ck, .rates = div_1_9_rates },
+	{ .parent = &rcosc_32k_ck, .rates = div_1_10_rates },
+	{ .parent = NULL}
+};
+
 /* SYS CLOCK OUT 0 */
 static struct clk sys_clkout1 = {
 	.name		= "sys_clkout1",
@@ -4206,282 +4086,296 @@
  * completeness.
  */
 static struct omap_clk ti814x_clks[] = {
-	CLK(NULL,		"rcosc_32k_ck",			&rcosc_32k_ck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"rcosc_32k_ck",			&rcosc_32k_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"osc_32k_ck",			&osc_32k_ck,			CK_TI811X),
 	CLK(NULL,		"sys_32k_clkin_ck",		&sys_32k_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"tclkin_ck",			&tclkin_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"osc0_clkin_ck",		&osc0_clkin_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"osc1_clkin_ck",		&osc1_clkin_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"rtc_divider_ck",		&rtc_divider_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"osc1_x1_ck",			&osc1_x1_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"xref0_ck",			&xref0_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"xref1_ck",			&xref1_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"xref2_ck",			&xref2_ck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"tclkin_ck",			&tclkin_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"osc0_clkin_ck",		&osc0_clkin_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"osc1_clkin_ck",		&osc1_clkin_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"rtc_divider_ck",		&rtc_divider_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"osc1_xi_ck",			&osc1_xi_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"xref0_ck",			&xref0_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"xref1_ck",			&xref1_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"xref2_ck",			&xref2_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"tsi0_dck_ck",			&tsi0_dck_ck,			CK_TI814X),
 	CLK(NULL,		"tsi1_dck_ck",			&tsi1_dck_ck,			CK_TI814X),
-	CLK(NULL,		"external_ck",			&external_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"atl0_clk_ck",			&atl0_clk_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"atl1_clk_ck",			&atl1_clk_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"atl2_clk_ck",			&atl2_clk_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"atl3_clk_ck",			&atl3_clk_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dcan0_fck",			&dcan0_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dcan1_fck",			&dcan1_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"external_ck",			&external_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"atl0_clk_ck",			&atl0_clk_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"atl1_clk_ck",			&atl1_clk_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"atl2_clk_ck",			&atl2_clk_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"atl3_clk_ck",			&atl3_clk_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dcan0_fck",			&dcan0_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dcan1_fck",			&dcan1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"sr1_fck",			&sr1_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sr2_fck",			&sr2_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"sr2_fck",			&sr2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"sr3_fck",			&sr3_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sr4_fck",			&sr4_fck,			CK_TI814X),
-	CLK(NULL,		"arm_dpll_clkin_ck",		&arm_dpll_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"arm_dpll_ck",			&arm_dpll_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mpu_ck",			&mpu_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dsp_dpll_ck",			&dsp_dpll_ck,			CK_TI814X),
-	CLK(NULL,		"gem_fck",			&gem_fck,			CK_TI814X),
-	CLK(NULL,		"sgx_dpll_ck",			&sgx_dpll_ck,			CK_TI814X),
-	CLK(NULL,		"sysclk23_ck",			&sysclk23_ck,			CK_TI814X),
-	CLK(NULL,		"sgx_ck",			&sgx_ck,			CK_TI814X),
-	CLK(NULL,		"sgx_sys_ck",			&sgx_sys_ck,			CK_TI814X),
-	CLK(NULL,		"sgx_mem_ck",			&sgx_mem_ck,			CK_TI814X),
+	CLK(NULL,		"sr4_fck",			&sr4_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"adc_clk_ck",			&adc_clk_ck,			CK_TI811X),
+	CLK(NULL,		"arm_dpll_clkin_ck",		&arm_dpll_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"arm_dpll_ck",			&arm_dpll_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mpu_ck",			&mpu_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dsp_dpll_ck",			&dsp_dpll_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"gem_fck",			&gem_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sgx_dpll_ck",			&sgx_dpll_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sysclk23_ck",			&sysclk23_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sgx_ck",			&sgx_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sgx_sys_ck",			&sgx_sys_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sgx_mem_ck",			&sgx_mem_ck,			CK_TI814X | CK_TI811X),
 	CLK(NULL,		"hdvicp_dpll_ck",		&hdvicp_dpll_ck,		CK_TI814X | CK_DM385),
 	CLK(NULL,		"sysclk3_ck",			&sysclk3_ck,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"ivahd0_ck",			&ivahd0_ck,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"l3_dpll_clkin_ck",		&l3_dpll_clkin_ck,		CK_TI814X | CK_DM385),
 	CLK(NULL,		"l3_dpll_ck",			&l3_dpll_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk4_ck",			&sysclk4_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"l3_fast_ick",			&l3_fast_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"sysclk4_ck",			&sysclk4_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"l3_fast_ick",			&l3_fast_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"ivahd0_ick",			&ivahd0_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"exp_slot_ick",			&exp_slot_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mmu_ick",			&mmu_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gem_ick",			&gem_ick,			CK_TI814X),
-	CLK(NULL,		"tptc0_ick",			&tptc0_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"tptc1_ick",			&tptc1_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"tptc2_ick",			&tptc2_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"tptc3_ick",			&tptc3_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"exp_slot_ick",			&exp_slot_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mmu_ick",			&mmu_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gem_ick",			&gem_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"tptc0_ick",			&tptc0_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"tptc1_ick",			&tptc1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"tptc2_ick",			&tptc2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"tptc3_ick",			&tptc3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"ivahd0_sl2_ick",		&ivahd0_sl2_ick,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"tpcc_ick",			&tpcc_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"tpcc_ick",			&tpcc_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"fdif_ick",			&fdif_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdvpss_l3_ick",		&hdvpss_l3_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk5_ck",			&sysclk5_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"l3_med_ick",			&l3_med_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"l4_fast_ick",			&l4_fast_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"securess_ick",			&securess_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"tpgsw_ick",			&tpgsw_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"hdvpss_l3_ick",		&hdvpss_l3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk5_ck",			&sysclk5_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"l3_med_ick",			&l3_med_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"l4_fast_ick",			&l4_fast_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"securess_ick",			&securess_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"tpgsw_ick",			&tpgsw_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK("ahci.0",		NULL,				&sata_ick,			CK_TI814X | CK_DM385),
 	CLK("ahci.1",		NULL,				&sata1_ick,			CK_DM385),
-	CLK(NULL,		"pcie_ck",			&pcie_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"vcp2_fck",			&vcp2_fck,			CK_TI814X),
-	CLK(NULL,		"mlb_ick",			&mlb_ick,			CK_TI814X),
+	CLK(NULL,		"pcie_ck",			&pcie_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"vcp2_fck",			&vcp2_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mlb_ick",			&mlb_ick,			CK_TI814X | CK_TI811X),
 	CLK(NULL,		"fdif_fck",			&fdif_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dap_ick",			&dap_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"ocmc_ram_ick",			&ocmc_ram_ick,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.2",	"ick",				&mmchs3_ick,			CK_TI814X | CK_DM385),
-	CLK("cpsw.0",		NULL,				&cpsw_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gem_trc_fck",			&gem_trc_fck,			CK_TI814X),
-	CLK(NULL,		"mcasp4_ick",			&mcasp4_ick,			CK_TI814X),
-	CLK(NULL,		"mcasp5_ick",			&mcasp5_ick,			CK_TI814X),
-	CLK(NULL,		"mcasp6_ick",			&mcasp6_ick,			CK_TI814X),
-	CLK(NULL,		"hdvpss_l4_ick",		&hdvpss_l4_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk6_ck",			&sysclk6_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"l3_slow_ick",			&l3_slow_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"l4_slow_ick",			&l4_slow_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart1_ick",			&uart1_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart2_ick",			&uart2_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart3_ick",			&uart3_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart4_ick",			&uart4_ick,			CK_TI814X),
-	CLK(NULL,		"uart5_ick",			&uart5_ick,			CK_TI814X),
-	CLK(NULL,		"uart6_ick",			&uart6_ick,			CK_TI814X),
-	CLK("omap_i2c.1",	"ick",				&i2c1_ick,			CK_TI814X | CK_DM385),
-	CLK("omap_i2c.2",	"ick",				&i2c2_ick,			CK_TI814X | CK_DM385),
-	CLK("omap_i2c.3",	"ick",				&i2c3_ick,			CK_TI814X | CK_DM385),
-	CLK("omap_i2c.4",	"ick",				&i2c4_ick,			CK_TI814X | CK_DM385),
-	CLK("omap2_mcspi.1",	"ick",				&mcspi1_ick,			CK_TI814X | CK_DM385),
-	CLK("omap2_mcspi.2",	"ick",				&mcspi2_ick,			CK_TI814X | CK_DM385),
-	CLK("omap2_mcspi.3",	"ick",				&mcspi3_ick,			CK_TI814X),
-	CLK("omap2_mcspi.4",	"ick",				&mcspi4_ick,			CK_TI814X),
-	CLK(NULL,		"sdio_ick",			&sdio_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt1_ick",			&gpt1_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt2_ick",			&gpt2_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt3_ick",			&gpt3_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt4_ick",			&gpt4_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt5_ick",			&gpt5_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt6_ick",			&gpt6_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt7_ick",			&gpt7_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt8_ick",			&gpt8_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio234_ick",			&gpio234_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio1_ick",			&gpio1_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio2_ick",			&gpio2_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio3_ick",			&gpio3_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio4_ick",			&gpio4_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"prcm_ick",			&prcm_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"dap_ick",			&dap_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"ocmc_ram_ick",			&ocmc_ram_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.2",	"ick",				&mmchs3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("cpsw.0",		NULL,				&cpsw_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gem_trc_fck",			&gem_trc_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcasp4_ick",			&mcasp4_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcasp5_ick",			&mcasp5_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcasp6_ick",			&mcasp6_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"hdvpss_l4_ick",		&hdvpss_l4_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk6_ck",			&sysclk6_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"l3_slow_ick",			&l3_slow_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"l4_slow_ick",			&l4_slow_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart1_ick",			&uart1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart2_ick",			&uart2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart3_ick",			&uart3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart4_ick",			&uart4_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"uart5_ick",			&uart5_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"uart6_ick",			&uart6_ick,			CK_TI814X | CK_TI811X),
+	CLK("omap_i2c.1",	"ick",				&i2c1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_i2c.2",	"ick",				&i2c2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_i2c.3",	"ick",				&i2c3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_i2c.4",	"ick",				&i2c4_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.1",	"ick",				&mcspi1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.2",	"ick",				&mcspi2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.3",	"ick",				&mcspi3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.4",	"ick",				&mcspi4_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sdio_ick",			&sdio_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt1_ick",			&gpt1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt2_ick",			&gpt2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt3_ick",			&gpt3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt4_ick",			&gpt4_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt5_ick",			&gpt5_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt6_ick",			&gpt6_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt7_ick",			&gpt7_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt8_ick",			&gpt8_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio234_ick",			&gpio234_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio1_ick",			&gpio1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio2_ick",			&gpio2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio3_ick",			&gpio3_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio4_ick",			&gpio4_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio5_ick",			&gpio5_ick,			CK_TI811X),
+	CLK(NULL,		"gpio6_ick",			&gpio6_ick,			CK_TI811X),
+	CLK(NULL,		"prcm_ick",			&prcm_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"smartcard1_ick",		&smartcard1_ick,		CK_TI814X),
 	CLK(NULL,		"smartcard2_ick",		&smartcard2_ick,		CK_TI814X),
-	CLK(NULL,		"mcasp1_ick",			&mcasp1_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcasp2_ick",			&mcasp2_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcasp3_ick",			&mcasp3_ick,			CK_TI814X),
-	CLK(NULL,		"mcbsp_ick",			&mcbsp_ick,			CK_TI814X),
-	CLK(NULL,		"gpmc_fck",			&gpmc_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdmi_ick",			&hdmi_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mlbp_ick",			&mlbp_ick,			CK_TI814X),
-	CLK("omap_wdt",		"wdt1_ick",			&wdt1_ick,			CK_TI814X | CK_DM385),
-	CLK("omap_wdt",		"wdt2_ick",			&wdt2_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sync_timer_ick",		&sync_timer_ick,		CK_TI814X | CK_DM385),
+	CLK(NULL,		"mcasp1_ick",			&mcasp1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcasp2_ick",			&mcasp2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcasp3_ick",			&mcasp3_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcbsp_ick",			&mcbsp_ick,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"gpmc_fck",			&gpmc_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"hdmi_ick",			&hdmi_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mlbp_ick",			&mlbp_ick,			CK_TI814X | CK_TI811X),
+	CLK("omap_wdt",		"wdt1_ick",			&wdt1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_wdt",		"wdt2_ick",			&wdt2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sync_timer_ick",		&sync_timer_ick,		CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"pata_ick",			&pata_ick,			CK_TI814X),
-	CLK(NULL,		"mailbox_ick",			&mailbox_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"spinbox_ick",			&spinbox_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"mailbox_ick",			&mailbox_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"spinbox_ick",			&spinbox_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"vlynq_ick",			&vlynq_ick,			CK_TI811X),
 	CLK(NULL,		"sr1_ick",			&sr1_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sr2_ick",			&sr2_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"sr2_ick",			&sr2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"sr3_ick",			&sr3_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sr4_ick",			&sr4_ick,			CK_TI814X),
-	CLK("ti81xx-usbss",	"usb_ick",			&usbotg_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mmu_cfg_ick",			&mmu_cfg_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"p1500_ick",			&p1500_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"elm_ick",			&elm_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"elm_fck",			&elm_fck,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.0",	"ick",				&mmchs1_ick,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.1",	"ick",				&mmchs2_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"atl_ick",			&atl_ick,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"sr4_ick",			&sr4_ick,			CK_TI814X | CK_TI811X),
+	CLK("ti81xx-usbss",	"usb_ick",			&usbotg_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mmu_cfg_ick",			&mmu_cfg_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"p1500_ick",			&p1500_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"elm_ick",			&elm_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"elm_fck",			&elm_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.0",	"ick",				&mmchs1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.1",	"ick",				&mmchs2_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"atl_ick",			&atl_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"fdif_enb_ck",			&fdif_enb_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"rtc_c32k_ick",			&rtc_c32k_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dcan0_ick",			&dcan0_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dcan1_ick",			&dcan1_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"iss_dpll_ck",			&iss_dpll_ck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"rtc_c32k_ick",			&rtc_c32k_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dcan0_ick",			&dcan0_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dcan1_ick",			&dcan1_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"iss_dpll_ck",			&iss_dpll_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"iss_ick",			&iss_ick,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"isp_ick",			&isp_ick,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"tppss_tso_ick",		&tppss_tso_ick,			CK_TI814X),
-	CLK(NULL,		"iss_dpll_d2_ck",		&iss_dpll_d2_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"ducati_ick",			&ducati_ick,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdvpss_dpll_ck",		&hdvpss_dpll_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdvpss_proc_fck",		&hdvpss_proc_fck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdvpss_proc_d2_fck",		&hdvpss_proc_d2_fck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"dvi_ch1_ck",			&dvi_ch1_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dvi_ch2_ck",			&dvi_ch2_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dvi_ch3_ck",			&dvi_ch3_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dvi_ch4_ck",			&dvi_ch4_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dvoi1_ck",			&dvoi1_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"dvoi2_ck",			&dvoi2_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"usb_dpll_clkin_ck",		&usb_dpll_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"usb_dpll_ck",			&usb_dpll_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"usb_phy0_rclk_ick",		&usb_phy0_rclk_ick,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"usb_phy1_rclk_ick",		&usb_phy1_rclk_ick,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"usb_dpll_div5_ck",		&usb_dpll_div5_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk10_ck",			&sysclk10_ck,			CK_TI814X | CK_DM385),
-	CLK("omap2_mcspi.1",	"fck",				&mcspi1_fck,			CK_TI814X | CK_DM385),
-	CLK("omap2_mcspi.2",	"fck",				&mcspi2_fck,			CK_TI814X | CK_DM385),
-	CLK("omap2_mcspi.3",	"fck",				&mcspi3_fck,			CK_TI814X | CK_DM385),
-	CLK("omap2_mcspi.4",	"fck",				&mcspi4_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"i2c02_ck",			&i2c02_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"i2c13_ck",			&i2c13_ck,			CK_TI814X | CK_DM385),
-	CLK("omap_i2c.1",	"fck",				&i2c1_fck,			CK_TI814X | CK_DM385),
-	CLK("omap_i2c.2",	"fck",				&i2c2_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"i2c3_fck",			&i2c3_fck,			CK_TI814X | CK_DM385),
-	CLK("omap_i2c.4",	"fck",				&i2c4_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart1_fck",			&uart1_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart2_fck",			&uart2_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart3_fck",			&uart3_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"iss_dpll_d2_ck",		&iss_dpll_d2_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"ducati_ick",			&ducati_ick,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"hdvpss_dpll_ck",		&hdvpss_dpll_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"hdvpss_proc_fck",		&hdvpss_proc_fck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"hdvpss_proc_d2_fck",		&hdvpss_proc_d2_fck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dvi_ch1_ck",			&dvi_ch1_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dvi_ch2_ck",			&dvi_ch2_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dvi_ch3_ck",			&dvi_ch3_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dvi_ch4_ck",			&dvi_ch4_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dvoi1_ck",			&dvoi1_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dvoi2_ck",			&dvoi2_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"usb_dpll_clkin_ck",		&usb_dpll_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"usb_dpll_ck",			&usb_dpll_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"usb_phy0_rclk_ick",		&usb_phy0_rclk_ick,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"usb_phy1_rclk_ick",		&usb_phy1_rclk_ick,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"usb_dpll_div5_ck",		&usb_dpll_div5_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk10_ck",			&sysclk10_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.1",	"fck",				&mcspi1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.2",	"fck",				&mcspi2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.3",	"fck",				&mcspi3_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap2_mcspi.4",	"fck",				&mcspi4_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"i2c02_ck",			&i2c02_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"i2c13_ck",			&i2c13_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_i2c.1",	"fck",				&i2c1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_i2c.2",	"fck",				&i2c2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"i2c3_fck",			&i2c3_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_i2c.4",	"fck",				&i2c4_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart1_fck",			&uart1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart2_fck",			&uart2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart3_fck",			&uart3_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"hdmi_cec_dcc_fck",		&hdmi_cec_dcc_fck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk8_ck",			&sysclk8_ck,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.0",	"fck",				&mmchs1_fck,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.1",	"fck",				&mmchs2_fck,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.2",	"fck",				&mmchs3_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"uart4_fck",			&uart4_fck,			CK_TI814X),
-	CLK(NULL,		"uart5_fck",			&uart5_fck,			CK_TI814X),
-	CLK(NULL,		"uart6_fck",			&uart6_fck,			CK_TI814X),
-	CLK(NULL,		"securess_fck",			&securess_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"sysclk8_ck",			&sysclk8_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.0",	"fck",				&mmchs1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.1",	"fck",				&mmchs2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.2",	"fck",				&mmchs3_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"uart4_fck",			&uart4_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"uart5_fck",			&uart5_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"uart6_fck",			&uart6_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"uart78_fck",			&uart78_fck,			CK_TI811X),
+	CLK(NULL,		"securess_fck",			&securess_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"tppss_fck",			&tppss_fck,			CK_TI814X),
 	CLK(NULL,		"csi2_phy_fck",			&csi2_phy_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"ddr_dpll_clkin_ck",		&ddr_dpll_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"ddr_dpll_ck",			&ddr_dpll_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"ddr0_phy_fck",			&ddr0_phy_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"ddr_dpll_clkin_ck",		&ddr_dpll_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"ddr_dpll_ck",			&ddr_dpll_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"ddr0_phy_fck",			&ddr0_phy_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"ddr1_phy_fck",			&ddr1_phy_fck,			CK_TI814X),
-	CLK(NULL,		"ddr0_half_fck",		&ddr0_half_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"ddr0_half_fck",		&ddr0_half_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"ddr1_half_fck",		&ddr1_half_fck,			CK_TI814X),
-	CLK(NULL,		"ddr0_phy_d2_fck",		&ddr0_phy_d2_fck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"ddr0_emif_fck",		&ddr0_emif_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"ddr0_phy_d2_fck",		&ddr0_phy_d2_fck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"ddr0_emif_fck",		&ddr0_emif_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"dmm_phy_fck",			&dmm_phy_fck,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"ddr1_phy_d2_fck",		&ddr1_phy_d2_fck,		CK_TI814X),
 	CLK(NULL,		"ddr1_emif_fck",		&ddr1_emif_fck,			CK_TI814X),
-	CLK(NULL,		"video0_dpll_clkin_ck",		&video0_dpll_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"video0_dpll_ck",		&video0_dpll_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"video1_dpll_clkin_ck",		&video1_dpll_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"video1_dpll_ck",		&video1_dpll_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdmi_dpll_clkin_ck",		&hdmi_dpll_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdmi_dpll_ck",			&hdmi_dpll_ck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"video0_dpll_clkin_ck",		&video0_dpll_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"video0_dpll_ck",		&video0_dpll_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"video1_dpll_clkin_ck",		&video1_dpll_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"video1_dpll_ck",		&video1_dpll_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"hdmi_dpll_clkin_ck",		&hdmi_dpll_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"hdmi_dpll_ck",			&hdmi_dpll_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"video_m_pclk_ck",		&video_m_pclk_ck,		CK_TI814X | CK_DM385),
 	CLK(NULL,		"hdmi_phy_tclk_ck",		&hdmi_phy_tclk_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"hdmi_dpll_muxout_ck",		&hdmi_dpll_muxout_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"video012_dpll_muxout_ck",	&video012_dpll_muxout_ck,	CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk16_d1mux_ck",		&sysclk16_d1mux_ck,		CK_TI814X),
-	CLK(NULL,		"sysclk16_b3mux_ck",		&sysclk16_b3mux_ck,		CK_TI814X),
-	CLK(NULL,		"sysclk14_c1mux_ck",		&sysclk14_c1mux_ck,		CK_TI814X),
-	CLK(NULL,		"sysclk16_ck",			&sysclk16_ck,			CK_TI814X),
+	CLK(NULL,		"hdmi_dpll_muxout_ck",		&hdmi_dpll_muxout_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"video012_dpll_muxout_ck",	&video012_dpll_muxout_ck,	CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk16_d1mux_ck",		&sysclk16_d1mux_ck,		CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sysclk16_b3mux_ck",		&sysclk16_b3mux_ck,		CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sysclk14_c1mux_ck",		&sysclk14_c1mux_ck,		CK_TI814X | CK_TI811X),
+	CLK(NULL,		"sysclk16_ck",			&sysclk16_ck,			CK_TI814X | CK_TI811X),
 	CLK(NULL,		"tppss_stc1_fck",		&tppss_stc1_fck,		CK_TI814X),
-	CLK(NULL,		"hd_venc_g_ck",			&hd_venc_g_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"hd_venc_d_ck",			&hd_venc_d_ck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"hd_venc_g_ck",			&hd_venc_g_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"hd_venc_d_ck",			&hd_venc_d_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"dtc0_logic_ck",		&dtc0_logic_ck,			CK_TI811X),
+	CLK(NULL,		"dtc1_logic_ck",		&dtc1_logic_ck,			CK_TI811X),
 	CLK(NULL,		"hd_venc_a_ck",			&hd_venc_a_ck,			CK_DM385),
 	CLK(NULL,		"hd_dac_ck",			&hd_dac_ck,			CK_DM385),
 	CLK(NULL,		"hdmi_phy_gclk_ck",		&hdmi_phy_gclk_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"sd_venc_ck",			&sd_venc_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk14_ck",			&sysclk14_ck,			CK_TI814X),
+	CLK(NULL,		"sd_venc_ck",			&sd_venc_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk14_ck",			&sysclk14_ck,			CK_TI814X | CK_TI811X),
 	CLK(NULL,		"tppss_stc0_fck",		&tppss_stc0_fck,		CK_TI814X),
-	CLK(NULL,		"audio_dpll_clk2_ck",		&audio_dpll_clk2_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"audio_dpll_clkin_ck",		&audio_dpll_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"audio_dpll_ck",		&audio_dpll_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"audio_dpll_clk1_ck",		&audio_dpll_clk1_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"audio_prcm_clkin_ck",		&audio_prcm_clkin_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk18_ck",			&sysclk18_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"rtc_c32k_fck",			&rtc_c32k_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk19_ck",			&sysclk19_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk20_ck",			&sysclk20_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk21_ck",			&sysclk21_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sysclk22_ck",			&sysclk22_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"audio_prcm1_out_ck",		&audio_prcm1_out_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcbsp_fck",			&mcbsp_fck,			CK_TI814X | CK_DM385),
-	CLK("davinci-mcasp.0",	NULL,				&mcasp1_fck,			CK_TI814X | CK_DM385),
-	CLK("davinci-mcasp.1",	NULL,				&mcasp2_fck,			CK_TI814X | CK_DM385),
-	CLK("davinci-mcasp.2",	NULL,				&mcasp3_fck,			CK_TI814X),
+	CLK(NULL,		"audio_dpll_clk2_ck",		&audio_dpll_clk2_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"audio_dpll_clkin_ck",		&audio_dpll_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"audio_dpll_ck",		&audio_dpll_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"ducati_mux_out_ck",		&ducati_mux_out_ck,		CK_TI811X),
+	CLK(NULL,		"ducati_mux_out_div2_ck",	&ducati_mux_out_div2_ck,	CK_TI811X),
+	CLK(NULL,		"dss_mux_out_ck",		&dss_mux_out_ck,		CK_TI811X),
+	CLK(NULL,		"audio_dpll_clk1_ck",		&audio_dpll_clk1_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"audio_prcm_clkin_ck",		&audio_prcm_clkin_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk18_ck",			&sysclk18_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"rtc_c32k_fck",			&rtc_c32k_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"rtcss_aux_ck",			&rtcss_aux_ck,			CK_TI811X),
+	CLK(NULL,		"sysclk19_ck",			&sysclk19_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk20_ck",			&sysclk20_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk21_ck",			&sysclk21_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sysclk22_ck",			&sysclk22_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"audio_prcm1_out_ck",		&audio_prcm1_out_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcbsp_fck",			&mcbsp_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("davinci-mcasp.0",	NULL,				&mcasp1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("davinci-mcasp.1",	NULL,				&mcasp2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("davinci-mcasp.2",	NULL,				&mcasp3_fck,			CK_TI814X | CK_TI811X),
 	CLK(NULL,		"hdmi_i2s_ck",			&hdmi_i2s_ck,			CK_TI814X | CK_DM385),
 	CLK("hdmi-dai",		NULL,				&hdmi_i2s_fck,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"tppss_tso_fck",		&tppss_tso_fck,			CK_TI814X),
-	CLK(NULL,		"atl_fck",			&atl_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio234_dbck",			&gpio234_dbck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio1_dbck",			&gpio1_dbck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio2_dbck",			&gpio2_dbck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio3_dbck",			&gpio3_dbck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpio4_dbck",			&gpio4_dbck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"rtc_fck",			&rtc_fck,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.0",	"mmchs1_dbck",			&mmchs1_dbck,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.1",	"mmchs2_dbck",			&mmchs2_dbck,			CK_TI814X | CK_DM385),
-	CLK("mmci-omap-hs.2",	"mmchs3_dbck",			&mmchs3_dbck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sync_timer_fck",		&sync_timer_fck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"bandgaps_fck",			&bandgaps_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"arm_oper_fck",			&arm_oper_fck,			CK_TI814X),
-	CLK(NULL,		"gpt1_fck",			&gpt1_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt2_fck",			&gpt2_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt3_fck",			&gpt3_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt4_fck",			&gpt4_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt5_fck",			&gpt5_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt6_fck",			&gpt6_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt7_fck",			&gpt7_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"gpt8_fck",			&gpt8_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcasp_auxclk_mux0_ck",		&mcasp_auxclk_mux0_ck,		CK_TI814X),
-	CLK("davinci-mcasp.3",	NULL,				&mcasp4_fck,			CK_TI814X),
-	CLK("davinci-mcasp.4",	NULL,				&mcasp5_fck,			CK_TI814X),
-	CLK("davinci-mcasp.5",	NULL,				&mcasp6_fck,			CK_TI814X),
-	CLK(NULL,		"mcasp1_ahx_ck",		&mcasp1_ahx_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcasp1_ahr_ck",		&mcasp1_ahr_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcasp2_ahx_ck",		&mcasp2_ahx_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcasp2_ahr_ck",		&mcasp2_ahr_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"mcasp3_ahx_ck",		&mcasp3_ahx_ck,			CK_TI814X),
-	CLK(NULL,		"mcasp4_ahx_ck",		&mcasp4_ahx_ck,			CK_TI814X),
-	CLK(NULL,		"mcasp5_ahx_ck",		&mcasp5_ahx_ck,			CK_TI814X),
-	CLK(NULL,		"mcasp6_ahx_ck",		&mcasp6_ahx_ck,			CK_TI814X),
-	CLK(NULL,		"cpts_rft_clk_ck",		&cpts_rft_clk_ck,		CK_TI814X | CK_DM385),
+	CLK(NULL,		"atl_fck",			&atl_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio234_dbck",			&gpio234_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio1_dbck",			&gpio1_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio2_dbck",			&gpio2_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio3_dbck",			&gpio3_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio4_dbck",			&gpio4_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpio5_dbck",			&gpio5_dbck,			CK_TI811X),
+	CLK(NULL,		"gpio6_dbck",			&gpio6_dbck,			CK_TI811X),
+	CLK(NULL,		"rtc_fck",			&rtc_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.0",	"mmchs1_dbck",			&mmchs1_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.1",	"mmchs2_dbck",			&mmchs2_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("mmci-omap-hs.2",	"mmchs3_dbck",			&mmchs3_dbck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sync_timer_fck",		&sync_timer_fck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"bandgaps_fck",			&bandgaps_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"arm_opt_fck",			&arm_opt_fck,			CK_TI814X),
+	CLK(NULL,		"gpt1_fck",			&gpt1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt2_fck",			&gpt2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt3_fck",			&gpt3_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt4_fck",			&gpt4_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt5_fck",			&gpt5_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt6_fck",			&gpt6_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt7_fck",			&gpt7_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"gpt8_fck",			&gpt8_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcasp_auxclk_mux0_ck",		&mcasp_auxclk_mux0_ck,		CK_TI814X | CK_TI811X),
+	CLK("davinci-mcasp.3",	NULL,				&mcasp4_fck,			CK_TI814X | CK_TI811X),
+	CLK("davinci-mcasp.4",	NULL,				&mcasp5_fck,			CK_TI814X | CK_TI811X),
+	CLK("davinci-mcasp.5",	NULL,				&mcasp6_fck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcasp1_ahx_ck",		&mcasp1_ahx_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcasp1_ahr_ck",		&mcasp1_ahr_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcasp2_ahx_ck",		&mcasp2_ahx_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcasp2_ahr_ck",		&mcasp2_ahr_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"mcasp3_ahx_ck",		&mcasp3_ahx_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcasp4_ahx_ck",		&mcasp4_ahx_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcasp5_ahx_ck",		&mcasp5_ahx_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"mcasp6_ahx_ck",		&mcasp6_ahx_ck,			CK_TI814X | CK_TI811X),
+	CLK(NULL,		"cpts_rft_clk_ck",		&cpts_rft_clk_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"cpts_rft_div5_ck",		&cpts_rft_div5_ck,		CK_DM385),
 	CLK(NULL,		"cpts_rft_div2_ck",		&cpts_rft_div2_ck,		CK_DM385),
-	CLK(NULL,		"ljcb_serdesp_ck",		&ljcb_serdesp_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"ljcb_serdesn_ck",		&ljcb_serdesn_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"pciessp_ck",			&pciessp_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"pciessn_ck",			&pciessn_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"pciess_20m_ck",		&pciess_20m_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"pciess_50m_ck",		&pciess_50m_ck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"pciess_125m_ck",		&pciess_125m_ck,		CK_TI814X | CK_DM385),
+	CLK(NULL,		"ljcb_serdesp_ck",		&ljcb_serdesp_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"ljcb_serdesn_ck",		&ljcb_serdesn_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"pciessp_ck",			&pciessp_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"pciessn_ck",			&pciessn_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"pciess_20m_ck",		&pciess_20m_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"pciess_50m_ck",		&pciess_50m_ck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"pciess_125m_ck",		&pciess_125m_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"satassp_ck",			&satassp_ck,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"satassn_ck",			&satassn_ck,			CK_TI814X | CK_DM385),
 	CLK(NULL,		"satass_20m_ck",		&satass_20m_ck,			CK_TI814X | CK_DM385),
@@ -4495,25 +4389,40 @@
 	CLK(NULL,		"sata01_50m_mux_out_ck",	&sata01_50m_mux_out_ck,		CK_DM385),
 	CLK(NULL,		"sata01_125m_mux_out_ck",	&sata01_125m_mux_out_ck,	CK_DM385),
 	CLK(NULL,		"gmac0to1_mux_out_ck",		&gmac0to1_mux_out_ck,		CK_DM385),
-	CLK(NULL,		"emac_rmii_fck",		&emac_rmii_fck,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"emac_gmii_fck",		&emac_gmii_fck,			CK_TI814X | CK_DM385),
-	CLK("omap_wdt",		"wdt1_fck",			&wdt1_fck,			CK_TI814X | CK_DM385),
-	CLK("omap_wdt",		"wdt2_fck",			&wdt2_fck,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"gmac_125_clk_mux_out_ck",	&gmac_125_clk_mux_out_ck,	CK_TI811X),
+	CLK(NULL,		"gmac_125_clk_d4_ck",		&gmac_125_clk_d4_ck,		CK_TI811X),
+	CLK(NULL,		"gmac_125_clk_d5_ck",		&gmac_125_clk_d5_ck,		CK_TI811X),
+	CLK(NULL,		"gmac_125_clk_d2_ck",		&gmac_125_clk_d2_ck,		CK_TI811X),
+	CLK(NULL,		"gmac_50_clk_mux_out_ck",	&gmac_50_clk_mux_out_ck,	CK_TI811X),
+	CLK(NULL,		"emac_rmii_fck",		&emac_rmii_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"emac_gmii_fck",		&emac_gmii_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"icss_ocp_ck",			&icss_ocp_ck,			CK_TI811X),
+	CLK(NULL,		"icss_oep_ck",			&icss_oep_ck,			CK_TI811X),
+	CLK("omap_wdt",		"wdt1_fck",			&wdt1_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK("omap_wdt",		"wdt2_fck",			&wdt2_fck,			CK_TI814X | CK_DM385 | CK_TI811X),
 	CLK(NULL,		"dummy_clk_ck",			&dummy_clk_ck,			CK_DM385),
-	CLK(NULL,		"clkout_prcm_mux_ck",		&clkout_prcm_mux_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"clkout_prcm_ck",		&clkout_prcm_ck,		CK_TI814X | CK_DM385),
-	CLK(NULL,		"sys_clkout1",			&sys_clkout1,			CK_TI814X | CK_DM385),
-	CLK(NULL,		"sys_clkout2",			&sys_clkout2,			CK_TI814X | CK_DM385),
+	CLK(NULL,		"clkout_prcm_mux_ck",		&clkout_prcm_mux_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"clkout_prcm_ck",		&clkout_prcm_ck,		CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sys_clkout1",			&sys_clkout1,			CK_TI814X | CK_DM385 | CK_TI811X),
+	CLK(NULL,		"sys_clkout2",			&sys_clkout2,			CK_TI814X | CK_DM385 | CK_TI811X),
 };
 
 void _update_fixed_divisors(void)
 {
 	if (cpu_is_dm385() || (cpu_is_ti814x() &&
-			omap_rev() > TI8148_REV_ES1_0)) {
+			omap_rev() > TI8148_REV_ES1_0) || cpu_is_ti811x()) {
 		usb_dpll_div5_ck.fixed_div = 1;
 	} else {
 		usb_dpll_div5_ck.fixed_div = 5;
 	}
+	/* EMIF CLK GATE register addr changed between PG1.0 and 2.0 for TI814X */
+	if(!(cpu_is_ti814x() &&
+		omap_rev() == TI8148_REV_ES1_0)) {
+		ddr0_phy_fck.enable_reg = TI814X_PLL_CMGC_EMIF_CLK_GATE_PG2;
+		ddr0_half_fck.enable_reg = TI814X_PLL_CMGC_EMIF_CLK_GATE_PG2;
+		ddr1_phy_fck.enable_reg = TI814X_PLL_CMGC_EMIF_CLK_GATE_PG2;
+		ddr1_half_fck.enable_reg = TI814X_PLL_CMGC_EMIF_CLK_GATE_PG2;
+	}
 }
 
 void _update_data_for_dm385(void)
@@ -4532,6 +4441,38 @@
 	sys_clkout2.clksel	= clkout0to10_385_mux_sel;
 }
 
+void _update_data_for_ti811x(void)
+{
+	sysclk4_ck.parent	= &iss_dpll_d2_ck;
+	cpts_rft_clk_ck.clksel	= cpts0to4_rft_clk_mux_811x_sel;
+	emac_gmii_fck.parent	= &gmac_125_clk_d2_ck;
+	emac_rmii_fck.clksel	= rmii_811x_mux_sel;
+	rtc_c32k_fck.parent	= &osc_32k_ck;
+	audio_prcm_clkin_ck.clksel	= rtc_clkin32_mux_811x_sel;
+
+	/* gptimer no of inputs and sources changed */
+	gpt1_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt1_fck.clksel_mask	= TI811X_DMTIMER1_CLKS_MASK;
+	gpt2_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt2_fck.clksel_mask	= TI811X_DMTIMER2_CLKS_MASK;
+	gpt3_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt3_fck.clksel_mask	= TI811X_DMTIMER3_CLKS_MASK;
+	gpt4_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt4_fck.clksel_mask	= TI811X_DMTIMER4_CLKS_MASK;
+	gpt5_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt5_fck.clksel_mask	= TI811X_DMTIMER5_CLKS_MASK;
+	gpt6_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt6_fck.clksel_mask	= TI811X_DMTIMER6_CLKS_MASK;
+	gpt7_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt7_fck.clksel_mask	= TI811X_DMTIMER7_CLKS_MASK;
+	gpt8_fck.clksel		= gpt0to8_fclk_mux_811x_sel;
+	gpt8_fck.clksel_mask	= TI811X_DMTIMER8_CLKS_MASK;
+
+	clkout_prcm_mux_ck.clksel	= clkout0to3_811x_mux_sel;
+	sys_clkout1.clksel		= clkout0to10_811x_mux_sel;
+	sys_clkout2.clksel		= clkout0to10_811x_mux_sel;
+}
+
 int __init ti814x_clk_init(void)
 {
 	struct omap_clk *c;
@@ -4541,6 +4482,9 @@
 		if (cpu_is_dm385()) {
 			cpu_mask = RATE_IN_DM385;
 			cpu_clkflg = CK_DM385;
+		} else if (cpu_is_ti811x()) {
+			cpu_mask = RATE_IN_TI811X;
+			cpu_clkflg = CK_TI811X;
 		} else {
 			cpu_mask = RATE_IN_TI814X;
 			cpu_clkflg = CK_TI814X;
@@ -4549,6 +4493,8 @@
 	_update_fixed_divisors();
 	if (cpu_is_dm385())
 		_update_data_for_dm385();
+	if (cpu_is_ti811x())
+		_update_data_for_ti811x();
 
 	clk_init(&omap2_clk_functions);
 
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clockdomains81xx.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clockdomains81xx.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/clockdomains81xx.h	2014-08-07 14:42:24.000000000 -0600
@@ -48,7 +48,7 @@
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 #endif
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X |
-					 CHIP_IS_DM385),
+					 CHIP_IS_DM385 | CHIP_IS_TI811X),
 };
 
 static struct clockdomain alwon_l3_med_81xx_clkdm = {
@@ -63,7 +63,7 @@
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 #endif
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X |
-					 CHIP_IS_DM385),
+					 CHIP_IS_DM385 | CHIP_IS_TI811X),
 };
 
 static struct clockdomain alwon_l3_fast_81xx_clkdm = {
@@ -78,7 +78,7 @@
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 #endif
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X |
-					 CHIP_IS_DM385),
+					 CHIP_IS_DM385 | CHIP_IS_TI811X),
 };
 
 static struct clockdomain alwon_ethernet_81xx_clkdm = {
@@ -93,7 +93,7 @@
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 #endif
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X |
-					 CHIP_IS_DM385),
+					 CHIP_IS_DM385 | CHIP_IS_TI811X),
 };
 
 /* OCMC clock domain */
@@ -104,7 +104,8 @@
 	.clkdm_offs	= TI814X_CM_OCMC_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 static struct clockdomain mmu_81xx_clkdm = {
@@ -119,7 +120,7 @@
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 #endif
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X |
-					 CHIP_IS_DM385),
+					CHIP_IS_DM385 | CHIP_IS_TI811X),
 };
 
 static struct clockdomain mmu_cfg_81xx_clkdm = {
@@ -134,7 +135,7 @@
 	.flags		= CLKDM_CAN_HWSUP_SWSUP,
 #endif
 	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X |
-					 CHIP_IS_DM385),
+					CHIP_IS_DM385 | CHIP_IS_TI811X),
 };
 
 /*
@@ -148,7 +149,7 @@
 	.clkdm_offs	= TI814X_CM_DSP_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_TI811X),
 };
 
 static struct clockdomain ivahd_814x_clkdm = {
@@ -169,7 +170,8 @@
 	.clkdm_offs	= TI814X_CM_ALWON2_MC_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 /* GFX clock domain */
@@ -180,7 +182,8 @@
 	.clkdm_offs	= TI814X_CM_GFX_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X |
+				CHIP_IS_TI811X),
 };
 
 /* DSS clock domain */
@@ -191,7 +194,8 @@
 	.clkdm_offs	= TI814X_CM_HDVPSS_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 /* ISP clock domain */
@@ -214,7 +218,8 @@
 	.clkdm_offs	= TI814X_CM_ALWON2_L3_MED_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 /* PCIe clock domain */
@@ -225,7 +230,8 @@
 	.clkdm_offs	= TI814X_CM_ALWON2_PCI_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 
@@ -247,7 +253,8 @@
 	.clkdm_offs	= TI814X_CM_ALWON2_L3_SLOW_CLKDM,
 	.clktrctrl_mask	= TI81XX_CLKTRCTRL_MASK,
 	.flags		= CLKDM_CAN_SWSUP,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 /*
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/control.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/control.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/control.h	2014-08-07 14:42:24.000000000 -0600
@@ -16,7 +16,7 @@
 #ifndef __ARCH_ARM_MACH_OMAP2_CONTROL_H
 #define __ARCH_ARM_MACH_OMAP2_CONTROL_H
 
-#include <mach/io.h>
+#include <asm/io.h>
 #include <mach/ctrl_module_core_44xx.h>
 #include <mach/ctrl_module_wkup_44xx.h>
 #include <mach/ctrl_module_pad_core_44xx.h>
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/gpmc-nand.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/gpmc-nand.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/gpmc-nand.c	2014-08-07 14:42:24.000000000 -0600
@@ -69,11 +69,6 @@
 	t.cs_wr_off = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->cs_wr_off);
 	t.wr_cycle  = gpmc_round_ns_to_ticks(gpmc_nand_data->gpmc_t->wr_cycle);
 
-	/* Configure GPMC */
-	if (gpmc_nand_data->devsize == NAND_BUSWIDTH_16)
-		gpmc_cs_configure(gpmc_nand_data->cs, GPMC_CONFIG_DEV_SIZE, 1);
-	else
-		gpmc_cs_configure(gpmc_nand_data->cs, GPMC_CONFIG_DEV_SIZE, 0);
 	gpmc_cs_configure(gpmc_nand_data->cs,
 			GPMC_CONFIG_DEV_TYPE, GPMC_DEVICETYPE_NAND);
 	err = gpmc_cs_set_timings(gpmc_nand_data->cs, &t);
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/hsmmc.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/hsmmc.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/hsmmc.c	2014-08-07 14:42:24.000000000 -0600
@@ -261,6 +261,8 @@
 		}
 
 		if (cpu_is_ti81xx())
+                       mmc->version = MMC_CTRL_VERSION_2;
+		if (cpu_is_ti816x())
 			mmc->version = MMC_CTRL_VERSION_2;
 
 		if (c->name)
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/id.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/id.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/id.c	2014-08-07 14:42:24.000000000 -0600
@@ -382,15 +382,19 @@
 		case 1:
 			omap_revision = TI8168_REV_ES1_1;
 			strcpy(cpu_rev, "1.1");
-			break;	
+			break;
 		case 2:
-			/* FALLTHROUGH */
-		default:
 			omap_revision = TI8168_REV_ES2_0;
 			strcpy(cpu_rev, "2.0");
+			break;
+		case 3:
+			/* FALLTHROUGH */
+		default:
+			omap_revision = TI8168_REV_ES2_1;
+			strcpy(cpu_rev, "2.1");
 		}
 
-		omap3_features |= OMAP3_HAS_DSP;
+		omap3_features |= OMAP3_HAS_DSP | OMAP3_HAS_IVA;
 		pr_info("OMAP chip is TI8168 %s\n", cpu_rev);
 		return;
 	} else if ((partnum == 0xb8f2)) {
@@ -420,7 +424,7 @@
 			strcpy(cpu_rev, "2.0");
 		}
 
-		omap3_features |= OMAP3_HAS_DSP;
+		omap3_features |= OMAP3_HAS_DSP | OMAP3_HAS_IVA;
 		pr_info("OMAP chip is TI8148 %s\n", cpu_rev);
 		return;
 	} else if ((partnum == 0xb96b)) {
@@ -434,8 +438,23 @@
 			strcpy(cpu_rev, "1.0");
 		}
 
+		omap3_features |= OMAP3_HAS_IVA;
 		pr_info("OMAP chip is DM385 %s\n", cpu_rev);
 		return;
+	} else if ((partnum == 0xb968)) {
+		omap_chip.oc |= CHIP_IS_TI811X;
+
+		switch (rev) {
+		case 0:
+			/* FALLTHROUGH */
+		default:
+			omap_revision = TI8148_REV_ES1_0;
+			strcpy(cpu_rev, "1.0");
+		}
+
+		omap3_features |= OMAP3_HAS_DSP;
+		pr_info("OMAP chip is TI811X %s\n", cpu_rev);
+		return;
 	}
 
 	pr_err("Unknown TI81XX CPU id\n");
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/board-ti811x.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/board-ti811x.h	2014-08-07 11:51:57.626748451 -0600
@@ -0,0 +1,50 @@
+/*
+ * arch/arm/mach-omap2/include/mach/board-ti811x.h
+ *
+ * Header file for TI811x evm.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _BOARD_TI811X_H
+#define _BOARD_TI811X_H
+
+#include <plat/ti81xx-vpss.h>
+
+#define VPS_SEL_TVP7002_DECODER	0
+#define VPS_SEL_SIL9135_DECODER	1
+
+#ifdef CONFIG_ARCH_TI814X
+int ti811x_pcf8575_init(void);
+int ti811x_pcf8575_exit(void);
+int vps_ti811x_select_video_decoder(int vid_decoder_id);
+int vps_ti811x_set_tvp7002_filter(enum fvid2_standard standard);
+#else
+static inline int ti811x_pcf8575_init(void)
+{
+	return 0;
+}
+static inline int ti811x_pcf8575_exit(void)
+{
+	return 0;
+}
+int vps_ti811x_select_video_decoder(int vid_decoder_id)
+{
+	return 0;
+}
+int vps_ti811x_set_tvp7002_filter(enum fvid2_standard standard)
+{
+	return 0;
+}
+#endif
+#endif /* _BOARD_TI811X_H */
+
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/board-ti816x.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/board-ti816x.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/board-ti816x.h	2014-08-07 11:51:57.686748448 -0600
@@ -22,49 +22,27 @@
 #define VPS_SEL_TVP7002_DECODER	0
 #define VPS_SEL_SIL9135_DECODER	1
 
-
-enum ti816x_ths_filter_ctrl {
-	TI816X_THSFILTER_ENABLE_MODULE = 0,
-	TI816X_THSFILTER_BYPASS_MODULE,
-	TI816X_THSFILTER_DISABLE_MODULE
-};
-
-/* \brief Enum for selecting filter for component input/output in THS7360 */
-enum ti816x_ths7360_sf_ctrl {
-	TI816X_THS7360_DISABLE_SF = 0,
-	TI816X_THS7360_BYPASS_SF,
-	TI816X_THS7360_SF_SD_MODE,
-	TI816X_THS7360_SF_ED_MODE,
-	TI816X_THS7360_SF_HD_MODE,
-	TI816X_THS7360_SF_TRUE_HD_MODE
-};
-
 #ifdef CONFIG_ARCH_TI816X
-int pcf8575_ths7375_enable(enum ti816x_ths_filter_ctrl ctrl);
-int pcf8575_ths7360_sd_enable(enum ti816x_ths_filter_ctrl ctrl);
-int pcf8575_ths7360_hd_enable(enum ti816x_ths7360_sf_ctrl ctrl);
+int pcf8575_ths7360_sd_enable(enum ti81xx_ths_filter_ctrl ctrl);
+int pcf8575_ths7360_hd_enable(enum ti81xx_ths7360_sf_ctrl ctrl);
 int ti816x_pcf8575_init(void);
 int ti816x_pcf8575_exit(void);
 int vps_ti816x_select_video_decoder(int vid_decoder_id);
 int vps_ti816x_set_tvp7002_filter(enum fvid2_standard standard);
 #else
-int pcf8575_ths7375_enable(enum ti816x_ths_filter_ctrl ctrl)
-{
-	return 0;
-}
-int pcf8575_ths7360_sd_enable(enum ti816x_ths_filter_ctrl ctrl)
+static inline int pcf8575_ths7360_sd_enable(enum ti81xx_ths_filter_ctrl ctrl)
 {
 	return 0;
 }
-int pcf8575_ths7360_hd_enable(enum ti816x_ths7360_sf_ctrl ctrl)
+static inline int pcf8575_ths7360_hd_enable(enum ti81xx_ths7360_sf_ctrl ctrl)
 {
 	return 0;
 }
-int ti816x_pcf8575_init(void)
+static inline int ti816x_pcf8575_init(void)
 {
 	return 0;
 }
-int ti816x_pcf8575_exit(void)
+static inline int ti816x_pcf8575_exit(void)
 {
 	return 0;
 }
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/mux.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/mux.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/mux.c	2014-08-07 14:42:24.000000000 -0600
@@ -504,6 +504,7 @@
 
 }
 #endif /* CONFIG_ARCH_TI81XX */
+
 #define OMAP_MUX_DEFNAME_LEN	32
 
 static int omap_mux_dbg_board_show(struct seq_file *s, void *unused)
@@ -545,7 +546,10 @@
 		 * same OMAP generation.
 		 */
 		seq_printf(s, "OMAP%d_MUX(%s, ", omap_gen, m0_def);
-		omap_mux_decode(s, val);
+		if(cpu_is_ti81xx())
+			ti81xx_mux_decode(s, val);
+		else
+			omap_mux_decode(s, val);
 		seq_printf(s, "),\n");
 	}
 
@@ -608,22 +612,43 @@
 			m->balls[0] ? m->balls[0] : none,
 			m->balls[1] ? m->balls[1] : none);
 	seq_printf(s, "mode: ");
-	omap_mux_decode(s, val);
+	if(cpu_is_ti81xx())
+		ti81xx_mux_decode(s, val);
+	else
+		omap_mux_decode(s, val);
 	seq_printf(s, "\n");
-	seq_printf(s, "signals: %s | %s | %s | %s | %s | %s | %s | %s\n",
-			m->muxnames[0] ? m->muxnames[0] : none,
-			m->muxnames[1] ? m->muxnames[1] : none,
-			m->muxnames[2] ? m->muxnames[2] : none,
-			m->muxnames[3] ? m->muxnames[3] : none,
-			m->muxnames[4] ? m->muxnames[4] : none,
-			m->muxnames[5] ? m->muxnames[5] : none,
-			m->muxnames[6] ? m->muxnames[6] : none,
-			m->muxnames[7] ? m->muxnames[7] : none);
+
+	if (cpu_is_ti811x())
+		seq_printf(s, "signals: %s | %s | %s | %s | %s | %s | %s | %s "
+				"| %s | %s | %s | %s\n",
+				m->muxnames[0] ? m->muxnames[0] : none,
+				m->muxnames[1] ? m->muxnames[1] : none,
+				m->muxnames[2] ? m->muxnames[2] : none,
+				m->muxnames[3] ? m->muxnames[3] : none,
+				m->muxnames[4] ? m->muxnames[4] : none,
+				m->muxnames[5] ? m->muxnames[5] : none,
+				m->muxnames[6] ? m->muxnames[6] : none,
+				m->muxnames[7] ? m->muxnames[7] : none,
+				m->muxnames[8] ? m->muxnames[8] : none,
+				m->muxnames[9] ? m->muxnames[9] : none,
+				m->muxnames[10] ? m->muxnames[10] : none,
+				m->muxnames[11] ? m->muxnames[11] : none);
+	else
+		seq_printf(s, "signals: %s | %s | %s | %s | %s | %s | %s "
+				"| %s\n",
+				m->muxnames[0] ? m->muxnames[0] : none,
+				m->muxnames[1] ? m->muxnames[1] : none,
+				m->muxnames[2] ? m->muxnames[2] : none,
+				m->muxnames[3] ? m->muxnames[3] : none,
+				m->muxnames[4] ? m->muxnames[4] : none,
+				m->muxnames[5] ? m->muxnames[5] : none,
+				m->muxnames[6] ? m->muxnames[6] : none,
+				m->muxnames[7] ? m->muxnames[7] : none);
 
 	return 0;
 }
 
-#define OMAP_MUX_MAX_ARG_CHAR  7
+#define OMAP_MUX_MAX_ARG_CHAR  11
 
 static ssize_t omap_mux_dbg_signal_write(struct file *file,
 					 const char __user *user_buf,
@@ -648,9 +673,13 @@
 	ret = strict_strtoul(buf, 0x10, &val);
 	if (ret < 0)
 		return ret;
-
-	if (val > 0xffff)
-		return -EINVAL;
+	if(cpu_is_ti814x()) {
+		if (val > 0xffffffff)
+			return -EINVAL;
+	} else {
+		if (val > 0xffff)
+			return -EINVAL;
+	}
 
 	seqf = file->private_data;
 	m = seqf->private;
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/omap_hwmod_81xx_data.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/omap_hwmod_81xx_data.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/omap_hwmod_81xx_data.c	2014-08-07 14:42:24.000000000 -0600
@@ -94,6 +94,8 @@
 static struct omap_hwmod ti81xx_gpio2_hwmod;
 static struct omap_hwmod ti814x_gpio3_hwmod;
 static struct omap_hwmod ti814x_gpio4_hwmod;
+static struct omap_hwmod ti814x_gpio5_hwmod;
+static struct omap_hwmod ti814x_gpio6_hwmod;
 static struct omap_hwmod ti81xx_usbss_hwmod;
 static struct omap_hwmod ti81xx_elm_hwmod;
 struct omap_hwmod_ocp_if ti81xx_l4_slow__elm;
@@ -381,11 +383,47 @@
 	.user		= OCP_USER_MPU | OCP_USER_SDMA,
 };
 
+/* L4 SLOW -> GPIO5 */
+static struct omap_hwmod_addr_space ti814x_gpio5_addrs[] = {
+	{
+		.pa_start	= TI811X_GPIO4_BASE,
+		.pa_end		= TI811X_GPIO4_BASE + SZ_4K - 1,
+		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if ti814x_l4_slow__gpio5 = {
+	.master		= &ti816x_l4_slow_hwmod,
+	.slave		= &ti814x_gpio5_hwmod,
+	.addr		= ti814x_gpio5_addrs,
+	.addr_cnt	= ARRAY_SIZE(ti814x_gpio5_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
+/* L4 SLOW -> GPIO6 */
+static struct omap_hwmod_addr_space ti814x_gpio6_addrs[] = {
+	{
+		.pa_start	= TI811X_GPIO5_BASE,
+		.pa_end		= TI811X_GPIO5_BASE + SZ_4K - 1,
+		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
+	},
+};
+
+static struct omap_hwmod_ocp_if ti814x_l4_slow__gpio6 = {
+	.master		= &ti816x_l4_slow_hwmod,
+	.slave		= &ti814x_gpio6_hwmod,
+	.addr		= ti814x_gpio6_addrs,
+	.addr_cnt	= ARRAY_SIZE(ti814x_gpio6_addrs),
+	.user		= OCP_USER_MPU | OCP_USER_SDMA,
+};
+
 /* Slave interfaces on the L4_SLOW interconnect */
 static struct omap_hwmod_ocp_if *ti816x_l4_slow_slaves[] = {
 	&ti816x_l3_slow__l4_slow,
 };
 
+
+
 /* Master interfaces on the L4_SLOW interconnect */
 static struct omap_hwmod_ocp_if *ti816x_l4_slow_masters[] = {
 	&ti816x_l4_slow__uart1,
@@ -654,7 +692,7 @@
 	.slaves		= ti814x_uart4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(ti814x_uart4_slaves),
 	.class		= &uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_TI811X),
 };
 
 /* UART5 */
@@ -687,7 +725,7 @@
 	.slaves		= ti814x_uart5_slaves,
 	.slaves_cnt	= ARRAY_SIZE(ti814x_uart5_slaves),
 	.class		= &uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_TI811X),
 };
 
 /* UART6 */
@@ -720,7 +758,7 @@
 	.slaves		= ti814x_uart6_slaves,
 	.slaves_cnt	= ARRAY_SIZE(ti814x_uart6_slaves),
 	.class		= &uart_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_TI811X),
 };
 
 /* Watchdog */
@@ -760,7 +798,8 @@
 	.slaves		= ti814x_wd_timer1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(ti814x_wd_timer1_slaves),
 	.class		= &wd_timer_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 	.flags	  = HWMOD_INIT_NO_RESET,
 };
 
@@ -859,7 +898,8 @@
 	.slaves         = ti814x_i2c3_slaves,
 	.slaves_cnt     = ARRAY_SIZE(ti814x_i2c3_slaves),
 	.class          = &i2c_class,
-	.omap_chip      = OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip      = OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 /* I2C4 */
@@ -892,7 +932,8 @@
 	.slaves		= ti814x_i2c4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(ti814x_i2c4_slaves),
 	.class		= &i2c_class,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 /* ELM */
@@ -946,8 +987,7 @@
 	.mpu_irqs_cnt	= ARRAY_SIZE(ti81xx_elm_irqs),
 	.slaves			= ti81xx_elm_slaves,
 	.slaves_cnt		= ARRAY_SIZE(ti81xx_elm_slaves),
-	.omap_chip		= OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X
-						| CHIP_IS_DM385),
+	.omap_chip		= OMAP_CHIP_INIT(CHIP_IS_TI81XX),
 };
 
 /* GPIO1 TI81XX */
@@ -1052,7 +1092,8 @@
 	.dev_attr	= &gpio_dev_attr,
 	.slaves		= ti814x_gpio3_slaves,
 	.slaves_cnt	= ARRAY_SIZE(ti814x_gpio3_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 };
 
 /* GPIO4 TI814X*/
@@ -1087,7 +1128,78 @@
 	.dev_attr	= &gpio_dev_attr,
 	.slaves		= ti814x_gpio4_slaves,
 	.slaves_cnt	= ARRAY_SIZE(ti814x_gpio4_slaves),
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
+};
+
+/* GPIO5 TI811X*/
+
+static struct omap_hwmod_irq_info ti814x_gpio5_irqs[] = {
+	{ .irq = TI811X_IRQ_GPIO_4A },
+	{ .irq = TI811X_IRQ_GPIO_4B },
+};
+
+/* gpio4 slave ports */
+static struct omap_hwmod_ocp_if *ti814x_gpio5_slaves[] = {
+	&ti814x_l4_slow__gpio5,
+};
+
+static struct omap_hwmod_opt_clk gpio5_opt_clks[] = {
+	{ .role = "dbclk", .clk = "gpio5_dbck" },
+};
+
+static struct omap_hwmod ti814x_gpio5_hwmod = {
+	.name		= "gpio5",
+	.class		= &ti81xx_gpio_hwmod_class,
+	.mpu_irqs	= ti814x_gpio5_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(ti814x_gpio4_irqs),
+	.main_clk	= "gpio5_ick",
+	.prcm = {
+		.omap4 = {
+			.clkctrl_reg = TI81XX_CM_ALWON_GPIO_1_CLKCTRL,
+		},
+	},
+	.opt_clks	= gpio5_opt_clks,
+	.opt_clks_cnt	= ARRAY_SIZE(gpio4_opt_clks),
+	.dev_attr	= &gpio_dev_attr,
+	.slaves		= ti814x_gpio5_slaves,
+	.slaves_cnt	= ARRAY_SIZE(ti814x_gpio5_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI811X),
+};
+
+/* GPIO6 TI811X*/
+
+static struct omap_hwmod_irq_info ti814x_gpio6_irqs[] = {
+	{ .irq = TI811X_IRQ_GPIO_5A },
+	{ .irq = TI811X_IRQ_GPIO_5B },
+};
+
+/* gpio4 slave ports */
+static struct omap_hwmod_ocp_if *ti814x_gpio6_slaves[] = {
+	&ti814x_l4_slow__gpio6,
+};
+
+static struct omap_hwmod_opt_clk gpio6_opt_clks[] = {
+	{ .role = "dbclk", .clk = "gpio6_dbck" },
+};
+
+static struct omap_hwmod ti814x_gpio6_hwmod = {
+	.name		= "gpio6",
+	.class		= &ti81xx_gpio_hwmod_class,
+	.mpu_irqs	= ti814x_gpio6_irqs,
+	.mpu_irqs_cnt	= ARRAY_SIZE(ti814x_gpio6_irqs),
+	.main_clk	= "gpio6_ick",
+	.prcm = {
+		.omap4 = {
+			.clkctrl_reg = TI81XX_CM_ALWON_GPIO_1_CLKCTRL,
+		},
+	},
+	.opt_clks	= gpio6_opt_clks,
+	.opt_clks_cnt	= ARRAY_SIZE(gpio6_opt_clks),
+	.dev_attr	= &gpio_dev_attr,
+	.slaves		= ti814x_gpio6_slaves,
+	.slaves_cnt	= ARRAY_SIZE(ti814x_gpio6_slaves),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI811X),
 };
 
 /* L3 SLOW -> USBSS interface */
@@ -1177,6 +1289,8 @@
 	&ti81xx_gpio2_hwmod,
 	&ti814x_gpio3_hwmod,
 	&ti814x_gpio4_hwmod,
+	&ti814x_gpio5_hwmod,
+	&ti814x_gpio6_hwmod,
 	&ti81xx_usbss_hwmod,
 	&ti81xx_elm_hwmod,
 	NULL,
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pcie-ti81xx.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pcie-ti81xx.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pcie-ti81xx.c	2014-08-07 14:42:24.000000000 -0600
@@ -13,18 +13,6 @@
  * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
-/*
- * General TODO:
- * - All of the register accesses are through raw_read/writes which eat up lines
- *   especially when needed to mask bits before writing. Better to add
- *   read-mask-write kind of wrappers.
- * - Lots of private data to maintain - group together inside a structure and
- *   provide accessor functions?
- * - Possibility of adding hw de-initialization sequence (also, re-enumeration /
- *   PM impact)
- */
-
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/platform_device.h>
@@ -50,6 +38,7 @@
 static int msi_irq_base;
 static int msi_irq_num;
 static int force_x1;
+static int force_gen1;
 static int msi_inv;
 static unsigned short int device_id;
 
@@ -148,17 +137,17 @@
 
 static int get_and_clear_err(void)
 {
-	int status = __raw_readl(reg_virt + ERR_IRQ_STATUS_RAW);
+	int status = readl(reg_virt + ERR_IRQ_STATUS_RAW);
 
 	if (status) {
 		/* The PCIESS interrupt status buts are "write 0 to clear" */
-		__raw_writel(~status, reg_virt + ERR_IRQ_STATUS);
+		writel(~status, reg_virt + ERR_IRQ_STATUS);
 
 		/*
 		 * Clear all errors. We are not worried here about individual
 		 * status as no specific handling is required.
 		 */
-		__raw_writew(0xffff, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+		writew(0xffff, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 				PCI_STATUS);
 	}
 
@@ -249,21 +238,19 @@
 			start, end);
 
 	/* Set outbound translation size per window division */
-	__raw_writel(CFG_PCIM_WIN_SZ_IDX & 0x7, reg_virt + OB_SIZE);
+	writel(CFG_PCIM_WIN_SZ_IDX & 0x7, reg_virt + OB_SIZE);
 
 	tr_size = (1 << (CFG_PCIM_WIN_SZ_IDX & 0x7)) * SZ_1M;
 
 	/* Using Direct 1:1 mapping of RC <-> PCI memory space */
 	for (i = 0; (i < CFG_PCIM_WIN_CNT) && (start < end); i++) {
-		__raw_writel(start | 1, reg_virt + OB_OFFSET_INDEX(i));
-		__raw_writel(0,	reg_virt + OB_OFFSET_HI(i));
+		writel(start | 1, reg_virt + OB_OFFSET_INDEX(i));
+		writel(0,	reg_virt + OB_OFFSET_HI(i));
 		start += tr_size;
 	}
 
-	/* TODO: ensure unused translation regions are disabled */
-
 	/* Enable OB translation */
-	 __raw_writel(OB_XLAT_EN_VAL | __raw_readl(reg_virt + CMD_STATUS),
+	 writel(OB_XLAT_EN_VAL | readl(reg_virt + CMD_STATUS),
 			 reg_virt + CMD_STATUS);
 }
 
@@ -275,11 +262,10 @@
  */
 static inline void set_dbi_mode(void)
 {
-	 __raw_writel(DBI_CS2_EN_VAL | __raw_readl(reg_virt + CMD_STATUS),
+	 writel(DBI_CS2_EN_VAL | readl(reg_virt + CMD_STATUS),
 			 reg_virt + CMD_STATUS);
 
-	  /* FIXME: Need loop to check bit5 = 1? */
-	__raw_readl(reg_virt + CMD_STATUS);
+	readl(reg_virt + CMD_STATUS);
 }
 
 /**
@@ -290,20 +276,20 @@
  */
 static inline void clear_dbi_mode(void)
 {
-	__raw_writel(~DBI_CS2_EN_VAL & __raw_readl(reg_virt + CMD_STATUS),
+	writel(~DBI_CS2_EN_VAL & readl(reg_virt + CMD_STATUS),
 			reg_virt + CMD_STATUS);
 
 	  /* FIXME: Need loop to check bit5 = 1? */
-	__raw_readl(reg_virt + CMD_STATUS);
+	readl(reg_virt + CMD_STATUS);
 }
 
 static void disable_bars(void)
 {
 	set_dbi_mode();
 
-	__raw_writel(0, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+	writel(0, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 			PCI_BASE_ADDRESS_0);
-	__raw_writel(0, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+	writel(0, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 			PCI_BASE_ADDRESS_1);
 
 	clear_dbi_mode();
@@ -318,8 +304,6 @@
  * into specified (SoC/Board level) internal address space.
  *
  * Note: 1:1 mapping for internal addresses is used.
- *
- * TODO: Add 64-bit support
  */
 static void set_inbound_trans(void)
 {
@@ -327,10 +311,10 @@
 	set_dbi_mode();
 
 	/* Enable BAR0 */
-	__raw_writel(1, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+	writel(1, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 			PCI_BASE_ADDRESS_0);
 
-	__raw_writel(SZ_4K - 1, reg_virt +
+	writel(SZ_4K - 1, reg_virt +
 			SPACE0_LOCAL_CFG_OFFSET + PCI_BASE_ADDRESS_0);
 
 	clear_dbi_mode();
@@ -339,7 +323,7 @@
 	  * For BAR0, just setting bus address for inbound writes (MSI) should
 	  * be sufficient. Use physical address to avoid any conflicts.
 	  */
-	__raw_writel(reg_phys, reg_virt + SPACE0_LOCAL_CFG_OFFSET
+	writel(reg_phys, reg_virt + SPACE0_LOCAL_CFG_OFFSET
 				+ PCI_BASE_ADDRESS_0);
 
 	/* Configure BAR1 only if inbound window is specified */
@@ -356,10 +340,10 @@
 		 * address. This also ensures no overlapping with base/limit
 		 * regions (outbound).
 		 */
-		__raw_writel(ram_base, reg_virt + IB_START0_LO);
-		__raw_writel(0, reg_virt + IB_START0_HI);
-		__raw_writel(1, reg_virt + IB_BAR0);
-		__raw_writel(ram_base, reg_virt + IB_OFFSET0);
+		writel(ram_base, reg_virt + IB_START0_LO);
+		writel(0, reg_virt + IB_START0_HI);
+		writel(1, reg_virt + IB_BAR0);
+		writel(ram_base, reg_virt + IB_OFFSET0);
 
 		/*
 		 * Set BAR1 mask to accomodate inbound window
@@ -367,16 +351,16 @@
 
 		set_dbi_mode();
 
-		__raw_writel(1, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+		writel(1, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 				PCI_BASE_ADDRESS_1);
 
-		__raw_writel(ram_end - ram_base, reg_virt +
+		writel(ram_end - ram_base, reg_virt +
 			SPACE0_LOCAL_CFG_OFFSET + PCI_BASE_ADDRESS_1);
 
 		clear_dbi_mode();
 
 		/* Set BAR1 attributes and value in config space */
-		__raw_writel(ram_base | PCI_BASE_ADDRESS_MEM_PREFETCH,
+		writel(ram_base | PCI_BASE_ADDRESS_MEM_PREFETCH,
 				reg_virt + SPACE0_LOCAL_CFG_OFFSET
 				+ PCI_BASE_ADDRESS_1);
 
@@ -384,7 +368,7 @@
 		 * Enable IB translation only if BAR1 is set. BAR0 doesn't
 		 * require enabling IB translation as it is set up in h/w
 		 */
-		__raw_writel(IB_XLAT_EN_VAL | __raw_readl(reg_virt +
+		writel(IB_XLAT_EN_VAL | readl(reg_virt +
 					CMD_STATUS), reg_virt + CMD_STATUS);
 	}
 }
@@ -410,18 +394,23 @@
 	 * The chained irq handler installation would have replaced normal
 	 * interrupt driver handler so we need to take care of mask/unmask and
 	 * ack operation.
+	 *
+	 * Note: OMAP IRQ handler doesn't have mask_ack but the ack does both.
 	 */
-	desc->chip->mask(irq);
-	if (desc->chip->ack)
+	if (likely(desc->chip->ack))
 		desc->chip->ack(irq);
+	else if (desc->chip->mask_ack)
+		desc->chip->mask_ack(irq);
+	else
+		desc->chip->mask(irq);
 
-	status = __raw_readl(reg_virt + MSI0_IRQ_STATUS);
+	status = readl(reg_virt + MSI0_IRQ_STATUS);
 
 	/* FIXME: Use max loops count? */
 	while (status) {
 		bit = find_first_bit((unsigned long *)&status, 32);
 		generic_handle_irq(msi_irq_base + bit);
-		status = __raw_readl(reg_virt + MSI0_IRQ_STATUS);
+		status = readl(reg_virt + MSI0_IRQ_STATUS);
 	}
 
 	desc->chip->unmask(irq);
@@ -430,7 +419,7 @@
 static void ack_msi(unsigned int irq)
 {
 	unsigned int msi_num = irq - msi_irq_base;
-	__raw_writel((1 << (msi_num & 0x1f)), reg_virt + MSI0_IRQ_STATUS);
+	writel((1 << (msi_num & 0x1f)), reg_virt + MSI0_IRQ_STATUS);
 }
 
 /*
@@ -440,25 +429,24 @@
 static void ack_msi_inv(unsigned int irq)
 {
 	unsigned int msi_num = irq - msi_irq_base;
-	__raw_writel(~(1 << (msi_num & 0x1f)), reg_virt + MSI0_IRQ_STATUS);
+	writel(~(1 << (msi_num & 0x1f)), reg_virt + MSI0_IRQ_STATUS);
 }
 
 static void mask_msi(unsigned int irq)
 {
 	unsigned int msi_num = irq - msi_irq_base;
-	__raw_writel(1 << (msi_num & 0x1f), reg_virt + MSI0_IRQ_ENABLE_CLR);
+	writel(1 << (msi_num & 0x1f), reg_virt + MSI0_IRQ_ENABLE_CLR);
 }
 
 static void unmask_msi(unsigned int irq)
 {
 	unsigned int msi_num = irq - msi_irq_base;
-	__raw_writel(1 << (msi_num & 0x1f), reg_virt + MSI0_IRQ_ENABLE_SET);
+	writel(1 << (msi_num & 0x1f), reg_virt + MSI0_IRQ_ENABLE_SET);
 }
 
 /*
- * TODO: Add support for mask/unmask on remote devices (mask_msi_irq and
- * unmask_msi_irq). Note that, this may not work always - requires endpoints to
- * support mask bits capability.
+ * Note: mask/unmask on remote devices is NOT supported (mask_msi_irq and
+ * unmask_msi_irq through mask bits capability on endpoints.
  */
 
 static struct irq_chip ti81xx_msi_chip = {
@@ -502,8 +490,6 @@
  *
  * Assigns an MSI to endpoint and sets up corresponding irq. Also passes the MSI
  * information to the endpont.
- *
- * TODO: Add 64-bit addressing support
  */
 int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
 {
@@ -572,11 +558,6 @@
  * - 32-bit IO
  * - Legacy interrupt
  * - MSI (if enabled)
- *
- * TODO: Add
- * - Prefetchable memory
- * - 64-bit addressing support
- * - Additional delay/handshaking for EPs indulging in CRRS
  */
 static int ti81xx_pcie_setup(int nr, struct pci_sys_data *sys)
 {
@@ -612,42 +593,30 @@
 	 * scanning.
 	 */
 
-	plat_res = platform_get_resource_byname(pcie_pdev, IORESOURCE_MEM,
-						"pcie-nonprefetch");
-	if (!plat_res) {
-		pr_err(DRIVER_NAME ": no resource for non-prefetch memory\n");
-		goto err_memres;
-	}
-
-	res[0].start = plat_res->start;
-	res[0].end = plat_res->end;
-	res[0].name = "PCI Memory";
-	res[0].flags = IORESOURCE_MEM;
-
-#if 0
-	{
-		if (insert_resource(&iomem_resource, &res[0])) {
-			pr_err(DRIVER_NAME ": Failed to reserve memory res\n");
-			goto err_memres;
-	}
-#endif
 	/* Optional: io window */
 	plat_res = platform_get_resource_byname(pcie_pdev, IORESOURCE_IO,
 						"pcie-io");
 	if (!plat_res) {
 		pr_warning(DRIVER_NAME ": no resource for PCI I/O\n");
 	} else {
-		res[1].start = plat_res->start;
-		res[1].end = plat_res->end;
-		res[1].name = "PCI I/O";
-		res[1].flags = IORESOURCE_IO;
-
-		if (insert_resource(&ioport_resource, &res[1])) {
-			pr_err(DRIVER_NAME ": Failed to reserve io resource\n");
-			goto err_iores;
-		}
+		res[0].start = plat_res->start;
+		res[0].end = plat_res->end;
+		res[0].name = "PCI I/O";
+		res[0].flags = IORESOURCE_IO;
 	}
 
+	plat_res = platform_get_resource_byname(pcie_pdev, IORESOURCE_MEM,
+						"pcie-nonprefetch");
+	if (!plat_res) {
+		pr_err(DRIVER_NAME ": no resource for non-prefetch memory\n");
+		goto err_memres;
+	}
+
+	res[1].start = plat_res->start;
+	res[1].end = plat_res->end;
+	res[1].name = "PCI Memory";
+	res[1].flags = IORESOURCE_MEM;
+
 	/*
 	 * Note: Only one inbound window can be considered as BAR0 is set up for
 	 * application register space in h/w.
@@ -670,7 +639,7 @@
 
 	if (!reg_virt) {
 		pr_err(DRIVER_NAME ": PCIESS register memory remap failed\n");
-		goto err_ioremap;
+		goto err_memres;
 	}
 
 	pr_info(DRIVER_NAME ": Register base mapped @0x%08x\n", (int)reg_virt);
@@ -689,7 +658,7 @@
 	 * form GEN1 in either EP/RC modes. The software needs to initiate speed
 	 * change.
 	 */
-	__raw_writel(DIR_SPD | __raw_readl(
+	writel(DIR_SPD | readl(
 				reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2),
 			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2);
 
@@ -705,20 +674,44 @@
 	if (force_x1) {
 		u32 val;
 
-		val = __raw_readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+		pr_info(DRIVER_NAME ": forcing link width - x1\n");
+
+		val = readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 				LINK_CAP);
 		val = (val & ~(0x3f << 4)) | (1 << 4);
-		__raw_writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+		writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 				LINK_CAP);
 
-		val = __raw_readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2);
+		val = readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2);
 		val = (val & ~(0xff << 8)) | (1 << 8);
-		__raw_writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2);
+		writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2);
 
-		val = __raw_readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+		val = readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 				PL_LINK_CTRL);
 		val = (val & ~(0x3F << 16)) | (1 << 16);
-		__raw_writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+		writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+				PL_LINK_CTRL);
+	}
+
+	/*
+	 * Force GEN1 speeds - this may be required mainly in case of interop
+	 * issues if the other end is GEN1.
+	 */
+	if (force_gen1) {
+		u32 val;
+
+		pr_info(DRIVER_NAME ": forcing link speed - GEN1\n");
+
+		val = readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+				LINK_CAP);
+		val = (val & ~0xf) | 1;
+		writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+				LINK_CAP);
+
+		val = readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+				PL_LINK_CTRL);
+		val = (val & ~(0xF << 8)) | (1 << 8);
+		writel(val, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 				PL_LINK_CTRL);
 	}
 
@@ -727,7 +720,7 @@
 	 * come up with ID 0x8888.
 	 */
 	if (device_id)
-		__raw_writew(device_id, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+		writew(device_id, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
 				PCI_DEVICE_ID);
 
 	/*
@@ -736,7 +729,7 @@
 	 * L0 status as this will be handled by explicit L0 state checks during
 	 * enumeration.
 	 */
-	 __raw_writel(LTSSM_EN_VAL | __raw_readl(reg_virt + CMD_STATUS),
+	 writel(LTSSM_EN_VAL | readl(reg_virt + CMD_STATUS),
 			 reg_virt + CMD_STATUS);
 
 	 /* 100ms */
@@ -749,7 +742,7 @@
 	 * If at all we want to restore the default class-subclass values, the
 	 * best place would be after returning from pci_common_init ().
 	 */
-	__raw_writew(PCI_CLASS_BRIDGE_PCI,
+	writew(PCI_CLASS_BRIDGE_PCI,
 			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PCI_CLASS_DEVICE);
 
 	/*
@@ -758,41 +751,18 @@
 	 */
 	disable_bars();
 
-	set_outbound_trans(res[0].start, res[0].end);
+	set_outbound_trans(res[1].start, res[1].end);
 
 	/* Enable 32-bit IO addressing support */
-	__raw_writew(PCI_IO_RANGE_TYPE_32 | (PCI_IO_RANGE_TYPE_32 << 8),
+	writew(PCI_IO_RANGE_TYPE_32 | (PCI_IO_RANGE_TYPE_32 << 8),
 			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PCI_IO_BASE);
 
-	/*
-	 * FIXME: The IO Decode size bits in IO base and limit registers are
-	 * writable from host any time and during enumeration, the Linux PCI
-	 * core clears the lower 4-bits of these registers while writing lower
-	 * IO address. This makes IO upper address and limit registers to show
-	 * value as '0' and not the actual value as configured by the core
-	 * during enumeration. We need to re-write bits 0 of IO limit and base
-	 * registers again. Need to find if a post configuration hook is
-	 * possible. An easier and clear but possibly inefficient WA is to snoop
-	 * each config write and restore 32-bit IO decode configuration.
-	 */
-
-	/*
-	 * Setup as PCI master, also clear any pending  status bits.
-	 * FIXME: Nolonger needed as post-scan fixup handles this (see below).
-	 */
-#if 0
-	__raw_writel((__raw_readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET
-					+ PCI_COMMAND)
-			| CFG_PCIM_CSR_VAL),
-			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PCI_COMMAND);
-#endif
-
 	legacy_irq = platform_get_irq_byname(pcie_pdev, "legacy_int");
 
 	if (legacy_irq >= 0) {
-		__raw_writel(0xf, reg_virt + IRQ_ENABLE_SET);
+		writel(0xf, reg_virt + IRQ_ENABLE_SET);
 	} else {
-		__raw_writel(0xf, reg_virt + IRQ_ENABLE_CLR);
+		writel(0xf, reg_virt + IRQ_ENABLE_CLR);
 		pr_warning(DRIVER_NAME ": INTx disabled since no legacy IRQ\n");
 	}
 
@@ -830,11 +800,6 @@
 	 clk_put(pcie_ck);
 err_clkget:
 	 iounmap((void __iomem *)reg_virt);
-err_ioremap:
-	 if (res[1].flags == IORESOURCE_IO)
-		 release_resource(&res[1]);
-err_iores:
-	 release_resource(&res[0]);
 err_memres:
 	 kfree(res);
 
@@ -856,7 +821,7 @@
  */
 static int check_device(struct pci_bus *bus, int dev)
 {
-	if ((__raw_readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET + DEBUG0) &
+	if ((readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET + DEBUG0) &
 				LTSSM_STATE_MASK) != LTSSM_STATE_L0)
 		return 0;
 
@@ -907,7 +872,7 @@
 		if (bus != 1)
 			regval |= BIT(24);
 
-		__raw_writel(regval, reg_virt + CFG_SETUP);
+		writel(regval, reg_virt + CFG_SETUP);
 
 		addr = reg_virt + SPACE0_REMOTE_CFG_OFFSET;
 	}
@@ -932,13 +897,23 @@
 
 	spin_lock_irqsave(&ti81xx_pci_io_lock, flags);
 
-	__raw_writel(addr & 0xfffff000, reg_virt + IOBASE);
+	writel(addr & 0xfffff000, reg_virt + IOBASE);
 
 	/* Get the actual address in I/O space */
-	addr = reg_virt + SPACE0_IO_OFFSET + (addr & 0xffc);
+	addr = reg_virt + SPACE0_IO_OFFSET + (addr & 0xfff);
 
-	*value = __raw_readl(addr);
-	*value >>= ((addr & 3)*8);
+	switch (size) {
+	case 1:
+		*value = (u8)readb(addr);
+		break;
+	case 2:
+		*value = (u16)readw(addr);
+		break;
+	case 4:
+	default:
+		*value = readl(addr);
+		break;
+	}
 
 	spin_unlock_irqrestore(&ti81xx_pci_io_lock, flags);
 
@@ -957,7 +932,6 @@
 int ti81xx_pci_io_write(u32 addr, int size, u32 value)
 {
 	unsigned long flags;
-	u32 iospace_addr;
 
 	if (!IS_ALIGNED(addr, size))
 		return -1;
@@ -966,20 +940,24 @@
 
 	spin_lock_irqsave(&ti81xx_pci_io_lock, flags);
 
-	__raw_writel(addr & 0xfffff000, reg_virt + IOBASE);
+	writel(addr & 0xfffff000, reg_virt + IOBASE);
 
 	/* Get the actual address in I/O space */
-	iospace_addr = reg_virt + SPACE0_IO_OFFSET + (addr & 0xffc);
+	addr = reg_virt + SPACE0_IO_OFFSET + (addr & 0xfff);
 
-	if (size != 4) {
-		u32 shift = (addr & 3) * 8;
-		u32 mask = (size == 1 ? 0xff : 0xffff) << shift;
-		u32 readval = __raw_readl(iospace_addr);
-		value = ((value << shift) & mask) | (readval & ~mask);
+	switch (size) {
+	case 1:
+		writeb((u8)value, addr);
+		break;
+	case 2:
+		writew((u16)value, addr);
+		break;
+	case 4:
+	default:
+		writel((u32)value, addr);
+		break;
 	}
 
-	__raw_writel(value, iospace_addr);
-
 	spin_unlock_irqrestore(&ti81xx_pci_io_lock, flags);
 
 	return 0;
@@ -1011,7 +989,7 @@
 		return PCIBIOS_DEVICE_NOT_FOUND;
 	}
 
-	*value = __raw_readl(setup_config_addr(bus_num, PCI_SLOT(devfn),
+	*value = readl(setup_config_addr(bus_num, PCI_SLOT(devfn),
 				PCI_FUNC(devfn)) + (where & ~3));
 
 	if (size == 1)
@@ -1052,11 +1030,11 @@
 	addr = setup_config_addr(bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));
 
 	if (size == 4)
-		__raw_writel(value, addr + where);
+		writel(value, addr + where);
 	else if (size == 2)
-		__raw_writew(value, addr + where);
+		writew(value, addr + where);
 	else
-		__raw_writeb(value, addr + where);
+		writeb(value, addr + where);
 
 	/*
 	 * The h/w has a limitation where Config Writes don't signal aborts to
@@ -1080,12 +1058,41 @@
 	pr_info(DRIVER_NAME ": Starting PCI scan...\n");
 	if (nr == 0) {
 		bus = pci_scan_bus(0, &ti81xx_pci_ops, sys);
+		pr_info(DRIVER_NAME ": PCI scan done.\n");
 
 		/* Post enumeration fixups */
 		set_inbound_trans();
 
 		/* Bridges are not getting enabled by default! */
 		pci_assign_unassigned_resources();
+
+		/*
+		 * The IO Decode size bits in IO base and limit registers are
+		 * writable from host any time and during enumeration, the Linux
+		 * PCI core clears the lower 4-bits of these registers while
+		 * writing lower IO address. This makes IO upper address and
+		 * limit registers to show value as '0' and not the actual value
+		 * as configured by the core during enumeration. We need to
+		 * re-write bits 0 of IO limit and base registers again.
+		 *
+		 * Forcing the same after scan - it may be ok to also do this as
+		 * a quirk.
+		 *
+		 * Without this, the I/O behind bridge (RC) will be shows
+		 * incorrectly as:
+		 *
+		 * I/O behind bridge: 00000000-00000fff
+		 *
+		 * instead of:
+		 *
+		 * I/O behind bridge: 40000000-40000fff
+		 */
+
+		writew(readw(reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+					PCI_IO_BASE) | PCI_IO_RANGE_TYPE_32 |
+					(PCI_IO_RANGE_TYPE_32 << 8),
+					reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+					PCI_IO_BASE);
 	}
 
 	return bus;
@@ -1138,7 +1145,13 @@
 
 	msi_irq_base = pdata->msi_irq_base;
 	msi_irq_num = pdata->msi_irq_num;
-	force_x1 = pdata->force_x1;
+
+	/* Use from platform data only if not set throug params */
+	if (!force_x1)
+		force_x1 = pdata->force_x1;
+	if (!force_gen1)
+		force_gen1 = pdata->force_gen1;
+
 	msi_inv = pdata->msi_inv;
 	device_id = pdata->device_id;
 
@@ -1170,3 +1183,24 @@
 	return 0;
 }
 subsys_initcall(ti81xx_pcie_rc_init);
+
+static int __init pcie_setup(char *str)
+{
+	while (str) {
+		char *k = strchr(str, ',');
+
+		if (k)
+			*k++ = 0;
+
+		if (!strcmp(str, "x1"))
+			force_x1 = 1;
+		else if (!strcmp(str, "gen1"))
+			force_gen1 = 1;
+		else
+			pr_err("ti81xx-pcie: Unknown option `%s'\n", str);
+
+		str = k;
+	}
+	return 0;
+}
+early_param("pcie", pcie_setup);
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm-debug.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm-debug.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm-debug.c	2014-08-07 14:42:24.000000000 -0600
@@ -623,8 +623,15 @@
 	if (cpu_is_omap34xx())
 		pm_dbg_reg_modules = omap3_pm_reg_modules;
 	else if (cpu_is_ti814x()) {
-		pr_info("Debugfs: Only enabling/disabling deep sleep "
-			"and wakeup timer is supported now\n");
+
+		if(cpu_is_ti811x()) {
+			pr_debug("%s: PM debugfs entries not available"
+				"for this platform\n", __func__);
+			return -ENODEV;
+		}
+		else
+			pr_info("Debugfs: Only enabling/disabling deep sleep "
+				"and wakeup timer is supported now\n");
 	} else {
 		printk(KERN_ERR "%s: only OMAP3 supported\n", __func__);
 		return -ENODEV;
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm.c	2014-08-07 14:42:24.000000000 -0600
@@ -179,7 +179,7 @@
 {
 	_init_omap_device("mpu", &mpu_dev);
 
-	if (omap3_has_iva())
+	if (!cpu_is_ti81xx() && omap3_has_iva())
 		_init_omap_device("iva", &iva_dev);
 
 	if (cpu_is_omap44xx()) {
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/powerdomains3xxx_data.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/powerdomains3xxx_data.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/powerdomains3xxx_data.c	2014-08-07 14:42:24.000000000 -0600
@@ -302,6 +302,7 @@
 	&ivahd1_816x_pwrdm,
 	&ivahd2_816x_pwrdm,
 	&sgx_816x_pwrdm,
+	&rtc_811x_pwrdm,
 #endif
 	NULL
 };
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/powerdomains81xx.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/powerdomains81xx.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/powerdomains81xx.h	2014-08-07 14:42:24.000000000 -0600
@@ -29,7 +29,7 @@
 	.name		  = "alwon_pwrdm",
 	.prcm_offs	  = TI81XX_PRM_ALWON_MOD,
 	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X | CHIP_IS_TI814X |
-					   CHIP_IS_DM385),
+					CHIP_IS_DM385 | CHIP_IS_TI811X),
 };
 
 /*
@@ -39,7 +39,7 @@
 static struct powerdomain gem_814x_pwrdm = {
 	.name		= "gem_pwrdm",
 	.prcm_offs	= TI814X_PRM_DSP_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_TI811X),
 	.pwrsts		= PWRSTS_OFF_ON,
 };
 
@@ -53,14 +53,15 @@
 static struct powerdomain hdvpss_814x_pwrdm = {
 	.name		= "hdvpss_pwrdm",
 	.prcm_offs	= TI814X_PRM_HDVPSS_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_DM385 |
+					CHIP_IS_TI811X),
 	.pwrsts		= PWRSTS_OFF_ON,
 };
 
 static struct powerdomain sgx_814x_pwrdm = {
 	.name		= "sgx_pwrdm",
 	.prcm_offs	= TI814X_PRM_GFX_MOD,
-	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X),
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI814X | CHIP_IS_TI811X),
 	.pwrsts		= PWRSTS_OFF_ON,
 };
 
@@ -71,6 +72,12 @@
 	.pwrsts		= PWRSTS_OFF_ON,
 };
 
+/* TI811X only */
+static struct powerdomain rtc_811x_pwrdm = {
+	.name		= "rtc_pwrdm",
+	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_TI811X),
+};
+
 /*
  * TI816X only
  */
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/sleep814x.S
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/sleep814x.S	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/sleep814x.S	2014-08-07 14:42:24.000000000 -0600
@@ -19,12 +19,9 @@
 #include <asm/assembler.h>
 #include <plat/sram.h>
 #include <plat/ti81xx.h>
-#include <mach/io.h>
-
 #include "cm2xxx_3xxx.h"
 #include "prm2xxx_3xxx.h"
 #include "cm-regbits-81xx.h"
-#include "control.h"
 #include "cm81xx.h"
 
 /*
@@ -57,19 +54,86 @@
 #define OSC1_CTRL				0x046C
 
 /**
+ * ti81xx_do_wfi_sync - sync write paths from MPU and enter WFI
+ *
+ * This routine performs non-posted memory writes in MPU -> DDR and MPU -> L3
+ * paths to drain the async bridges in respective paths before entering WFI.
+ * This is required to avoid the write pointers in the bridges getting corrupted
+ * on master disconnect during WFI pending earlier posted transfers (e.g, DDR
+ * writes, device writes, cache flush etc).
+ *
+ * r0 & r1 are passed word pointers for locations on DDR & L3 mapped as Strongly
+ * Ordered (SO) to do non-posted writes on respective paths.
+ *
+ * Since it *must* be ensured that no posted writes happen on these paths
+ * *after* SO writes are performed, following constraints should be considered:
+ *	1) No D cache op should happen, it may lead to a L1/L2 line being evicted.
+ *		- We do avoid any cache operation for data during the time of SO
+ *		write and entering WFI.
+ *	2) No I cache op should happen. This is so because the PoU for Cortex A8
+ *	is on L2, thus, an instruction fetch can cause miss on L2 and may lead
+ *	to a line being evicted causing memory write.
+ *		- As seen below, the routine is aligned on 16 instruction (word)
+ *		boundary to ensure the code including WFI resides in the same
+ *		line and thus not causing cache fill.
+ *	3) Page table walk should be prevented after SO writes. This is
+ *	necessary since L2 plays role here too and can have miss leading to
+ *	eviction.
+ *		- The approach used for (2) above automatically ensures this.
+ *
+ * *** IMPORTANT ***
+ * Thus, above points must be honored before changing anything in this routine.
+ *
+ * Some of the simpler (but costlier) approaches could include:
+ *	a) Disable D cache
+ *	b) Disable L2 cache
+ *	c) Preload code in L2 cache and
+ *	d) TLB lockdown
+ */
+ENTRY(ti81xx_do_wfi_sync)
+	.align	6
+
+	stmfd	sp!, {r0-r3, lr}		@ push on stack
+
+	ldr	r2, [r0]
+	ldr	r3, [r1]
+
+	dsb					@ ensure sync of memory, cache,
+	isb					@ instruction execution etc.
+
+	str	r3, [r1]			@ SO write on L3 path
+	str	r2, [r0]			@ SO write on DDR
+
+	wfi
+
+	nop					@ ensure pipeline fill post isb
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	ldmfd	sp!, {r0-r3, pc}		@ pop and return
+ENDPROC(ti81xx_do_wfi_sync)
+
+/**
  * ti814x_cpu_suspend - Put DDR in self refresh and enter processor
  * idle/DeepSleep.
  *
  * This routine is supposed to be executed from internal RAM and expects the
  * array of base addresses of various registers required to enter idle are
  * passed in r0 _strictly_ in following order:
- * 	1) EMIF0 base virtual address [r0]
- * 	2) EMIF1 base virtual address [r1]
- * 	3) DMM base virtual address [r2]
- * 	4) PLL base virtual address [r3]
- * 	5) Control module base virtual address [r4]
- * 	6) Flag indicating whether to proceed for DeepSleep (non-zero = yes)
- * 	[r5]
+ *	1) EMIF0 base virtual address [r0]
+ *	2) EMIF1 base virtual address [r1]
+ *	3) DMM base virtual address [r2]
+ *	4) PLL base virtual address [r3]
+ *	5) Control module base virtual address [r4]
+ *	6) Flag indicating whether to proceed for DeepSleep (non-zero = yes)
+ *	[r5]
  *
  * The code loads these addresses taking r0 value as reference to the array in
  * registers starting from r0, that is, EMIF0 base virtual address goes into r0
@@ -77,7 +141,7 @@
  * rest in the code for other purpose (r7 to r12).
  *
  * Notes:
- * 	1) Support DeepSleep is untested so far
+ *	1) Support DeepSleep is untested so far
  *	2) It is assumed that no TLB management is required for this mode. E.g.,
  *	not doing any invalidate operation on TLBs.
  *	3) All targets for load/store in this file during the time DDR is in
@@ -207,6 +271,17 @@
 	strne	r8, [r3, #DEEPSLEEP_CONTROL]	@ enter DeepSleep
 	ldrne	r8, [r3, #DEEPSLEEP_CONTROL]	@ and readback
 
+	beq	do_wfi
+
+ds_completion_loop:
+	ldr   r8, [r3, #DEEPSLEEP_STATUS]
+	and   r8, r8, #0x1			@poll for DSCOMPLETE
+	cmp   r8, #0x1				@ == 1 if DSCOUNT equals timer
+	bne   ds_completion_loop
+
+	cmp	r5, #0				@don't enter wfi if enterd ds
+do_wfi:
+
 	wfieq					@ or WFI
 
 	/*
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/ti81xx_vpss.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/ti81xx_vpss.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/ti81xx_vpss.c	2014-08-07 14:42:24.000000000 -0600
@@ -35,6 +35,8 @@
 #include <mach/hardware.h>
 #include <mach/board-ti814x.h>
 #include <mach/board-ti816x.h>
+#include <mach/board-dm813x.h>
+#include <mach/board-ti811x.h>
 #include <asm/mach/map.h>
 
 
@@ -56,19 +58,105 @@
 	/*FIXME add platform data here*/
 	int r;
 	if (cpu_is_ti816x() || cpu_is_dm385()) {
-		if (cpu_is_dm385())
+		if (cpu_is_dm385()) {
 			vps_pdata.cpu = CPU_DM813X;
-		else
+			/*setup the ths filter functioin*/
+/*			vps_pdata.pcf_ths_init = dm813x_pcf8575_init;
+			vps_pdata.pcf_ths_exit = dm813x_pcf8575_exit;
+			vps_pdata.pcf_ths_hd_set =
+					dm813x_pcf8575_ths7360_hd_enable;
+			vps_pdata.pcf_ths_sd_set =
+					dm813x_pcf8575_ths7360_sd_enable;*/
+		} else {
 			vps_pdata.cpu = CPU_DM816X;
+			/*setup the ths filter functioin*/
+			vps_pdata.pcf_ths_init = ti816x_pcf8575_init;
+			vps_pdata.pcf_ths_exit = ti816x_pcf8575_exit;
+			vps_pdata.pcf_ths_hd_set = pcf8575_ths7360_hd_enable;
+			vps_pdata.pcf_ths_sd_set = pcf8575_ths7360_sd_enable;
+		}
 		vps_pdata.numvencs = 4;
 		vps_pdata.vencmask = (1 << VPS_DC_MAX_VENC) - 1;
+	} else if (cpu_is_ti811x()) {
+		vps_pdata.cpu = CPU_DM811X;
+		vps_pdata.numvencs = 3;
+		vps_pdata.vencmask = (1 << VPS_DC_MAX_VENC) - 1 \
+					- VPS_DC_VENC_HDCOMP;
+		/*setup the ths filter functioin*/
+		vps_pdata.pcf_ths_init = ti811x_pcf8575_init;
+		vps_pdata.pcf_ths_exit = ti811x_pcf8575_exit;
+		vps_pdata.pcf_ths_hd_set = NULL;
+		vps_pdata.pcf_ths_sd_set = NULL;
 	} else if (cpu_is_ti814x()) {
 		vps_pdata.cpu = CPU_DM814X;
 		vps_pdata.numvencs = 3;
 		vps_pdata.vencmask = (1 << VPS_DC_MAX_VENC) - 1 \
 					- VPS_DC_VENC_HDCOMP;
+		/*setup the ths filter functioin*/
+		vps_pdata.pcf_ths_init = ti814x_pcf8575_init;
+		vps_pdata.pcf_ths_exit = ti814x_pcf8575_exit;
+		vps_pdata.pcf_ths_hd_set = NULL;
+		vps_pdata.pcf_ths_sd_set = NULL;
 	}
 
+	/*set up the grpx connections*/
+	vps_pdata.numgrpx = VPS_DISP_GRPX_MAX_INST;
+	/*grpx0 out to hdmi*/
+	vps_pdata.gdata[0].snode = VPS_DC_GRPX0_INPUT_PATH;
+	vps_pdata.gdata[0].numends = 1;
+	vps_pdata.gdata[0].enode[0] = VPS_DC_HDMI_BLEND;
+
+	/*grpx1 out to HDCOMP(DM816X) or DVO2(other platform)*/
+	vps_pdata.gdata[1].snode = VPS_DC_GRPX1_INPUT_PATH;
+	vps_pdata.gdata[1].numends = 1;
+	if (cpu_is_ti816x())
+		vps_pdata.gdata[1].enode[0] = VPS_DC_HDCOMP_BLEND;
+	else
+		vps_pdata.gdata[1].enode[0] = VPS_DC_DVO2_BLEND;
+	/*grpx2 out to SD*/
+	vps_pdata.gdata[2].snode = VPS_DC_GRPX2_INPUT_PATH;
+	vps_pdata.gdata[2].numends = 1;
+	vps_pdata.gdata[2].enode[0] = VPS_DC_SDVENC_BLEND;
+
+
+	/*set up the v4l2 video display connections*/
+	vps_pdata.numvideo = 3;
+	/*/dev/video1 -> HDMI*/
+	vps_pdata.vdata[0].idx = 0;
+	vps_pdata.vdata[0].numedges = 2;
+	vps_pdata.vdata[0].snodes[0] = VPS_DC_VCOMP_MUX;
+	vps_pdata.vdata[0].snodes_inputid[0] = VPS_DC_BP0_INPUT_PATH;
+	vps_pdata.vdata[0].snodes[1] = VPS_DC_VCOMP;
+	vps_pdata.vdata[0].snodes_inputid[1] = VPS_DC_VCOMP_MUX;
+	vps_pdata.vdata[0].numoutput = 1;
+	vps_pdata.vdata[0].enodes[0] = VPS_DC_HDMI_BLEND;
+	vps_pdata.vdata[0].enodes_inputid[0] =
+			VPS_DC_CIG_NON_CONSTRAINED_OUTPUT;
+
+	/*/dev/video2 -> HDCOMP or DVO2*/
+	vps_pdata.vdata[1].idx = 1;
+	vps_pdata.vdata[1].numedges = 2;
+	vps_pdata.vdata[1].snodes[0] = VPS_DC_HDCOMP_MUX;
+	vps_pdata.vdata[1].snodes_inputid[0] = VPS_DC_BP1_INPUT_PATH;
+	vps_pdata.vdata[1].snodes[1] = VPS_DC_CIG_PIP_INPUT;
+	vps_pdata.vdata[1].snodes_inputid[1] = VPS_DC_HDCOMP_MUX;
+	vps_pdata.vdata[1].numoutput = 1;
+	if (cpu_is_ti816x())
+		vps_pdata.vdata[1].enodes[0] = VPS_DC_HDCOMP_BLEND;
+	else
+		vps_pdata.vdata[1].enodes[0] = VPS_DC_DVO2_BLEND;
+
+	vps_pdata.vdata[1].enodes_inputid[0] = VPS_DC_CIG_PIP_OUTPUT;
+
+	/*/dev/video3 is SD only*/
+	vps_pdata.vdata[2].idx = 2;
+	vps_pdata.vdata[2].numedges = 1;
+	vps_pdata.vdata[2].snodes_inputid[0] = VPS_DC_SEC1_INPUT_PATH;
+	vps_pdata.vdata[2].snodes[0] = VPS_DC_SDVENC_MUX;
+	vps_pdata.vdata[2].numoutput = 1;
+	vps_pdata.vdata[2].enodes[0] = VPS_DC_SDVENC_BLEND;
+	vps_pdata.vdata[2].enodes_inputid[0] = VPS_DC_SDVENC_MUX;
+
 	vpss_device.dev.platform_data = &vps_pdata;
 	r = platform_device_register(&vpss_device);
 	if (r)
@@ -117,7 +205,7 @@
 #define HDVPSS_CAPTURE_INST2_BASE	0x48105A00
 #define HDVPSS_CAPTURE_INST2_SIZE	1024u
 u8 ti81xx_card_name[] = "TI81xx_catalogue";
-struct ti81xxvin_interface tvp7002_pdata = {
+struct ti81xxvin_interface tvp5150_pdata = {
 	.clk_polarity = 0,
 	.hs_polarity = 0,
 	.vs_polarity = 1,
@@ -127,15 +215,16 @@
 };
 static struct ti81xxvin_subdev_info hdvpss_capture_sdev_info[] = {
 	{
-		.name	= TVP7002_INST0,
+		.name	= TVP5150_INST0,
 		.board_info = {
 			/* TODO Find the correct address
-				of the TVP7002 connected */
-			I2C_BOARD_INFO("tvp7002", 0x5d),
-			.platform_data = &tvp7002_pdata,
+				of the TVP5150 connected */
+			I2C_BOARD_INFO("tvp5150", 0x5c),
+			.platform_data = &tvp5150_pdata,
 		},
+		.force_sd_video = 1,
 		.vip_port_cfg = {
-			.ctrlChanSel = VPS_VIP_CTRL_CHAN_SEL_15_8,
+			.ctrlChanSel = VPS_VIP_CTRL_CHAN_SEL_7_0,
 			.ancChSel8b = VPS_VIP_ANC_CH_SEL_DONT_CARE,
 			.pixClkEdgePol = VPS_VIP_PIX_CLK_EDGE_POL_RISING,
 			.invertFidPol = 0,
@@ -158,10 +247,12 @@
 		},
 		.video_capture_mode =
 		   VPS_CAPT_VIDEO_CAPTURE_MODE_SINGLE_CH_NON_MUX_EMBEDDED_SYNC,
-		.video_if_mode = VPS_CAPT_VIDEO_IF_MODE_16BIT,
+//		.video_if_mode = VPS_CAPT_VIDEO_IF_MODE_16BIT,
+		.video_if_mode = VPS_CAPT_VIDEO_IF_MODE_8BIT,
 		.input_data_format = FVID2_DF_YUV422P,
+//		.input_data_format = FVID2_DF_YUV422I_YUYV,
 	},
-	{
+/*	{
 		.name	= TVP7002_INST1,
 		.board_info = {
 			I2C_BOARD_INFO("tvp7002", 0x5c),
@@ -194,6 +285,7 @@
 		.video_if_mode = VPS_CAPT_VIDEO_IF_MODE_16BIT,
 		.input_data_format = FVID2_DF_YUV422P,
 	},
+*/
 };
 
 static const struct v4l2_dv_preset hdvpss_inst0_inp0_presets[] = {
@@ -232,16 +324,20 @@
 			.index		= 0,
 			.name		= "Component",
 			.type		= V4L2_INPUT_TYPE_CAMERA,
-			.std		= V4L2_STD_UNKNOWN,
-			.capabilities	= V4L2_OUT_CAP_PRESETS,
+//			.std		= V4L2_STD_ALL,
+			.std		= V4L2_STD_NTSC,
+//			.capabilities	= V4L2_OUT_CAP_PRESETS,
+			.capabilities	= 0,
 		},
-		.subdev_name	= TVP7002_INST0,
-		.dv_presets	= hdvpss_inst0_inp0_presets,
-		.num_dv_presets	= ARRAY_SIZE(hdvpss_inst0_inp0_presets),
+		.subdev_name	= TVP5150_INST0,
+//		.dv_presets	= hdvpss_inst0_inp0_presets,
+//		.num_dv_presets	= ARRAY_SIZE(hdvpss_inst0_inp0_presets),
+		.dv_presets	= NULL,
+		.num_dv_presets	= NULL,
 	},
 };
 
-static const struct ti81xxvin_input hdvpss_inst1_inputs[] = {
+/*static const struct ti81xxvin_input hdvpss_inst1_inputs[] = {
 	{
 		.input = {
 			.index		= 0,
@@ -255,6 +351,8 @@
 		.num_dv_presets	= ARRAY_SIZE(hdvpss_inst2_inp0_presets),
 	},
 };
+*/
+
 
 /* 16 bit decoders are present on the Port A of VIP0 and VIP1 instances. Which
 represents the VIP0 and VIP2 instances in software. While Port B of VIP0 and
@@ -273,7 +371,7 @@
 		.inputs = hdvpss_inst0_inputs,
 		.input_count = 0,
 	},
-	.inst_config[2] = {
+/*	.inst_config[2] = {
 		.inputs = hdvpss_inst1_inputs,
 		.input_count = ARRAY_SIZE(hdvpss_inst1_inputs),
 	},
@@ -281,7 +379,7 @@
 		.inputs = hdvpss_inst1_inputs,
 		.input_count = 0,
 	},
-
+*/
 };
 
 static struct resource ti81xx_hdvpss_capture_resource[] = {
@@ -315,27 +413,34 @@
 	int r;
 	hdvpss_capture_dev.dev.platform_data = &ti81xx_hsvpss_capture_cfg;
 	if (cpu_is_ti814x()) {
-		hdvpss_capture_sdev_info[0].ti81xxvin_select_decoder =
-			vps_ti814x_select_video_decoder;
-		hdvpss_capture_sdev_info[0].ti81xxvin_set_mode =
-			vps_ti814x_set_tvp7002_filter;
+	printk("Hello cpu_is_ti814x\n");
+		hdvpss_capture_sdev_info[0].ti81xxvin_select_decoder = NULL;
+		//	vps_ti814x_select_video_decoder;
+		hdvpss_capture_sdev_info[0].ti81xxvin_set_mode = NULL;
+		//	vps_ti814x_set_tvp7002_filter;
 		hdvpss_capture_sdev_info[0].decoder_id = 0;
+		//hdvpss_capture_sdev_info[0].i2c_adapter_id = 3;
+		hdvpss_capture_sdev_info[0].i2c_adapter_id = 1;
 		hdvpss_capture_sdev_info[1].ti81xxvin_select_decoder =
 			NULL;
 		hdvpss_capture_sdev_info[1].ti81xxvin_set_mode =
 			NULL;
 		hdvpss_capture_sdev_info[1].decoder_id = 0;
+		hdvpss_capture_sdev_info[1].i2c_adapter_id = 3;
 	} else {
+	printk("Hello cpu_is_not_ti814x\n");
 		hdvpss_capture_sdev_info[0].ti81xxvin_select_decoder =
 			vps_ti816x_select_video_decoder;
 		hdvpss_capture_sdev_info[0].ti81xxvin_set_mode =
 			vps_ti816x_set_tvp7002_filter;
 		hdvpss_capture_sdev_info[0].decoder_id = 0;
+		hdvpss_capture_sdev_info[0].i2c_adapter_id = 2;
 		hdvpss_capture_sdev_info[1].ti81xxvin_select_decoder =
 			NULL;
 		hdvpss_capture_sdev_info[1].ti81xxvin_set_mode =
 			NULL;
 		hdvpss_capture_sdev_info[1].decoder_id = 0;
+		hdvpss_capture_sdev_info[1].i2c_adapter_id = 2;
 	}
 	r = platform_device_register(&hdvpss_capture_dev);
 	if (r)
@@ -348,7 +453,8 @@
 #else
 static int __init ti81xx_vin_init(void)
 {
-	return 0;
+	printk("Hello ti81xx_vin_init\n");
+return 0;
 }
 
 #endif
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/usb-musb.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/usb-musb.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/usb-musb.c	2014-08-07 14:42:24.000000000 -0600
@@ -376,13 +376,29 @@
 	} else if (cpu_is_ti81xx()) {
 
 		musb_config.fifo_mode = 4;
+		board_data->txfifo_intr_enable = 1;
+		board_data->usbphy_rxcalib_enable = 1;
+		board_data->phyctrl_enable = 1;
 
 		/* disable multipoint for ti816x for ES1_0/1_1 */
-		if (cpu_is_ti816x() && (omap_rev() != TI8168_REV_ES2_0)) {
-			musb_config.multipoint = 0;
-			board_data->babble_ctrl = 1;
+		if (cpu_is_ti816x()) {
+			board_data->usbphy_rxcalib_enable = 0;
+			if (omap_rev() < TI8168_REV_ES2_0) {
+				musb_config.multipoint = 0;
+				board_data->babble_ctrl = 1;
+				board_data->txfifo_intr_enable = 0;
+			}
+		} else if (!cpu_is_ti811x() && !cpu_is_dm385()
+			&& cpu_is_ti814x() && (omap_rev() < TI8148_REV_ES2_0)) {
+			board_data->txfifo_intr_enable = 0;
 		}
 
+		/* enable or disable the USB1 instance based on the
+		 * ti811x daughter card attched or not
+		 */
+		if (cpu_is_ti811x() && board_data->mode == MUSB_HOST)
+			board_data->instances = 1;
+
 		/* only usb0 port enabled in peripheral mode*/
 		if (board_data->mode == MUSB_PERIPHERAL) {
 			board_data->instances = 0;
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mm/mmu.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mm/mmu.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mm/mmu.c	2014-08-07 11:51:58.442748414 -0600
@@ -277,9 +277,12 @@
 		.domain    = DOMAIN_KERNEL,
 	},
 	[MT_STRONGLY_ORDERED] = {
-		.prot_sect = PMD_TYPE_SECT | PMD_SECT_AP_WRITE |
-				PMD_SECT_UNCACHED,
-		.domain = DOMAIN_KERNEL,
+		.prot_pte  = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY |
+				L_PTE_MT_UNCACHED,
+		.prot_l1   = PMD_TYPE_TABLE,
+		.prot_sect = PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_S |
+				PMD_SECT_UNCACHED | PMD_SECT_XN,
+		.domain    = DOMAIN_KERNEL,
 	},
 };
 
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/Makefile
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/Makefile	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/Makefile	2014-08-07 11:51:58.490748411 -0600
@@ -5,7 +5,7 @@
 # Common support
 ifeq ($(CONFIG_ARCH_TI81XX),y)
 obj-y := common.o sram.o clock.o devices.o mux.o gpio.o \
-	 usb.o fb.o io.o counter_32k.o hdmi_lib.o
+	 usb.o fb.o io.o counter_32k.o hdmi_lib.o hdcp_ddc.o hdcp_lib.o
 else
 obj-y := common.o sram.o clock.o devices.o dma.o mux.o gpio.o \
 	 usb.o fb.o io.o counter_32k.o
@@ -21,7 +21,8 @@
 obj-$(CONFIG_ARCH_OMAP2) += omap_device.o
 obj-$(CONFIG_ARCH_OMAP3) += omap_device.o
 obj-$(CONFIG_ARCH_OMAP4) += omap_device.o
-obj-$(CONFIG_ARCH_TI81XX) += omap_device.o sdma2edma.o hdmi_lib.o
+obj-$(CONFIG_ARCH_TI81XX) += omap_device.o sdma2edma.o hdmi_lib.o hdcp_ddc.o \
+	hdcp_lib.o
 
 obj-$(CONFIG_OMAP_MCBSP) += mcbsp.o
 obj-$(CONFIG_OMAP_IOMMU) += iommu.o iovmm.o
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/cpu-omap.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/cpu-omap.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/cpu-omap.c	2014-08-07 11:51:58.606748406 -0600
@@ -202,7 +202,7 @@
 	return ret;
 }
 
-static int __init omap_cpu_init(struct cpufreq_policy *policy)
+static int omap_cpu_init(struct cpufreq_policy *policy)
 {
 	int result = 0;
 
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/hdmi_lib.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/hdmi_lib.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/hdmi_lib.c	2014-08-07 11:51:58.662748403 -0600
@@ -42,8 +42,7 @@
 #include <plat/hdmi_lib.h>
 #include <linux/delay.h>
 #include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
+#include <linux/module.h>
 #include <linux/seq_file.h>
 #include <sound/pcm.h>
 #include <linux/hrtimer.h>
@@ -241,19 +240,12 @@
 #define HDMI_WP_IRQSTATUS_OCPTIMEOUT 0x00000010
 
 #define HDMI_CORE_SYS__SYS_STAT_HPD 0x02
-#define HDMI_CORE_SYS__SYS_STAT_RSEN 0x4
 
 #define HDMI_IP_CORE_SYSTEM__INTR2__BCAP	0x80
 #define HDMI_IP_CORE_SYSTEM__INTR3__RI_ERR	0xF0
 
 bool first_hpd, dirty;
 
-struct hdmi_isr_data {
-	hdmi_int_cb		isr;
-	struct hdmi_irq_status	*arg;
-	struct list_head	list;
-};
-
 static struct {
 	void __iomem *base_core;	/* 0 */
 	void __iomem *base_core_av;	/* 1 */
@@ -263,11 +255,8 @@
 	struct hdmi_config hdmi_cfg;
 	struct mutex mutex;
 	struct list_head notifier_head;
-	struct list_head int_cb_list;
-	spinlock_t irqlock;
 } hdmi;
 
-void HDMI_W1_HPD_handler(struct hdmi_irq_status *status);
 static inline void hdmi_write_reg(u32 base, u16 idx, u32 val)
 {
 	void __iomem *b;
@@ -408,7 +397,7 @@
 	REG_FLD_MOD(HDMI_CORE_AV, HDMI_CORE_AV_DPD, 0x7, 2, 0);
 
 	/* Wait */
-	mdelay(10);
+	msleep(10);
 	if (!ext) {
 		/* Clk SCL Devices */
 		REG_FLD_MOD(ins, HDMI_CORE_DDC_CMD, 0xA, 3, 0);
@@ -453,7 +442,7 @@
 	/* I2C bus slow. So need some additional wait : Varada */
 	for(i=0;i<2;i++){
 	l = hdmi_read_reg(ins, sts);
-	mdelay(102);
+	msleep(102);
 	}
 
 	/* HDMI_CORE_DDC_STATUS__BUS_LOW */
@@ -724,25 +713,25 @@
 	int ret = 0;
 	u32 SD3_EN = 0, SD2_EN = 0, SD1_EN = 0 , SD0_EN = 0;
 	u8 DBYTE1, DBYTE2, DBYTE4, CHSUM;
-	u8 size1, sample;
+	u8 size1;
 	u16 size0;
+	u32 r;
 
-	/* CTS_MODE */
-	WR_REG_32(name, HDMI_CORE_AV__ACR_CTRL,
-		/* MCLK_EN (0: Mclk is not used) */
-		((!audio_cfg->cts_mode) << 2) |
-		/* CTS Request Enable (1:Packet Enable, 0:Disable) */
-		(0x1 << 1) |
-		/* CTS Source Select (1:SW, 0:HW) */
-		(audio_cfg->cts_mode << 0));
-
-	/* 128 * Fs */
-	REG_FLD_MOD(name, HDMI_CORE_AV__FREQ_SVAL, 0, 2, 0);
+	/* Parameters for audio clock recovery packets */
 	REG_FLD_MOD(name, HDMI_CORE_AV__N_SVAL1, audio_cfg->n, 7, 0);
 	REG_FLD_MOD(name, HDMI_CORE_AV__N_SVAL2, audio_cfg->n >> 8, 7, 0);
 	REG_FLD_MOD(name, HDMI_CORE_AV__N_SVAL3, audio_cfg->n >> 16, 7, 0);
+
 	/*program the CTS values only in SW mode 1:SW, 0:HW */
-	if (audio_cfg->cts_mode) {
+	if (CTS_MODE_HW == audio_cfg->cts_mode) {
+		REG_FLD_MOD(name, HDMI_CORE_AV__AUD_PAR_BUSCLK_1,
+					audio_cfg->aud_par_busclk, 7, 0);
+		REG_FLD_MOD(name, HDMI_CORE_AV__AUD_PAR_BUSCLK_2,
+					(audio_cfg->aud_par_busclk >> 8), 7, 0);
+		REG_FLD_MOD(name, HDMI_CORE_AV__AUD_PAR_BUSCLK_3,
+					(audio_cfg->aud_par_busclk >> 16), 7, 0);
+	} else {
+		/* Software mode */
 		REG_FLD_MOD(name, HDMI_CORE_AV__CTS_SVAL1,
 					 audio_cfg->cts, 7, 0);
 		REG_FLD_MOD(name, HDMI_CORE_AV__CTS_SVAL2,
@@ -750,19 +739,79 @@
 		REG_FLD_MOD(name, HDMI_CORE_AV__CTS_SVAL3,
 					 audio_cfg->cts >> 16, 7, 0);
 	}
+	/* Update ACR clock divider - 128 FS */
+	REG_FLD_MOD(name, HDMI_CORE_AV__FREQ_SVAL, 0, 2, 0);
 
-	/* number of channel */
-	REG_FLD_MOD(name, HDMI_CORE_AV__HDMI_CTRL, audio_cfg->layout, 2, 1);
-	REG_FLD_MOD(name, HDMI_CORE_AV__AUD_PAR_BUSCLK_1,
-				audio_cfg->aud_par_busclk, 7, 0);
-	REG_FLD_MOD(name, HDMI_CORE_AV__AUD_PAR_BUSCLK_2,
-				(audio_cfg->aud_par_busclk >> 8), 7, 0);
-	REG_FLD_MOD(name, HDMI_CORE_AV__AUD_PAR_BUSCLK_3,
-				(audio_cfg->aud_par_busclk >> 16), 7, 0);
-	/* FS_OVERRIDE = 1 because input is used */
+	/* CTS_MODE */
+	r = RD_REG_32(name, HDMI_CORE_AV__ACR_CTRL);
+
+	/*
+	 * Use TMDS clock for ACR packets. For devices that use
+	 * the MCLK, this is the first part of the MCLK initialization.
+	 */
+	r = FLD_MOD(r, 0, 2, 2);
+
+	/* Enable the CTS request enable always */
+	r = FLD_MOD(r, 1, 1, 1);
+	if (CTS_MODE_HW == audio_cfg->cts_mode) {
+		r = FLD_MOD(r, 0, 0, 0);
+	} else {
+		r = FLD_MOD(r, 1, 0, 0);
+	}
+	WR_REG_32(name, HDMI_CORE_AV__ACR_CTRL, r);
+
+	/* For devices using MCLK, this completes its initialization. */
+	/* Please that this enable of MCLK should be done sperately */
+	if (CTS_MODE_HW == audio_cfg->cts_mode)
+		REG_FLD_MOD(name, HDMI_CORE_AV__ACR_CTRL, 1, 2, 2);
+
+	/* Use sample frequency from channel status word  */
 	WR_REG_32(name, HDMI_CORE_AV__SPDIF_CTRL, 0x1);
-	 /* refer to table209 p192 in func core spec */
-	WR_REG_32(name, HDMI_CORE_AV__I2S_CHST4, audio_cfg->fs);
+
+	/* Update IEC-60958-3 Channel status bits - hard coded for now */
+	r = 0;
+	r = 0 |			/* Bit 0 - consumer */
+		(0 << 1) |	/* Bit 1 - Audio data */
+		(1 << 2);	/* Bit 2 - No copyright asserted ? */
+
+	/* Bit 3, 4,  5 - No pre-emphasis 2 channel audio  */
+	WR_REG_32(name, HDMI_CORE_AV__I2S_CHST0, r);
+	/* Category code - not specified */
+	WR_REG_32(name, HDMI_CORE_AV__I2S_CHST1, 0);
+	/* Source & channel numbers are zero ? */
+	WR_REG_32(name, HDMI_CORE_AV__I2S_CHST2, 0);
+	/* Refer IEC 60958 - 3 */
+	switch (audio_cfg->if_fs) {
+	case IF_FS_32000:
+		r = 3;
+		break;
+	case IF_FS_44100:
+		r = 0;
+		break;
+	case IF_FS_48000:
+		r = 2;
+		break;
+	case IF_FS_96000:
+		r = 10;
+		break;
+	case IF_FS_192000:
+		r = 14;
+		break;
+	default:
+		r = 3;
+		break;
+	}
+
+	/* r should also have parts per million PPM, its 0, which is 1000 */
+	WR_REG_32(name, HDMI_CORE_AV__I2S_CHST4, r);
+
+	r = 0;
+	if (IF_16BIT_PER_SAMPLE == audio_cfg->if_sample_size) {
+		r = 1 << 1;
+	} else {
+		r = (1 << 1) | (1 << 0);
+	}
+	WR_REG_32(name, HDMI_CORE_AV__I2S_CHST5, r);
 
 	/*
 	 * audio config is mainly due to wrapper hardware connection
@@ -778,17 +827,26 @@
 		(1 << 6) |	/* SCK_EDGE Sample clock is rising */
 		(0 << 5) |	/* CBIT_ORDER */
 		(0 << 4) |	/* VBit, 0x0=PCM, 0x1=compressed */
-		(0 << 3) |	/* I2S_WS, 0xdon't care */
-		(0 << 2) |	/* I2S_JUST, 0=left- 1=right-justified */
-		(0 << 1) |	/* I2S_DIR, 0xdon't care */
-		(0));		/* I2S_SHIFT, 0x0 don't care */
-
-	WR_REG_32(name, HDMI_CORE_AV__I2S_CHST5, /* mode only */
-		(0 << 4) |			/* FS_ORIG */
-		(audio_cfg->if_sample_size));	/* I2S lenght 16 /24 bit */
+		(0 << 3) |	/* I2S_WS, Left channel on WS low */
+		(audio_cfg->justify << 2) |	/* I2S_JUST, 0=left- 1=right */
+		(0 << 1) |	/* I2S_DIR, MSB first */
+		(0));		/* I2S_SHIFT, First bit shift */
+
+	/*
+	 * The I2S input word length is twice the lenght given in
+	 * the IEC-60958 status word. If the word size is greater
+	 * than 20 bits, increment by one.
+	 */
+	if (IF_16BIT_PER_SAMPLE == audio_cfg->if_sample_size) {
+		r = (1<<1);	/* 20-bit or 16-bit */
+	} else {
+		r = (5<<1);	/* 24-bit or 20-bit */
+		r++;		/* increment by one */
+	}
+	WR_REG_32(name, HDMI_CORE_AV__I2S_IN_LEN, r);
 
-	WR_REG_32(name, HDMI_CORE_AV__I2S_IN_LEN, /* mode only */
-		(0xb));		/* In length b=>24bits i2s hardware */
+	/* Audio channel parameters */
+	REG_FLD_MOD(name, HDMI_CORE_AV__HDMI_CTRL, audio_cfg->layout, 2, 1);
 
 	/* channel enable depend of the layout */
 	if (audio_cfg->layout == LAYOUT_2CH) {
@@ -803,6 +861,11 @@
 		SD0_EN = 0x1;
 	}
 
+	/*
+	 * When ever audio FIFO is used, we would require to
+	 * use parallel interface only. Furthre serial
+	 * interface is not available on TI814x, TI813x, etc.
+	 */
 	WR_REG_32(name, HDMI_CORE_AV__AUD_MODE,
 		(SD3_EN << 7) |	/* SD3_EN */
 		(SD2_EN << 6) |	/* SD2_EN */
@@ -810,26 +873,28 @@
 		(SD0_EN << 4) |	/* SD0_EN */
 		(0 << 3) |	/* DSD_EN */
 		(1 << 2) |	/* AUD_PAR_EN */
-		(0 << 1) |	/* SPDIF_EN */
-		(0));		/* AUD_EN */
+		(0 << 1) |	/* SPDIF_EN - disabled not supported by HW.*/
+		(0));		/* AUD_EN - Required only in case of SPDIF input. */
 
-	/* Audio info frame setting refer to CEA-861-d spec p75 */
-	/* 0x0 because on HDMI CT must be = 0 / -1 because 1 is for 2 channel */
-	sample =  (audio_cfg->if_sample_size & 0x1);
-	sample = (sample == HDMI_SAMPLE_16BITS) ? 0x1 : 0x3;
+	/* Number of channels */
+	DBYTE1 = audio_cfg->if_channel_number - 1;
+	/* We support L-PCM 60958 format only */
+	DBYTE1 |= 0x10;
+
+	/*
+	 * Audio info frame setting refer to CEA-861-d spec
+	 * Table 18 Audio InfoFrame Data Byte 2
+	 */
+	DBYTE2 = (audio_cfg->if_sample_size == IF_16BIT_PER_SAMPLE) ? 0x1 : 0x3;
+	DBYTE2 |= (audio_cfg->if_fs << 2);
 
-	DBYTE1 = 0x10 + (audio_cfg->if_channel_number - 1);
-	DBYTE2 = (audio_cfg->if_fs << 2) + sample;
 	/* channel location according to CEA spec */
 	DBYTE4 = audio_cfg->if_audio_channel_location;
 
-	CHSUM = 0x100-0x84-0x01-0x0A-DBYTE1-DBYTE2-DBYTE4;
-
+	/* HDMI Spec 1.3a, 0x80+InfoFrame Type = 0x04 */
 	WR_REG_32(name, HDMI_CORE_AV__AUDIO_TYPE, 0x084);
 	WR_REG_32(name, HDMI_CORE_AV__AUDIO_VERS, 0x001);
 	WR_REG_32(name, HDMI_CORE_AV__AUDIO_LEN, 0x00A);
-	/* don't care on VMP */
-	WR_REG_32(name, HDMI_CORE_AV__AUDIO_CHSUM, CHSUM);
 
 	size0 = HDMI_CORE_AV__AUDIO_DBYTE;
 	size1 = HDMI_CORE_AV__AUDIO_DBYTE__ELSIZE;
@@ -844,16 +909,9 @@
 	hdmi_write_reg(name, (size0 + 8 * size1), 0x000);
 	hdmi_write_reg(name, (size0 + 9 * size1), 0x000);
 
-	/* ISCR1 and ACP setting */
-	WR_REG_32(name, HDMI_CORE_AV__SPD_TYPE, 0x04);
-	WR_REG_32(name, HDMI_CORE_AV__SPD_VERS, 0x0);
-	WR_REG_32(name, HDMI_CORE_AV__SPD_LEN, 0x0);
-	WR_REG_32(name, HDMI_CORE_AV__SPD_CHSUM, 0x0);
-
-	WR_REG_32(name, HDMI_CORE_AV__MPEG_TYPE, 0x05);
-	WR_REG_32(name, HDMI_CORE_AV__MPEG_VERS, 0x0);
-	WR_REG_32(name, HDMI_CORE_AV__MPEG_LEN, 0x0);
-	WR_REG_32(name, HDMI_CORE_AV__MPEG_CHSUM, 0x0);
+	/* write the check sum last, no perticular reason. Just convention */
+	CHSUM = 0x100 - (0x84 + 0x01 + 0x0A + DBYTE1 + DBYTE2 + DBYTE4);
+	WR_REG_32(name, HDMI_CORE_AV__AUDIO_CHSUM, CHSUM);
 
 	return ret;
 }
@@ -1108,7 +1166,7 @@
 	/* ToDo : revert back to HDMI_PACK_10b_RGB_YUV444,
 	   or put conditional code*/
 	f_p->packingMode = HDMI_PACK_10b_RGB_YUV444;
-	mdelay(340);
+	msleep(340);
 
 	f_p->linePerPanel = 0;
 	f_p->pixelPerLine = 0;
@@ -1310,8 +1368,11 @@
 {
 	int ret = 0;
 	u32 value = 0;
-
+	/* Differs from OMAP code, this function explictly disable audio wrapper.
+		In our case, we ensure caller of this function disables audio wrapper */
 	value = hdmi_read_reg(name, HDMI_WP_AUDIO_CFG);
+	value &= 0xffffffef;
+	value |= ((audio_fmt->iec) << 4);
 	value &= 0xfffffff7;
 	value |= ((audio_fmt->justify) << 3);;
 	value &= 0xfffffffb;
@@ -1324,8 +1385,8 @@
 	value |= ((audio_fmt->stereo_channel_enable) << 24);
 	value &= 0xff00ffff;
 	value |= ((audio_fmt->audio_channel_location) << 16);
-	value &= 0xffffffef;
-	value |= ((audio_fmt->iec) << 4);
+	value &= 0xffffffdf;
+	value |= (audio_fmt->block_start_end << 5);
 
 	/* Wakeup value = 0x1030022; */
 
@@ -1385,33 +1446,6 @@
 	REG_FLD_MOD(HDMI_WP, HDMI_WP_AUDIO_CTRL, 0, 30, 30);
 }
 
-static int hdmi_w1_audio_config(void)
-{
-	int ret;
-
-	struct hdmi_audio_format audio_fmt;
-	struct hdmi_audio_dma audio_dma;
-
-	audio_fmt.justify = HDMI_AUDIO_JUSTIFY_LEFT;
-	audio_fmt.sample_number = HDMI_ONEWORD_TWO_SAMPLES;
-	audio_fmt.sample_size = HDMI_SAMPLE_16BITS;
-	audio_fmt.stereo_channel_enable = HDMI_STEREO_ONECHANNELS;
-	audio_fmt.audio_channel_location = HDMI_CEA_CODE_03;
-	audio_fmt.iec = HDMI_AUDIO_FORMAT_LPCM;
-	audio_fmt.left_before = HDMI_SAMPLE_LEFT_FIRST;
-
-	ret = hdmi_w1_audio_config_format(HDMI_WP, &audio_fmt);
-
-	audio_dma.dma_transfer = 0x20;
-	audio_dma.block_size = 0xC0;
-	audio_dma.threshold_value = 0x20;
-	audio_dma.dma_or_irq = HDMI_THRESHOLD_DMA;
-	audio_dma.block_start_end = HDMI_BLOCK_STARTEND_ON;
-
-	ret = hdmi_w1_audio_config_dma(HDMI_WP, &audio_dma);
-
-	return ret;
-}
 static void hdmi_core_extract_sync_config(struct hdmi_video_format *f_p,
 		struct hdmi_video_timing *t_p)
 {
@@ -1452,6 +1486,7 @@
 	hdmi_write_reg(HDMI_CORE_SYS, HDMI_CORE_SYS__VBIT_TO_VSYNC, vbit2_vsync);
 	hdmi_write_reg(HDMI_CORE_SYS, HDMI_CORE_SYS__VWIDTH, vwidth);
 }
+
 int hdmi_lib_enable(struct hdmi_config *cfg)
 {
 	u32 r;
@@ -1502,7 +1537,7 @@
 
 	hdmi_w1_irq_enable(&IrqHdmiVectorEnable);
 
-	mdelay(100);
+	msleep(100);
 	IrqHdmiVectorEnable.phyDisconnect = 0;
 	hdmi_w1_irq_wakeup_enable(&IrqHdmiVectorEnable);
 
@@ -1560,7 +1595,6 @@
 	if ( cpu_is_ti814x())
 		VideoInterfaceParam.timingMode = 1;
 	hdmi_w1_video_config_interface(&VideoInterfaceParam);
-	hdmi_w1_audio_config();
 
 	/****************************** CORE *******************************/
 	/************* configure core video part ********************************/
@@ -1616,7 +1650,7 @@
 	hdmi.avi_param.db1a_active_format_off_on =
 		INFOFRAME_AVI_DB1A_ACTIVE_FORMAT_OFF;
 	hdmi.avi_param.db1b_no_vert_hori_verthori = INFOFRAME_AVI_DB1B_NO;
-	hdmi.avi_param.db1s_0_1_2 = INFOFRAME_AVI_DB1S_0;
+	hdmi.avi_param.db1s_0_1_2 = INFOFRAME_AVI_DB1S_2;
 	hdmi.avi_param.db2c_no_itu601_itu709_extented = INFOFRAME_AVI_DB2C_NO;
 
 	/* Support AR in AVI infoframe */
@@ -1666,16 +1700,18 @@
 	/* wakeup */
 	repeat_param.AudioPacketED = PACKETENABLE;
 	repeat_param.AudioPacketRepeat = PACKETREPEATON;
-	/* ISCR1 transmission */
-	repeat_param.MPEGInfoFrameED = PACKETENABLE;
-	repeat_param.MPEGInfoFrameRepeat = PACKETREPEATON;
-	/* ACP transmission */
-	repeat_param.SPDInfoFrameED = PACKETENABLE;
-	repeat_param.SPDInfoFrameRepeat = PACKETREPEATON;
+
+	/* ISCR1 transmission - Disabled */
+	repeat_param.MPEGInfoFrameED = PACKETDISABLE;
+	repeat_param.MPEGInfoFrameRepeat = PACKETREPEATOFF;
+	/* ACP transmission - Disabled */
+	repeat_param.SPDInfoFrameED = PACKETDISABLE;
+	repeat_param.SPDInfoFrameRepeat = PACKETREPEATOFF;
 
 	r = hdmi_core_av_packet_config(av_name, repeat_param);
 
-	REG_FLD_MOD(av_name, HDMI_CORE_AV__HDMI_CTRL, cfg->hdmi_dvi, 0, 0);
+	REG_FLD_MOD(av_name, HDMI_CORE_AV__HDMI_CTRL,
+			v_core_cfg.CoreHdmiDvi, 0, 0);
 	memcpy(&hdmi.hdmi_cfg, cfg, sizeof(struct hdmi_config));
 	return r;
 }
@@ -1685,14 +1721,13 @@
 int hdmi_lib_init(void){
 	u32 rev;
 
-	hdmi.base_wp = ioremap(HDMI_WP, (HDMI_HDCP - HDMI_WP));
-
 	if(cpu_is_ti816x()){
 		/* OMAP first, then overwrite it */
 		hdmi.base_wp =  ioremap(TI81xx_HDMI_WP, 4096);
-	}
-	if(cpu_is_ti814x()){
+	}else if(cpu_is_ti814x()){
 		hdmi.base_wp =  ioremap(TI81xx_HDMI_WP, 4096);
+	} else {
+		hdmi.base_wp = ioremap(HDMI_WP, (HDMI_HDCP - HDMI_WP));
 	}
 
 	if (!hdmi.base_wp) {
@@ -1706,8 +1741,6 @@
 
 	mutex_init(&hdmi.mutex);
 	INIT_LIST_HEAD(&hdmi.notifier_head);
-	INIT_LIST_HEAD(&hdmi.int_cb_list);
-	spin_lock_init(&hdmi.irqlock);
 
 	rev = hdmi_read_reg(HDMI_WP, HDMI_WP_REVISION);
 	printk(KERN_INFO "HDMI W1 rev %d.%d\n",
@@ -1720,15 +1753,6 @@
 
 void hdmi_lib_exit(void){
 	iounmap(hdmi.base_wp);
-	while (!list_empty(&hdmi.int_cb_list)) {
-		struct hdmi_isr_data *isrd;
-		isrd = list_first_entry(&hdmi.int_cb_list,
-				struct hdmi_isr_data,
-				list);
-		list_del(&isrd->list);
-		kfree(isrd);
-	}
-
 }
 
 int hdmi_set_irqs(int i)
@@ -1760,34 +1784,8 @@
 	return 0;
 }
 
-static irqreturn_t hdmi_irq_handler(int irq, void *arg)
-{
-	unsigned long flags;
-	struct hdmi_isr_data *isrd;
-	struct hdmi_irq_status irq_status;
-
-	/* process interrupt in critical section to handle conflicts */
-	spin_lock_irqsave(&hdmi.irqlock, flags);
-
-	irq_status.hpd_status = 0;
-	irq_status.hpd_pin_status = 0;
-	irq_status.rsen_pin_status = 0;
-	HDMI_W1_HPD_handler(&irq_status);
-
-	list_for_each_entry(isrd, &hdmi.int_cb_list, list) {
-		if (isrd->isr && isrd->arg) {
-			isrd->arg->hpd_status = irq_status.hpd_status;
-			isrd->arg->hpd_pin_status = irq_status.hpd_pin_status;
-			isrd->arg->rsen_pin_status = irq_status.rsen_pin_status;
-			isrd->isr(isrd->arg);
-		}
-	}
-	spin_unlock_irqrestore(&hdmi.irqlock, flags);
-	return IRQ_HANDLED;
-}
-
 /* Interrupt handler */
-void HDMI_W1_HPD_handler(struct hdmi_irq_status *status)
+void HDMI_W1_HPD_handler(int *r)
 {
 	u32 val, set = 0, hpd_intr = 0, core_state = 0;
 	u32 time_in_ms, intr2 = 0, intr3 = 0;
@@ -1841,7 +1839,7 @@
 		if (hpd_intr & 0x40) {
 			if  (set & HDMI_CORE_SYS__SYS_STAT_HPD) {
 				if ((first_hpd == 0) && (dirty == 0)) {
-					status->hpd_status |= TI81XXHDMI_FIRST_HPD;
+					*r |= HDMI_FIRST_HPD;
 					first_hpd++;
 					DBG("first hpd");
 				} else {
@@ -1851,16 +1849,16 @@
 							(int)ktime_to_us(ktime_sub\
 									(ts_hpd_high, ts_hpd_low)) / 1000;
 						if (time_in_ms >= 80)
-							status->hpd_status |= TI81XXHDMI_HPD_MODIFY;
+							*r |= HDMI_HPD_MODIFY;
 						else
-							status->hpd_status |= TI81XXHDMI_HPD_HIGH;
+							*r |= HDMI_HPD_HIGH;
 						dirty = 0;
 					}
 				}
 			} else {
 				ts_hpd_low = ktime_get();
 				dirty = 1;
-				status->hpd_status |= TI81XXHDMI_HPD_LOW;
+				*r |= HDMI_HPD_LOW;
 			}
 		}
 	}
@@ -1876,68 +1874,67 @@
 	}
 
 	if (intr2 & HDMI_IP_CORE_SYSTEM__INTR2__BCAP)
-		status->hpd_status |= TI81XXHDMI_BCAP;
+		*r |= HDMI_BCAP;
 
 	if (intr3 & HDMI_IP_CORE_SYSTEM__INTR3__RI_ERR)
-		status->hpd_status |= TI81XXHDMI_RI_ERR;
+		*r |= HDMI_RI_ERR;
 
 	/* Ack other interrupts if any */
 	hdmi_write_reg(HDMI_WP, HDMI_WP_IRQSTATUS, val);
 	/* flush posted write */
 	hdmi_read_reg(HDMI_WP, HDMI_WP_IRQSTATUS);
-	status->hpd_pin_status = ((set & HDMI_CORE_SYS__SYS_STAT_HPD) ? 1 : 0);
-	status->rsen_pin_status = ((set & HDMI_CORE_SYS__SYS_STAT_RSEN) ? 1 : 0);
 }
-
-/* wrapper functions to be used until L24.5 release */
-int HDMI_CORE_DDC_READEDID(u32 name, u8 *p, u16 max_length)
+#if 0
+int hdmi_rxdet(void)
 {
-	int r = read_edid(p, max_length);
-	return r;
-}
+	int state = 0;
+	int loop = 0, val1, val2, val3, val4;
+	struct hdmi_irq_vector IrqHdmiVectorEnable;
 
-int hdmi_register_interrupt_cb(hdmi_int_cb cb, void *arg)
-{
-	int r = 0;
-	struct hdmi_isr_data *isrd, *new;
+	hdmi_write_reg(HDMI_WP, HDMI_WP_WP_DEBUG_CFG, 4);
 
-	mutex_lock(&hdmi.mutex);
-	if (list_empty(&hdmi.int_cb_list))
-		r = request_irq(TI81XX_IRQ_HDMIINT, hdmi_irq_handler, 0,
-			"HDMI", (void *)0);
-	if (r)
-		goto exit;
-	list_for_each_entry(isrd, &hdmi.int_cb_list, list) {
-		if ((isrd->isr == cb) && (isrd->arg == arg)) {
-			r = -EINVAL;
-			goto exit;
-		}
+	do {
+		val1 = hdmi_read_reg(HDMI_WP, HDMI_WP_WP_DEBUG_DATA);
+		udelay(5);
+		val2 = hdmi_read_reg(HDMI_WP, HDMI_WP_WP_DEBUG_DATA);
+		udelay(5);
+		val3 = hdmi_read_reg(HDMI_WP, HDMI_WP_WP_DEBUG_DATA);
+		udelay(5);
+		val4 = hdmi_read_reg(HDMI_WP, HDMI_WP_WP_DEBUG_DATA);
+	} while ((val1 != val2 || val2 != val3 || val3 != val4)
+		&& (loop < 100));
+
+	hdmi_write_reg(HDMI_WP, HDMI_WP_WP_DEBUG_CFG, 0);
+
+	if (loop == 100)
+		state = -1;
+	else
+		state = (val1 & 1);
+
+	/* Turn on the wakeup capability of the interrupts
+	It is recommended to turn on opposite interrupt wake
+	up capability in connected and disconnected state.
+	This is to avoid race condition in interrupts.
+	*/
+	IrqHdmiVectorEnable.core = 1;
+	if (state) {
+		IrqHdmiVectorEnable.phyDisconnect = 1;
+		IrqHdmiVectorEnable.phyConnect = 0;
+		hdmi_w1_irq_wakeup_enable(&IrqHdmiVectorEnable);
+	} else {
+		IrqHdmiVectorEnable.phyDisconnect = 0;
+		IrqHdmiVectorEnable.phyConnect = 1;
+		hdmi_w1_irq_wakeup_enable(&IrqHdmiVectorEnable);
 	}
-	new = kzalloc(sizeof(*isrd), GFP_KERNEL);
-	new->isr = cb;
-	new->arg = arg;
-	list_add_tail(&new->list, &hdmi.int_cb_list);
-exit:
-	mutex_unlock(&hdmi.mutex);
-	return r;
+
+	return state;
 }
+#endif
 
-int hdmi_unregister_interrupt_cb(hdmi_int_cb cb, void *arg)
+/* wrapper functions to be used until L24.5 release */
+int HDMI_CORE_DDC_READEDID(u32 name, u8 *p, u16 max_length)
 {
-	int r = 0;
-	struct hdmi_isr_data  *isrd,  *next;
-
-	mutex_lock(&hdmi.mutex);
-	list_for_each_entry_safe(isrd, next, &hdmi.int_cb_list, list) {
-		if ((isrd->arg == arg) && (isrd->isr == cb)) {
-			list_del(&isrd->list);
-			kfree(isrd);
-			break;
-		}
-	}
-	if (list_empty(&hdmi.int_cb_list))
-		free_irq(TI81XX_IRQ_HDMIINT, NULL);
-	mutex_unlock(&hdmi.mutex);
+	int r = read_edid(p, max_length);
 	return r;
 }
 
@@ -2075,12 +2072,14 @@
 	return;
 }
 
-/* TODO : This func will return the current video clock  */
+/* This function will return the current video clock  */
 int hdmi_lib_get_pixel_clock()
 {
 	return hdmi.hdmi_cfg.pixel_clock;
 
 }
+
+/* TODO - Check if this function can be deprecated */
 int hdmi_get_video_timing()
  {
        int ret = 0;
@@ -2243,8 +2242,8 @@
 		temp = hdmi_read_reg(HDMI_CORE_CEC, HDMI_CORE_CEC_DBG_3);
 		if (FLD_GET(temp, 7, 7) == 0)
 			break;
-		/* FIX ME - use udelay instead, as this wait is not a constant for 
-			different platforms */
+		/* FIX ME - use msleep instead, as this wait is not a
+		 * constant for all platforms */
 		timeout--;
 	}
 	if (timeout == 0x0) {
@@ -2422,11 +2421,11 @@
 }
 
 
-
 EXPORT_SYMBOL(hdmi_lib_enable);
 EXPORT_SYMBOL(hdmi_lib_init);
 EXPORT_SYMBOL(hdmi_lib_exit);
 EXPORT_SYMBOL(hdmi_set_irqs);
+EXPORT_SYMBOL(HDMI_W1_HPD_handler);
 EXPORT_SYMBOL(HDMI_CORE_DDC_READEDID);
 EXPORT_SYMBOL(HDMI_W1_StopVideoFrame);
 EXPORT_SYMBOL(HDMI_W1_StartVideoFrame);
@@ -2457,5 +2456,3 @@
 EXPORT_SYMBOL(hdmi_lib_cec_activate);
 EXPORT_SYMBOL(hdmi_lib_cec_write_msg);
 EXPORT_SYMBOL(hdmi_lib_cec_read_msg);
-EXPORT_SYMBOL(hdmi_register_interrupt_cb);
-EXPORT_SYMBOL(hdmi_unregister_interrupt_cb);
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/clkdev_omap.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/clkdev_omap.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/clkdev_omap.h	2014-08-07 14:42:24.000000000 -0600
@@ -41,6 +41,7 @@
 #define CK_TI814X	(1 << 12)
 #define CK_TI816X	(1 << 13)
 #define CK_DM385	(1 << 14)
+#define CK_TI811X	(1 << 15)
 
 
 #define CK_34XX		(CK_3430ES1 | CK_3430ES2PLUS)
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/cpu.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/cpu.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/cpu.h	2014-08-07 14:42:24.000000000 -0600
@@ -88,7 +88,7 @@
  * cpu_is_omap243x():	True for OMAP2430
  * cpu_is_omap343x():	True for OMAP3430
  * cpu_is_omap443x():	True for OMAP4430
- * cpu_is_ti814x():	True for TI8148, DM385
+ * cpu_is_ti814x():	True for TI8148, DM385, TI811X
  * cpu_is_ti816x():	True for TI8168
  */
 #define GET_OMAP_CLASS	(omap_rev() & 0xff)
@@ -150,6 +150,7 @@
 #define cpu_is_ti81xx()			0
 #define cpu_is_ti814x()			0
 #define cpu_is_dm385()			0
+#define cpu_is_ti811x()			0
 #define cpu_is_ti816x()			0
 
 #if defined(MULTI_OMAP1)
@@ -381,10 +382,12 @@
 # undef cpu_is_ti81xx
 # undef cpu_is_ti814x
 # undef cpu_is_dm385
+# undef cpu_is_ti811x
 # undef cpu_is_ti816x
 # define cpu_is_ti81xx()		is_ti81xx()
 # define cpu_is_ti814x()		is_ti814x()
 # define cpu_is_dm385()			(cpu_is_ti814x() && !omap3_has_dsp())
+# define cpu_is_ti811x()		(cpu_is_ti814x() && !omap3_has_iva())
 # define cpu_is_ti816x()		is_ti816x()
 # endif
 
@@ -437,6 +440,7 @@
 #define TI8168_REV_ES1_0	TI816X_CLASS
 #define TI8168_REV_ES1_1	(TI816X_CLASS | (OMAP_REVBITS_01 << 8))
 #define TI8168_REV_ES2_0	(TI816X_CLASS | (OMAP_REVBITS_02 << 8))
+#define TI8168_REV_ES2_1	(TI816X_CLASS | (OMAP_REVBITS_03 << 8))
 
 /*
  * omap_chip bits
@@ -467,6 +471,7 @@
 #define CHIP_IS_TI816X			(1 << 12)
 #define CHIP_IS_TI814X			(1 << 13)
 #define CHIP_IS_DM385			(1 << 14)
+#define CHIP_IS_TI811X			(1 << 15)
 
 #define CHIP_IS_OMAP24XX		(CHIP_IS_OMAP2420 | CHIP_IS_OMAP2430)
 
@@ -474,7 +479,7 @@
 						 CHIP_IS_OMAP4430ES2)
 
 #define CHIP_IS_TI81XX			(CHIP_IS_TI816X | CHIP_IS_TI814X | \
-						CHIP_IS_DM385)
+						CHIP_IS_DM385 | CHIP_IS_TI811X)
 
 /*
  * "GE" here represents "greater than or equal to" in terms of ES
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/io.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/io.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/io.h	2014-08-07 14:42:24.000000000 -0600
@@ -42,11 +42,14 @@
 
 #define IO_SPACE_LIMIT 0xffffffff
 
+#ifndef CONFIG_PCI
 /*
  * We don't actually have real ISA nor PCI buses, but there is so many
  * drivers out there that might just work if we fake them...
  */
 #define __io(a)		__typesafe_io(a)
+#endif
+
 #define __mem_pci(a)	(a)
 
 /*
@@ -88,6 +91,7 @@
 
 #define TI81XX_L2_MC_IO_OFFSET		0xa4000000
 #define TI81XX_L2_MC_IO_ADDRESS(pa)	IOMEM((pa) + TI81XX_L2_MC_IO_OFFSET)
+
 /*
  * Required to map if using workaround for draining async bridge path draining
  * on entering WFI
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/ti81xx-vpss.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/ti81xx-vpss.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/ti81xx-vpss.h	2014-08-07 14:42:24.000000000 -0600
@@ -31,17 +31,63 @@
 #include <linux/vps_cfgdei.h>
 #include <linux/vps_display.h>
 
+#define VPS_DISPLAY_MAX_EDGES   2
+
 enum ti81xx_cpu {
 	CPU_DM816X = 0,
 	CPU_DM814X,
 	CPU_DM813X,
+	CPU_DM811X,
 	CPU_MAX = 0xFFFFFFFF
 };
 
+struct vps_platform_grpx {
+	int snode;
+	u32 numends;
+	int enode[VPS_DC_MAX_VENC];
+};
+
+struct vps_platform_video {
+	/*idx 0: /dev/video1, 1 /dev/video2, 2:/dev/video3(SD output only)*/
+	int idx;
+	/*display nodes(not including the final blend node)*/
+	int numedges;
+	int snodes[VPS_DISPLAY_MAX_EDGES];
+	int snodes_inputid[VPS_DISPLAY_MAX_EDGES];
+	/*num vencs connected to the input only blender is considered here*/
+	int numoutput;
+	int enodes[VPS_DC_MAX_VENC - 1];
+	int enodes_inputid[VPS_DC_MAX_VENC - 1];
+};
+
+enum ti81xx_ths_filter_ctrl {
+	TI81XX_THSFILTER_ENABLE_MODULE = 0,
+	TI81XX_THSFILTER_BYPASS_MODULE,
+	TI81XX_THSFILTER_DISABLE_MODULE
+};
+
+/* \brief Enum for selecting filter for component input/output in THS7360 */
+enum ti81xx_ths7360_sf_ctrl {
+	TI81XX_THS7360_DISABLE_SF = 0,
+	TI81XX_THS7360_BYPASS_SF,
+	TI81XX_THS7360_SF_SD_MODE,
+	TI81XX_THS7360_SF_ED_MODE,
+	TI81XX_THS7360_SF_HD_MODE,
+	TI81XX_THS7360_SF_TRUE_HD_MODE
+};
+
 struct vps_platform_data {
 	enum ti81xx_cpu cpu;
 	u32             numvencs;
 	u32             vencmask;
+	u32             numgrpx;
+	struct vps_platform_grpx  gdata[VPS_DISP_GRPX_MAX_INST];
+	u32             numvideo;
+	struct vps_platform_video vdata[VPS_DISPLAY_INST_MAX];
+	int (*pcf_ths_init)(void);
+	int (*pcf_ths_exit)(void);
+	int (*pcf_ths_hd_set)(u32 mode);
+	int (*pcf_ths_sd_set)(u32 ctrl);
 };
 
 /*structure for graphics pipeline*/
@@ -172,7 +218,6 @@
 #define VPSS_VID_CAPS_COLOR                 8
 
 
-#define VPS_DISPLAY_MAX_EDGES   2
 #define  MAX_BUFFER_NUM        32
 
 struct vps_video_ctrl {
@@ -209,6 +254,9 @@
 	/* De-interlacer config params*/
 	struct vps_dei_disp_params      *vdeiprm;
 	u32                             vdei_phy;
+	/* De-interlacer scalar crop configs*/
+	struct vps_cropconfig           *vdeicrpcfg;
+	u32                             vdeicr_phy;
 	/* The followings  are the FVID2 varables*/
 	/*fvid2 create params*/
 	struct fvid2_cbparams           *cbparams;
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/uncompress.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/uncompress.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/uncompress.h	2014-08-07 14:42:24.000000000 -0600
@@ -184,6 +184,9 @@
 
 		/* DM385 base boards using UART1 */
 		DEBUG_LL_TI81XX(1, dm385evm);
+
+		/* TI811X base boards using UART1 */
+		DEBUG_LL_TI81XX(1, ti811xevm);
 	} while (0);
 }
 
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/usb.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/usb.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/plat-omap/include/plat/usb.h	2014-08-07 14:42:24.000000000 -0600
@@ -310,6 +310,8 @@
 #define USB_RNDIS_MODE		1
 #define USB_CDC_MODE		2
 #define USB_GENERIC_RNDIS_MODE	3
+#define USB_INFINITE_DMAMODE	4
+#define MAX_GRNDIS_PKTSIZE	(64 * 1024)
 
 /* AutoReq register bits */
 #define USB_RX_AUTOREQ_SHIFT(n) (((n) - 1) << 1)
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/tools/mach-types
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/tools/mach-types	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/tools/mach-types	2014-08-07 11:51:59.010748388 -0600
@@ -3220,3 +3220,4 @@
 dds			MACH_DDS		DDS			3237
 chalten_xa1		MACH_CHALTEN_XA1	CHALTEN_XA1		3238
 dm385evm		MACH_DM385EVM		DM385EVM		3900
+ti811xevm		MACH_TI811XEVM		TI811XEVM		3901
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-dm385evm.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-dm385evm.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/board-dm385evm.c	2014-08-07 14:42:24.000000000 -0600
@@ -55,6 +55,9 @@
 
 #define GPIO_TSC               31
 
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
+
 #ifdef CONFIG_OMAP_MUX
 static struct omap_board_mux board_mux[] __initdata = {
 	{ .reg_offset = OMAP_MUX_TERMINATOR },
@@ -67,7 +70,7 @@
 	{
 		.mmc		= 1,
 		.caps		= MMC_CAP_4_BIT_DATA | MMC_CAP_NEEDS_POLL,
-		.gpio_cd	= -EINVAL, /* Dedicated pins for CD and WP */
+		.gpio_cd	= GPIO_TO_PIN(1, 6), /* Dedicated pins for CD and WP */
 		.gpio_wp	= -EINVAL,
 		.ocr_mask	= MMC_VDD_33_34,
 	},
@@ -262,16 +265,16 @@
 
 static struct i2c_board_info __initdata ti814x_i2c_boardinfo[] = {
 	{
-		I2C_BOARD_INFO("eeprom", 0x50),
+/*		I2C_BOARD_INFO("eeprom", 0x50),
 		.platform_data	= &eeprom_info,
 	},
 	{
 		I2C_BOARD_INFO("cpld", 0x23),
 	},
-	{
+	{*/
 		I2C_BOARD_INFO("tlv320aic3x", 0x18),
 	},
-	{
+/*	{
 		I2C_BOARD_INFO("IO Expander", 0x20),
 	},
 	{
@@ -280,13 +283,237 @@
 	{
 		I2C_BOARD_INFO("qt602240_ts", 0x4A),
 		.platform_data = &ts_platform_data,
-	},
+	},*/
 	{
 		I2C_BOARD_INFO("tps65911", 0x2D),
 		.platform_data = &tps65911_pdata,
 	},
 };
 
+static struct i2c_board_info __initdata dm813x_i2c_boardinfo1[] = {
+	{
+		I2C_BOARD_INFO("pcf8575_1_dm813x", 0x20),
+	},
+
+};
+
+
+static const struct i2c_device_id ti813x_pcf8575_cir_id[] = {
+	{ "IO Expander", 0 },
+	{ }
+};
+static struct i2c_client *ti813x_pcf8575_cir_client;
+static unsigned char ti813x_pcf8575_cir_port[2] = {0, 0xbf};
+static int ti813x_pcf8575_cir_enable(void);
+static int ti813x_pcf8575_cir_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	ti813x_pcf8575_cir_client = client;
+	ti813x_pcf8575_cir_enable();
+	return 0;
+}
+
+static int __devexit ti813x_pcf8575_cir_remove(struct i2c_client *client)
+{
+	ti813x_pcf8575_cir_client = NULL;
+	return 0;
+}
+static struct i2c_driver ti813x_pcf8575_cir_driver = {
+	.driver = {
+		.name	= "IO Expander",
+	},
+	.probe		= ti813x_pcf8575_cir_probe,
+	.remove		= ti813x_pcf8575_cir_remove,
+	.id_table		= ti813x_pcf8575_cir_id,
+};
+int ti813x_pcf8575_cir_init(void)
+{
+
+	i2c_add_driver(&ti813x_pcf8575_cir_driver);
+	return 0;
+}
+/*static void __init dm385_irda_init(void)
+{
+	 printk("pinmux for IR \n");
+         omap_mux_init_signal("uart0_rin.uart1_rxd_mux0", OMAP_PIN_INPUT);
+}*/
+
+
+int ti813x_cir_exit(void)
+{
+	i2c_del_driver(&ti813x_pcf8575_cir_driver);
+	return 0;
+}
+
+static const struct i2c_device_id pcf8575_video_id[] = {
+	{ "pcf8575_1_dm813x", 0 },
+	{ }
+};
+static struct i2c_client *pcf8575_1_client;
+static unsigned char pcf8575_1_port[2] = {0x4F, 0x7F};
+
+#define VPS_PCF8575_PIN0                (0x20)
+#define VPS_PCF8575_PIN1                (0x10)
+#define VPS_PCF8575_PIN2                (0x4)
+#define VPS_PCF8575_PIN3                (0x8)
+#define VPS_PCF8575_PIN4                (0x2)
+#define VPS_PCF8575_PIN5                (0x1)
+#define VPS_PCF8575_PIN6                (0x40)
+#define VPS_PCF8575_PIN7                (0x80)
+
+#define pcf8575_IR_REMOTE_OFF		(0x40)
+#define VPS_PCF8575_PIN10               (0x1)
+#define VPS_PCF8575_PIN11               (0x2)
+
+#define VPS_THS7375_MASK                (VPS_PCF8575_PIN10 | VPS_PCF8575_PIN11)
+
+#define VPS_THS7360_SD_MASK             (VPS_PCF8575_PIN2 | VPS_PCF8575_PIN5)
+
+#define VPS_THS7360_SF_MASK             (VPS_PCF8575_PIN0 |                    \
+					VPS_PCF8575_PIN1 |                    \
+					VPS_PCF8575_PIN3 |                    \
+					VPS_PCF8575_PIN4)
+int dm813x_pcf8575_ths7360_sd_enable(enum ti81xx_ths_filter_ctrl ctrl)
+{
+	struct i2c_msg msg = {
+		.addr = pcf8575_1_client->addr,
+		.flags = 0,
+		.len = 2,
+	};
+	pcf8575_1_port[0] &= ~VPS_THS7360_SD_MASK;
+	switch (ctrl) {
+	case TI81XX_THSFILTER_ENABLE_MODULE:
+		pcf8575_1_port[0] &= ~(VPS_THS7360_SD_MASK);
+		break;
+	case TI81XX_THSFILTER_BYPASS_MODULE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN2;
+		break;
+	case TI81XX_THSFILTER_DISABLE_MODULE:
+		pcf8575_1_port[0] |= VPS_THS7360_SD_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	msg.buf = pcf8575_1_port;
+	return i2c_transfer(pcf8575_1_client->adapter, &msg, 1);
+}
+
+static void ti813x_cir_pin_mux(void)
+{
+	char mux_name[100];
+	sprintf(mux_name, "uart0_rin.uart1_rxd_mux0");
+	printk("cir pinmux\n");
+	omap_mux_init_signal(mux_name, OMAP_MUX_MODE0 |
+			TI814X_PULL_DIS | TI814X_INPUT_EN);
+	return;
+}
+
+int ti813x_pcf8575_cir_enable(void)
+{
+	int ret = 0;
+	struct i2c_msg msg = {
+		.addr = ti813x_pcf8575_cir_client->addr,
+		.flags = 1,
+		.len = 2,
+	};
+	msg.buf = ti813x_pcf8575_cir_port;
+	ret = i2c_transfer(ti813x_pcf8575_cir_client->adapter, &msg, 1);
+	msg.flags = 0;
+	if (ret < 0)
+		printk(KERN_ERR "I2C: Read failed at %s %d with error code: %d\n",
+			__func__, __LINE__, ret);
+	ti813x_pcf8575_cir_port[0] = msg.buf[0];
+	ti813x_pcf8575_cir_port[1] = (msg.buf[1] & ~(pcf8575_IR_REMOTE_OFF));
+	ret = i2c_transfer(ti813x_pcf8575_cir_client->adapter, &msg, 1);
+	ti813x_cir_pin_mux();
+	if (ret < 0)
+		printk(KERN_ERR "I2C: Transfer failed at %s %d with error code: %d\n",
+			__func__, __LINE__, ret);
+	return ret;
+
+}
+int dm813x_pcf8575_ths7360_hd_enable(enum ti81xx_ths7360_sf_ctrl ctrl)
+{
+	int ret_val;
+	struct i2c_msg msg = {
+		.addr = pcf8575_1_client->addr,
+		.flags = 0,
+		.len = 2,
+	};
+
+	pcf8575_1_port[0] &= ~VPS_THS7360_SF_MASK;
+	switch (ctrl) {
+	case TI81XX_THS7360_DISABLE_SF:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN4;
+		break;
+	case TI81XX_THS7360_BYPASS_SF:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN3;
+		break;
+	case TI81XX_THS7360_SF_SD_MODE:
+		pcf8575_1_port[0] &= ~(VPS_THS7360_SF_MASK);
+		break;
+	case TI81XX_THS7360_SF_ED_MODE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN0;
+		break;
+	case TI81XX_THS7360_SF_HD_MODE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN1;
+		break;
+	case TI81XX_THS7360_SF_TRUE_HD_MODE:
+		pcf8575_1_port[0] |= VPS_PCF8575_PIN0|VPS_PCF8575_PIN1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	msg.buf = pcf8575_1_port;
+
+	ret_val = i2c_transfer(pcf8575_1_client->adapter, &msg, 1);
+	return ret_val;
+
+}
+static int pcf8575_video_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	pcf8575_1_client = client;
+	return 0;
+}
+
+static int __devexit pcf8575_video_remove(struct i2c_client *client)
+{
+	pcf8575_1_client = NULL;
+	return 0;
+}
+
+//static void ft5x0x_ts_init(int evm_id, int profile)
+//{
+
+  //     printk("FT5x0x pin mux\n");
+//	omap_mux_init_signal(
+
+//};
+
+
+static struct i2c_driver pcf8575_driver = {
+	.driver = {
+		.name   = "pcf8575_1_dm813x",
+	},
+	.probe          = pcf8575_video_probe,
+	.remove         = pcf8575_video_remove,
+	.id_table       = pcf8575_video_id,
+};
+
+int dm813x_pcf8575_init(void)
+{
+	i2c_add_driver(&pcf8575_driver);
+	return 0;
+}
+
+int dm813x_pcf8575_exit(void)
+{
+	i2c_del_driver(&pcf8575_driver);
+	return 0;
+}
+
 static void __init ti814x_tsc_init(void)
 {
 	int error;
@@ -313,6 +540,9 @@
 	 */
 	omap_register_i2c_bus(1, 100, ti814x_i2c_boardinfo,
 				ARRAY_SIZE(ti814x_i2c_boardinfo));
+	omap_register_i2c_bus(3, 100, dm813x_i2c_boardinfo1,
+				ARRAY_SIZE(dm813x_i2c_boardinfo1));
+
 }
 
 static u8 dm385_iis_serializer_direction[] = {
@@ -331,8 +561,8 @@
 	.serial_dir	= dm385_iis_serializer_direction,
 	.asp_chan_q	= EVENTQ_2,
 	.version	= MCASP_VERSION_2,
-	.txnumevt	= 1,
-	.rxnumevt	= 1,
+	.txnumevt	= 64,
+	.rxnumevt	= 64,
 };
 
 /* NOR Flash partitions */
@@ -490,6 +720,7 @@
 static struct snd_hdmi_platform_data dm385_snd_hdmi_pdata = {
 	.dma_addr = TI81xx_HDMI_WP + HDMI_WP_AUDIO_DATA,
 	.channel = 53,
+	.dma_chan_q = EVENTQ_0,
 	.data_type = 4,
 	.acnt = 4,
 	.fifo_level = 0x20,
@@ -550,6 +781,8 @@
 	omap_serial_init();
 	ti814x_tsc_init();
 	ti814x_evm_i2c_init();
+//	dm385_irda_init()
+	ti813x_cir_pin_mux();
 	ti81xx_register_mcasp(0, &dm385_evm_snd_data);
 
 	omap2_hsmmc_init(mmc);
@@ -566,12 +799,15 @@
 			ARRAY_SIZE(ti814x_nand_partitions), 0, bw);
 	} else
 		board_nand_init(ti814x_nand_partitions,
-		ARRAY_SIZE(ti814x_nand_partitions), 0, NAND_BUSWIDTH_16);
+		ARRAY_SIZE(ti814x_nand_partitions), 0, NAND_OMAP_BUS_16);
 
 	/* initialize usb */
 	usb_musb_init(&musb_board_data);
 
 	dm385_spi_init();
+
+        //ft5x0x_ts_init();
+
 #ifdef CONFIG_SND_SOC_TI81XX_HDMI
 	/* hdmi mclk setup */
 	ti813x_hdmi_clk_init();
@@ -580,6 +816,7 @@
 	regulator_use_dummy_regulator();
 	board_nor_init(ti814x_evm_norflash_partitions,
 		ARRAY_SIZE(ti814x_evm_norflash_partitions), 0);
+	//ti813x_pcf8575_cir_init();
 }
 
 static void __init dm385_evm_map_io(void)
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm81xx.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm81xx.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pm81xx.c	2014-08-07 14:42:24.000000000 -0600
@@ -32,6 +32,7 @@
 #include "prm-regbits-81xx.h"
 #include "prm2xxx_3xxx.h"
 #include <mach/omap4-common.h>
+#include <mach/ti81xx-common.h>
 #include <plat/serial.h>
 #include <plat/sram.h>
 
@@ -312,6 +313,41 @@
 }
 
 /**
+ * ti81xx_idle - idle routine for the CPU.'
+ *
+ * This function is used as replacement for default_idle()->arch_idle(), it does
+ * following apart from just invoking WFI as arch_idle() would do otherwise:
+ *	1) Skip wfi on ti81xx ES1.0
+ *	2) Do DMM and L3 interconnect write buffer draining before entering WFI
+ *	- this is required as workaround to avoid issue of aync brides in
+ *	MPU->L3 and MPU->DMM path getting corrupted write pointers leading to
+ *	incorrect writes resulting into undefined behavior (kernel crash or even
+ *	lockup). This workaround involves writes to respective locations in the
+ *	above paths (DDR for MPU->DMM), OCMC RAM for MPU->L3) mapped as strongly
+ *	ordered which would go as non-posted writes.
+ *	3) Ensure that no normal memory accesses (posted writes) or even cache
+ *	maintainance kicks in after the above non-posted writes.
+ *	4) If or during the time the DDR and OCMC regions are not mapped,
+ *	proceed to use default cpu_do_idle().
+ *
+ *	Note: We don't disable and enable FIQs here. It is expected that we are
+ *	called with IRQs disabled.
+ */
+static void ti81xx_idle(void)
+{
+	if (!cpu_is_ti814x() || cpu_is_dm385() ||
+			(omap_rev() > TI8148_REV_ES1_0)) {
+
+		if(dram_sync && sram_sync) {}
+			//ti81xx_do_wfi_sync(dram_sync, sram_sync);
+		else
+			cpu_do_idle();
+	}
+
+	local_irq_enable();
+}
+
+/**
  * ti81xx_pm_init - Init routine for TI81XX PM
  *
  * Initializes all powerdomain and clockdomain target states
@@ -324,9 +360,16 @@
 
 	pr_info("Power Management for TI81XX.\n");
 
+	/*
+	 * Override default_idle as we will be doing more than just wfi --> see
+	 * ti81xx_idle()
+	 */
+	pm_idle = ti81xx_idle;
+
+	/* Not all devices support PM beyond idle (WFI), return */
 	if (!cpu_is_dm385() && !(cpu_is_ti814x() &&
 				(omap_rev() > TI8148_REV_ES1_0)))
-		return -ENODEV;
+		return 0;
 
 	prcm_setup_regs();
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/base/power/runtime.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/base/power/runtime.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/base/power/runtime.c	2014-08-07 11:51:59.178748380 -0600
@@ -135,8 +135,9 @@
 
 	if (dev->power.runtime_error)
 		retval = -EINVAL;
-	else if (atomic_read(&dev->power.usage_count) > 0
-	    || dev->power.disable_depth > 0)
+	else if (dev->power.disable_depth > 0)
+		retval = -EACCES;
+	else if (atomic_read(&dev->power.usage_count) > 0)
 		retval = -EAGAIN;
 	else if (!pm_children_suspended(dev))
 		retval = -EBUSY;
@@ -257,7 +258,7 @@
 	spin_lock_irq(&dev->power.lock);
 	dev->power.runtime_error = retval;
 
-	return retval;
+	return retval != -EACCES ? retval : -EIO;
 }
 
 /**
@@ -442,7 +443,7 @@
 	if (dev->power.runtime_error)
 		retval = -EINVAL;
 	else if (dev->power.disable_depth > 0)
-		retval = -EAGAIN;
+		retval = -EACCES;
 	if (retval)
 		goto out;
 
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/Kconfig	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/Kconfig	2014-08-07 11:51:59.226748378 -0600
@@ -351,6 +351,23 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called qt602240_ts.
 
+
+config TOUCHSCREEN_FT5X0x_TS
+
+        tristate "EDT FocalTech FT5X0x_TS I2C Touchscreen support"
+        depends on I2C
+        help
+          Say Y here if you have an EDT "Polytouch" touchscreen based
+          on the FocalTech FT5x06 family of controllers connected to
+          your system.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the
+          module will be called edt-ft5x0x.
+
+
+
 config TOUCHSCREEN_MIGOR
 	tristate "Renesas MIGO-R touchscreen"
 	depends on SH_MIGOR && I2C
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/Makefile
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/Makefile	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/Makefile	2014-08-07 11:51:59.226748378 -0600
@@ -18,6 +18,8 @@
 obj-$(CONFIG_TOUCHSCREEN_CY8CTMG110)	+= cy8ctmg110_ts.o
 obj-$(CONFIG_TOUCHSCREEN_DA9034)	+= da9034-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DYNAPRO)	+= dynapro.o
+obj-$(CONFIG_TOUCHSCREEN_FT5X0x_TS)             += ft5x0x_ts.o
+
 obj-$(CONFIG_TOUCHSCREEN_HAMPSHIRE)	+= hampshire.o
 obj-$(CONFIG_TOUCHSCREEN_GUNZE)		+= gunze.o
 obj-$(CONFIG_TOUCHSCREEN_EETI)		+= eeti_ts.o
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/ft5x0x_ts.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/ft5x0x_ts.c	2014-08-07 11:51:59.226748378 -0600
@@ -0,0 +1,613 @@
+/*
+ * drivers/input/touchscreen/ft5x0x_ts.c
+ *
+ * FocalTech ft5x0x TouchScreen driver.
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *	note: only support mulititouch	Wenfs 2010-10-01
+ */
+
+#include <linux/module.h>
+#include <linux/hrtimer.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/i2c/ft5x06_ts.h>
+#include <linux/earlysuspend.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+//#include <asm/jzsoc.h>
+
+//#define DEBUG 0
+//#define DEBUG_0 0
+
+#ifdef DEBUG_0
+	#define TS_DEBUG(fmt,args...) printk(fmt, ##args )
+	#else
+	#define TS_DEBUG(fmt,args...)
+#endif
+
+#ifdef DEBUG
+	#define TS_DEBUG1(fmt,args...) printk(fmt, ##args )
+	#else
+	#define TS_DEBUG1(fmt,args...)
+#endif
+
+static struct i2c_client *this_client;
+//static struct ft5x0x_ts_platform_data *pdata;
+
+//#define CONFIG_FT5X0X_MULTITOUCH 1
+
+struct ts_event {
+	u16 	x;
+	u16	y;
+	u16	x1;
+	u16	y1;
+	u16	x2;
+	u16	y2;
+	u16	x3;
+	u16	y3;
+	u16	x4;
+	u16	y4;
+	u16	x5;
+	u16	y5;
+	u16	pressure;
+	s16 touch_ID1;
+	s16 touch_ID2;
+	s16 touch_ID3;
+	s16 touch_ID4;
+	s16 touch_ID5;
+    u8  touch_point;
+};
+
+struct ft5x0x_ts_data {
+	struct input_dev	*input_dev;
+	struct ts_event		event;
+	struct work_struct 	pen_event_work;
+	struct workqueue_struct *ts_workqueue;
+	struct early_suspend	early_suspend;
+};
+
+static int ft5x0x_i2c_rxdata(char *rxdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= rxdata,
+		},
+		{
+			.addr	= this_client->addr,
+			.flags	= I2C_M_RD,
+			.len	= length,
+			.buf	= rxdata,
+		},
+	};
+
+    //msleep(1);
+	ret = i2c_transfer(this_client->adapter, msgs, 2);
+	if (ret < 0)
+		pr_err("msg %s i2c read error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int ft5x0x_i2c_txdata(char *txdata, int length)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr	= this_client->addr,
+			.flags	= 0,
+			.len	= length,
+			.buf	= txdata,
+		},
+	};
+
+   	//msleep(1);
+	ret = i2c_transfer(this_client->adapter, msg, 1);
+	if (ret < 0)
+		pr_err("%s i2c write error: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int ft5x0x_set_reg(u8 addr, u8 para)
+{
+    u8 buf[3];
+    int ret = -1;
+
+    buf[0] = addr;
+    buf[1] = para;
+    ret = ft5x0x_i2c_txdata(buf, 2);
+    if (ret < 0) {
+        pr_err("write reg failed! %#x ret: %d", buf[0], ret);
+        return -1;
+    }
+
+    return 0;
+}
+
+static void ft5x0x_ts_release(void)
+{
+//	TS_DEBUG("ft5x0x_ts_release");
+	struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+#ifdef CONFIG_FT5X0X_MULTITOUCH
+	input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+	input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+
+#else
+	input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+	input_report_key(data->input_dev, BTN_TOUCH, 0);
+#endif
+	input_sync(data->input_dev);
+}
+
+static int ft5x0x_read_data(void)
+{
+	struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+//	u8 buf[14] = {0};
+	u8 buf[32] = {0};
+	int ret = -1;
+	int status = 0;
+
+#ifdef CONFIG_FT5X0X_MULTITOUCH
+//	ret = ft5x0x_i2c_rxdata(buf, 13);
+	ret = ft5x0x_i2c_rxdata(buf, 31);
+#else
+    ret = ft5x0x_i2c_rxdata(buf, 7);
+#endif
+    if (ret < 0) {
+		printk("%s read_data i2c_rxdata failed: %d\n", __func__, ret);
+		return ret;
+	}
+
+	memset(event, 0, sizeof(struct ts_event));
+//	event->touch_point = buf[2] & 0x03;// 0000 0011
+	event->touch_point = buf[2] & 0x07;// 000 0111
+
+    if (event->touch_point == 0) {
+        ft5x0x_ts_release();
+        return 1;
+    }
+#ifdef CONFIG_FT5X0X_MULTITOUCH
+    switch (event->touch_point) {
+		case 5:
+			event->x5 = (s16)(buf[0x1b] & 0x0F)<<8 | (s16)buf[0x1c];
+			event->y5 = (s16)(buf[0x1d] & 0x0F)<<8 | (s16)buf[0x1e];
+			status = (s16)((buf[0x1b] & 0xc0) >> 6);
+			event->touch_ID5=(s16)(buf[0x1D] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 4:
+			event->x4 = (s16)(buf[0x15] & 0x0F)<<8 | (s16)buf[0x16];
+			event->y4 = (s16)(buf[0x17] & 0x0F)<<8 | (s16)buf[0x18];
+			status = (s16)((buf[0x15] & 0xc0) >> 6);
+			event->touch_ID4=(s16)(buf[0x17] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 3:
+			event->x3 = (s16)(buf[0x0f] & 0x0F)<<8 | (s16)buf[0x10];
+			event->y3 = (s16)(buf[0x11] & 0x0F)<<8 | (s16)buf[0x12];
+			status = (s16)((buf[0x0f] & 0xc0) >> 6);
+			event->touch_ID3=(s16)(buf[0x11] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 2:
+			event->x2 = (s16)(buf[9] & 0x0F)<<8 | (s16)buf[10];
+			event->y2 = (s16)(buf[11] & 0x0F)<<8 | (s16)buf[12];
+			status = (s16)((buf[0x9] & 0xc0) >> 6);
+			event->touch_ID2=(s16)(buf[0x0b] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 1:
+			event->x1 = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+			event->y1 = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+			status = (s16)((buf[0x3] & 0xc0) >> 6);
+			event->touch_ID1=(s16)(buf[0x05] & 0xF0)>>4;
+	/*		event->x = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+	                event->y = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+			status = (s16)((buf[0x3] & 0xc0) >> 6);*/
+
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+            break;
+		default:
+		    return -1;
+	}
+#else
+    if (event->touch_point == 1) {
+    	event->x = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+		event->y = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+    }
+#endif
+
+
+    event->pressure = 200;
+
+	dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d \n", __func__,
+		event->x1, event->y1, event->x2, event->y2);
+
+    return 0;
+}
+
+static void ft5x0x_report_value(void)
+{
+	struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+	struct ts_event *event = &data->event;
+
+		TS_DEBUG("==ft5x0x_report_value =\n");
+#ifdef CONFIG_FT5X0X_MULTITOUCH
+	switch(event->touch_point) {
+		case 5:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID5);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x5);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y5);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 4:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID4);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x4);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y4);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 3:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID3);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x3);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y3);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 2:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID2);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x2);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y2);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 1:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID1);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x1);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y1);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x1 = %d,y1 = %d ====\n",event->x1,event->y1);
+/*			input_report_abs(data->input_dev, ABS_X, event->x);
+	                input_report_abs(data->input_dev, ABS_Y, event->y);
+        	        input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);*/
+		default:
+			TS_DEBUG("==touch_point default =\n");
+			break;
+
+	}
+#else	/* CONFIG_FT5X0X_MULTITOUCH*/
+	if (event->touch_point == 1) {
+		input_report_abs(data->input_dev, ABS_X, event->x);
+		input_report_abs(data->input_dev, ABS_Y, event->y);
+		input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);
+	}
+
+	input_report_key(data->input_dev, BTN_TOUCH, 1);
+	TS_DEBUG("ROHIT ::::::::::; SINGLE TOUCH ===x1 = %d,y1 = %d ====\n",event->x,event->y);
+#endif	/* CONFIG_FT5X0X_MULTITOUCH*/
+	input_sync(data->input_dev);
+
+	dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d \n", __func__,
+		event->x, event->y, event->x2, event->y2);
+	TS_DEBUG1("1:(%d, %d) 2:(%d, %d) 3:(%d, %d) 4:(%d, %d) 5:(%d, %d)\n",
+		event->x1, event->y1, event->x2, event->y2, event->x3, event->y3,
+		event->x4, event->y4, event->x5, event->y5);
+}	/*end ft5x0x_report_value*/
+
+static void ft5x0x_ts_pen_irq_work(struct work_struct *work)
+{
+	int ret = -1;
+
+//	disable_irq(this_client->irq);
+	//disable_irq_nosync(this_client->irq);
+
+	TS_DEBUG("==work 1=\n");
+	ret = ft5x0x_read_data();
+	if (ret == 0) {
+		ft5x0x_report_value();
+	}
+	else
+		TS_DEBUG("data package read error\n");
+	TS_DEBUG("==work 2=\n");
+//    	msleep(1);
+//    enable_irq(this_client->irq);
+//	enable_irq(IRQ_EINT(6));
+}
+
+static irqreturn_t ft5x0x_ts_interrupt(int irq, void *dev_id)
+{
+	struct ft5x0x_ts_data *ft5x0x_ts = dev_id;
+
+	TS_DEBUG("==int ft5x0x_ts_interrupt=\n");
+
+//	disable_irq(this_client->irq);
+//	disable_irq(IRQ_EINT(6));
+
+
+	if (!work_pending(&ft5x0x_ts->pen_event_work)) {
+		queue_work(ft5x0x_ts->ts_workqueue, &ft5x0x_ts->pen_event_work);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ft5x0x_ts_suspend(struct early_suspend *handler)
+{
+//	struct ft5x0x_ts_data *ts;
+//	ts =  container_of(handler, struct ft5x0x_ts_data, early_suspend);
+
+	TS_DEBUG("==ft5x0x_ts_suspend=\n");
+//	disable_irq(this_client->irq);
+//	disable_irq(IRQ_EINT(6));
+//	cancel_work_sync(&ts->pen_event_work);
+//	flush_workqueue(ts->ts_workqueue);
+	// ==set mode ==,
+//    	ft5x0x_set_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
+}
+
+static void ft5x0x_ts_resume(struct early_suspend *handler)
+{
+	TS_DEBUG("==ft5x0x_ts_resume=\n");
+	// wake the mode
+//	__gpio_as_output(GPIO_FT5X0X_WAKE);
+//	__gpio_clear_pin(GPIO_FT5X0X_WAKE);		//set wake = 0,base on system
+//	 msleep(100);
+//	__gpio_set_pin(GPIO_FT5X0X_WAKE);			//set wake = 1,base on system
+//	msleep(100);
+//	enable_irq(this_client->irq);
+//	enable_irq(IRQ_EINT(6));
+}
+#endif  //CONFIG_HAS_EARLYSUSPEND
+
+static int
+ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct ft5x0x_ts_data *ft5x0x_ts;
+	struct input_dev *input_dev;
+	int err = 0;
+	int irq_num;
+
+	printk("ROH: IN Probe Function .... Touch driver\n");
+	TS_DEBUG("\n\n\n\n#############################################==ft5x0x_ts_probe=\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	TS_DEBUG("==kzalloc=\n");
+	ft5x0x_ts = kzalloc(sizeof(*ft5x0x_ts), GFP_KERNEL);
+	if (!ft5x0x_ts)	{
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+
+	TS_DEBUG("==i2c_set_clientdata=\n");
+	this_client = client;
+	i2c_set_clientdata(client, ft5x0x_ts);
+//	i2c_jz_setclk(client, 100*1000);
+
+	TS_DEBUG("==INIT_WORK=\n");
+	INIT_WORK(&ft5x0x_ts->pen_event_work, ft5x0x_ts_pen_irq_work);
+	TS_DEBUG("==create_singlethread_workqueue=\n");
+	ft5x0x_ts->ts_workqueue = create_singlethread_workqueue(dev_name(&client->dev));
+	if (!ft5x0x_ts->ts_workqueue) {
+		err = -ESRCH;
+		goto exit_create_singlethread;
+	}
+
+//	pdata = client->dev.platform_data;
+//	if (pdata == NULL) {
+//		dev_err(&client->dev, "%s: platform data is null\n", __func__);
+//		goto exit_platform_data_null;
+//	}
+
+//	TS_DEBUG("==request_irq=\n");
+//	err = request_irq(client->irq, ft5x0x_ts_interrupt, IRQF_DISABLED, "ft5x0x_ts", ft5x0x_ts);
+//	err = request_irq(IRQ_EINT(6), ft5x0x_ts_interrupt, IRQF_TRIGGER_FALLING, "ft5x0x_ts", ft5x0x_ts);
+
+
+	irq_num = gpio_to_irq(46);
+	printk("ROH : irq_num allocated is %d\n", irq_num);
+
+	err = request_irq(irq_num, ft5x0x_ts_interrupt, IRQF_DISABLED | IRQF_TRIGGER_FALLING, "ft5x0x_ts", ft5x0x_ts);
+	if (err < 0) {
+		printk("ROH : irq requst failed\n");
+		dev_err(&client->dev, "ft5x0x_probe: request irq failed\n");
+		goto exit_irq_request_failed;
+	}
+
+//	__gpio_as_irq_fall_edge(pdata->intr);		//
+//	disable_irq(this_client->irq);
+//	disable_irq(IRQ_EINT(6));
+
+	TS_DEBUG("==input_allocate_device=\n");
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+
+	ft5x0x_ts->input_dev = input_dev;
+
+#ifdef CONFIG_FT5X0X_MULTITOUCH
+	set_bit(ABS_MT_TOUCH_MAJOR, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_X, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_Y, input_dev->absbit);
+	set_bit(ABS_MT_WIDTH_MAJOR, input_dev->absbit);
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_Y, 0, SCREEN_MAX_Y, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_TOUCH_MAJOR, 0, PRESS_MAX, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);
+
+/*	set_bit(ABS_X, input_dev->absbit);
+        set_bit(ABS_Y, input_dev->absbit);
+        set_bit(ABS_PRESSURE, input_dev->absbit);
+        set_bit(BTN_TOUCH, input_dev->keybit);
+
+        input_set_abs_params(input_dev, ABS_X, 0, SCREEN_MAX_X, 0, 0);
+        input_set_abs_params(input_dev, ABS_Y, 0, SCREEN_MAX_Y, 0, 0);
+        input_set_abs_params(input_dev,
+                             ABS_PRESSURE, 0, PRESS_MAX, 0 , 0);
+
+*/
+#else
+	set_bit(ABS_X, input_dev->absbit);
+	set_bit(ABS_Y, input_dev->absbit);
+	set_bit(ABS_PRESSURE, input_dev->absbit);
+	set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_set_abs_params(input_dev, ABS_X, 0, SCREEN_MAX_X, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, SCREEN_MAX_Y, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_PRESSURE, 0, PRESS_MAX, 0 , 0);
+#endif
+
+	set_bit(EV_ABS, input_dev->evbit);
+	set_bit(EV_KEY, input_dev->evbit);
+	set_bit(EV_SYN, input_dev->evbit);
+
+	input_dev->name		= FT5X0X_NAME;		//dev_name(&client->dev)
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev,
+		"ft5x0x_ts_probe: failed to register input device: %s\n",
+		dev_name(&client->dev));
+		goto exit_input_register_device_failed;
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	TS_DEBUG("==register_early_suspend =\n");
+	ft5x0x_ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ft5x0x_ts->early_suspend.suspend = ft5x0x_ts_suspend;
+	ft5x0x_ts->early_suspend.resume	= ft5x0x_ts_resume;
+	register_early_suspend(&ft5x0x_ts->early_suspend);
+#endif
+//wake the CTPM
+//	__gpio_as_output(GPIO_FT5X0X_WAKE);
+//	__gpio_clear_pin(GPIO_FT5X0X_WAKE);		//set wake = 0,base on system
+//	 msleep(100);
+//	__gpio_set_pin(GPIO_FT5X0X_WAKE);			//set wake = 1,base on system
+//	msleep(100);
+//	ft5x0x_set_reg(0x88, 0x05); //5, 6,7,8
+//	ft5x0x_set_reg(0x80, 30);
+//	msleep(50);
+
+//	enable_irq(this_client->irq);
+//	enable_irq(IRQ_EINT(6));
+
+	TS_DEBUG("==probe over =, this_client->irq=%d\n\n\n", this_client->irq);
+    return 0;
+
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+exit_input_dev_alloc_failed:
+	free_irq(client->irq, ft5x0x_ts);
+//	free_irq(IRQ_EINT(6), ft5x0x_ts);
+exit_irq_request_failed:
+//exit_platform_data_null:
+//	cancel_work_sync(&ft5x0x_ts->pen_event_work);
+//	destroy_workqueue(ft5x0x_ts->ts_workqueue);
+exit_create_singlethread:
+	TS_DEBUG("==singlethread error =\n\n\n");
+	i2c_set_clientdata(client, NULL);
+	kfree(ft5x0x_ts);
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	return err;
+}
+
+static int __devexit ft5x0x_ts_remove(struct i2c_client *client)
+{
+	//TS_DEBUG("==ft5x0x_ts_remove=\n");
+	struct ft5x0x_ts_data *ft5x0x_ts = i2c_get_clientdata(client);
+	unregister_early_suspend(&ft5x0x_ts->early_suspend);
+	free_irq(client->irq, ft5x0x_ts);
+//	free_irq(IRQ_EINT(6), ft5x0x_ts);
+	input_unregister_device(ft5x0x_ts->input_dev);
+	kfree(ft5x0x_ts);
+	cancel_work_sync(&ft5x0x_ts->pen_event_work);
+	destroy_workqueue(ft5x0x_ts->ts_workqueue);
+	i2c_set_clientdata(client, NULL);
+	return 0;
+}
+
+static const struct i2c_device_id ft5x0x_ts_id[] = {
+	{ FT5X0X_NAME, 0 },{ }
+};
+MODULE_DEVICE_TABLE(i2c, ft5x0x_ts_id);
+
+static struct i2c_driver ft5x0x_ts_driver = {
+	.probe		= ft5x0x_ts_probe,
+	.remove		= __devexit_p(ft5x0x_ts_remove),
+	.id_table	= ft5x0x_ts_id,
+	.driver	= {
+		.name	= FT5X0X_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ft5x0x_ts_init(void)
+{
+	printk("ROH: IN INit Function .... Touch driver\n");
+	return i2c_add_driver(&ft5x0x_ts_driver);
+}
+
+static void __exit ft5x0x_ts_exit(void)
+{
+	i2c_del_driver(&ft5x0x_ts_driver);
+}
+
+module_init(ft5x0x_ts_init);
+module_exit(ft5x0x_ts_exit);
+
+MODULE_AUTHOR("<wenfs@Focaltech-systems.com>");
+MODULE_DESCRIPTION("FocalTech ft5x0x TouchScreen driver");
+MODULE_LICENSE("GPL");
+
+
+
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/tsc2007.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/tsc2007.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/input/touchscreen/tsc2007.c	2014-08-07 11:51:59.258748376 -0600
@@ -26,6 +26,12 @@
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/i2c/tsc2007.h>
+#include <plat/irqs.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+
 
 #define TS_POLL_DELAY			1 /* ms delay between samples */
 #define TS_POLL_PERIOD			1 /* ms delay between samples */
@@ -268,6 +274,7 @@
 	struct tsc2007_platform_data *pdata = client->dev.platform_data;
 	struct input_dev *input_dev;
 	int err;
+	int irq_num;
 
 	if (!pdata) {
 		dev_err(&client->dev, "platform data is required!\n");
@@ -312,8 +319,11 @@
 	if (pdata->init_platform_hw)
 		pdata->init_platform_hw();
 
-	err = request_irq(ts->irq, tsc2007_irq, 0,
-			client->dev.driver->name, ts);
+	irq_num = gpio_to_irq(46);
+        printk("ROH : irq_num allocated is %d\n", irq_num);
+
+
+	err = request_irq(irq_num, tsc2007_irq, IRQF_DISABLED | IRQF_TRIGGER_FALLING, client->dev.driver->name, ts);
 	if (err < 0) {
 		dev_err(&client->dev, "irq %d busy?\n", ts->irq);
 		goto err_free_mem;
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/staging/rt2870/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/staging/rt2870/Kconfig	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/staging/rt2870/Kconfig	2014-08-07 11:51:59.294748375 -0600
@@ -2,7 +2,7 @@
 	tristate "Ralink 2870/3070 wireless support"
 	depends on USB && (X86 || ARM) && WLAN
 	select WIRELESS_EXT
-	select WEXT_PRIV
+#	select WEXT_PRIV
 	select CRC_CCITT
 	select FW_LOADER
 	---help---
Index: kernel/linux-2.6.37-psp04.04.00.01/fs/ubifs/sb.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/fs/ubifs/sb.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/fs/ubifs/sb.c	2014-08-07 11:51:59.326748373 -0600
@@ -715,8 +715,12 @@
 		lnum = ubifs_next_log_lnum(c, lnum);
 	}
 
-	/* Fixup the current log head */
-	err = fixup_leb(c, c->lhead_lnum, c->lhead_offs);
+	/*
+	 * Fixup the log head which contains the only a CS node at the
+	 * beginning.
+	 */
+	err = fixup_leb(c, c->lhead_lnum,
+			ALIGN(UBIFS_CS_NODE_SZ, c->min_io_size));
 	if (err)
 		goto out;
 
Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/earlysuspend.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/earlysuspend.h	2014-08-07 11:51:59.354748372 -0600
@@ -0,0 +1,55 @@
+/* include/linux/earlysuspend.h
+*
+* Copyright (C) 2007-2008 Google, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+*/
+
+#ifndef _LINUX_EARLYSUSPEND_H
+#define _LINUX_EARLYSUSPEND_H
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/list.h>
+#endif
+
+/* The early_suspend structure defines suspend and resume hooks to be called
+* when the user visible sleep state of the system changes, and a level to
+* control the order. They can be used to turn off the screen and input
+* devices that are not used for wakeup.
+* Suspend handlers are called in low to high level order, resume handlers are
+* called in the opposite order. If, when calling register_early_suspend,
+* the suspend handlers have already been called without a matching call to the
+* resume handlers, the suspend handler will be called directly from
+* register_early_suspend. This direct call can violate the normal level order.
+*/
+enum {
+EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+struct early_suspend {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+struct list_head link;
+int level;
+void (*suspend)(struct early_suspend *h);
+void (*resume)(struct early_suspend *h);
+#endif
+};
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+#else
+#define register_early_suspend(handler) do { } while (0)
+#define unregister_early_suspend(handler) do { } while (0)
+#endif
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/i2c/ft5x06_ts.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/i2c/ft5x06_ts.h	2014-08-07 11:51:59.362748372 -0600
@@ -0,0 +1,42 @@
+#ifndef __LINUX_FT5X0X_TS_H__
+#define __LINUX_FT5X0X_TS_H__
+
+#define SCREEN_MAX_X    1280
+#define SCREEN_MAX_Y    800
+#define PRESS_MAX       255
+
+#define FT5X0X_NAME	"ft5x0x_ts"
+
+struct ft5x0x_ts_platform_data{
+	u16	intr;		/* irq number	*/
+};
+
+enum ft5x0x_ts_regs {
+	FT5X0X_REG_PMODE	= 0xA5,	/* Power Consume Mode		*/
+};
+
+//FT5X0X_REG_PMODE
+#define PMODE_ACTIVE        0x00
+#define PMODE_MONITOR       0x01
+#define PMODE_STANDBY       0x02
+#define PMODE_HIBERNATE     0x03
+
+
+	#ifndef ABS_MT_TOUCH_MAJOR
+	#define ABS_MT_TOUCH_MAJOR	0x30	/* touching ellipse */
+	#define ABS_MT_TOUCH_MINOR	0x31	/* (omit if circular) */
+	#define ABS_MT_WIDTH_MAJOR	0x32	/* approaching ellipse */
+	#define ABS_MT_WIDTH_MINOR	0x33	/* (omit if circular) */
+	#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
+	#define ABS_MT_POSITION_X	0x35	/* Center X ellipse position */
+	#define ABS_MT_POSITION_Y	0x36	/* Center Y ellipse position */
+	#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
+	#define ABS_MT_BLOB_ID		0x38	/* Group set of pkts as blob */
+	#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
+
+	#endif /* ABS_MT_TOUCH_MAJOR */
+
+
+#endif
+
+
Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/sii9022a.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/sii9022a.h	2014-08-07 11:51:59.362748372 -0600
@@ -0,0 +1,30 @@
+ /* sii9022a.h : sii9022a platform data
+ *
+ * Copyright (C) 2009 Texas Instruments Inc
+ * Author: Deepthy Ravi <deepthy.ravi@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _SII9022A_H_
+#define _SII9022A_H_
+
+struct sii9022a_platform_data {
+	u32 hdmi_hot_plug_gpio_intr_line; /* HDMI hot plug GPIO int line */
+	u32 sync_mode; /* Sync Mode */
+	u32 clk_edge;
+};
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/include/linux/usb/gadget.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/include/linux/usb/gadget.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/include/linux/usb/gadget.h	2014-08-07 11:51:59.402748370 -0600
@@ -898,7 +898,7 @@
 
 /* API for dual gadget configuration */
 extern int get_gadget_drv_id(void);
-extern int put_gadget_drv_id(void);
+extern int put_gadget_drv_id(int id);
 extern int get_gadget_max_drv_id(void);
 
 #endif /* __LINUX_USB_GADGET_H */
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/tlv320aic3x.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/tlv320aic3x.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/tlv320aic3x.c	2014-08-07 11:51:59.422748369 -0600
@@ -991,7 +991,22 @@
 	struct snd_soc_codec *codec = codec_dai->codec;
 	struct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);
 	u8 iface_areg, iface_breg;
-	int delay = 0;
+	int delay = 0, i = 0;
+	u8 *cache = codec->reg_cache;
+
+	/*
+	 * Register cache sync issue faced while running
+	 * audio in a tight loop for long time(TI811X).
+	 * The actual root cause is unknow.
+	 *
+	 * Workaround:
+	 * forcing the reg cache sync always in the startup
+	 *
+	 */
+
+	for (i = 0; i < ARRAY_SIZE(aic3x_reg); i++)
+		snd_soc_write(codec, i, cache[i]);
+	codec->cache_sync = 0;
 
 	iface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;
 	iface_breg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & 0x3f;
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-evm.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-evm.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-evm.c	2014-08-07 11:51:59.430748368 -0600
@@ -66,7 +66,6 @@
 				machine_is_ti8148evm() ||
 				machine_is_dm385evm())
 		sysclk = 24576000;
-
 	else
 		return -EINVAL;
 
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-hdmi.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-hdmi.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-hdmi.c	2014-08-07 11:51:59.430748368 -0600
@@ -47,6 +47,7 @@
 
 /* Currently, we support only 16b & 24b samples at HDMI */
 #define DAVINCI_HDMI_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+//#define HDMI_FORCE_SW_ACR
 
 /* Fs - N lookup table for CTS calculation for S/W mode*/
 const struct audio_fs_n audio_fs_n_list[] = {
@@ -80,6 +81,7 @@
 #ifdef HDMI_FORCE_SW_ACR
 	return CTS_MODE_SW;
 #else
+	/* only TI8168 PG2.0 or higher support auto mode*/
 	if (cpu_is_ti816x() && TI8168_REV_ES2_0 > omap_rev())
 		return CTS_MODE_SW;
 	else
@@ -149,6 +151,12 @@
 	u64 tmp_cts = 0;
 	u32 tmp_fs = 0 ;
 
+	/*
+	 * Currently, the deep color is not supported. Hence the
+	 * N/CTS values computations do not consider the same
+	 */
+	hdmi_w1_wrapper_disable(HDMI_WP);
+
 	/* TODO Modify the N/CTS value selection based on the Video clkc */
 	tmds = hdmi_lib_get_pixel_clock();
 	rate = params_rate(params);
@@ -195,29 +203,37 @@
 	case SNDRV_PCM_FORMAT_S16_LE:
 		audio_fmt.sample_number = HDMI_ONEWORD_TWO_SAMPLES;
 		audio_fmt.sample_size = HDMI_SAMPLE_16BITS;
-		audio_cfg.if_sample_size = (IF_16BIT_PER_SAMPLE << 1) |
-						 HDMI_SAMPLE_16BITS;
+		audio_fmt.justify = HDMI_AUDIO_JUSTIFY_LEFT;
+		audio_cfg.justify = HDMI_AUDIO_JUSTIFY_LEFT;
+		audio_cfg.if_sample_size = IF_16BIT_PER_SAMPLE;
+		audio_dma.dma_transfer = 0x10;
 		break;
 	case SNDRV_PCM_FORMAT_S24_LE:
 		audio_fmt.sample_number = HDMI_ONEWORD_ONE_SAMPLE;
 		audio_fmt.sample_size = HDMI_SAMPLE_24BITS;
-		audio_cfg.if_sample_size = (IF_24BIT_PER_SAMPLE << 1) |
-						HDMI_SAMPLE_24BITS;
+		audio_fmt.justify = HDMI_AUDIO_JUSTIFY_RIGHT;
+		audio_cfg.justify = HDMI_AUDIO_JUSTIFY_RIGHT;
+		audio_cfg.if_sample_size = IF_24BIT_PER_SAMPLE;
+		audio_dma.dma_transfer = 0x20;
 		break;
 	default:
 		err = -EINVAL;
 	}
 
 	/* HDMI Wrapper config */
-	audio_fmt.justify = HDMI_AUDIO_JUSTIFY_LEFT;
 	audio_fmt.stereo_channel_enable = HDMI_STEREO_ONECHANNELS;
 	audio_fmt.audio_channel_location = HDMI_CEA_CODE_03;
 	audio_fmt.iec = HDMI_AUDIO_FORMAT_LPCM;
+	/* As per spec, we support left first only */
 	audio_fmt.left_before = HDMI_SAMPLE_LEFT_FIRST;
+	/*
+	 * The HDMI audio (L-PCM) is encoded in IEC 60958
+	 * format require block start and stop
+	 */
+	audio_fmt.block_start_end = HDMI_BLOCK_STARTEND_ON;
 
 	ret = hdmi_w1_audio_config_format(HDMI_WP, &audio_fmt);
 
-	audio_dma.dma_transfer = 0x20;
 	audio_dma.block_size = 0xC0;
 	audio_dma.threshold_value = 0x20;
 	audio_dma.dma_or_irq = HDMI_THRESHOLD_DMA;
@@ -232,14 +248,13 @@
 	audio_cfg.if_channel_number = HDMI_STEREO_TWOCHANNELS;
 	audio_cfg.if_audio_channel_location = HDMI_CEA_CODE_00;
 
-	/* TODO: Is this configuration correct? */
-	audio_cfg.aud_par_busclk = 0;
-
 	if (CTS_MODE_HW == hdmi_acr_mode()) {
 		audio_cfg.cts_mode = CTS_MODE_HW;
+		audio_cfg.aud_par_busclk = (((128 * 31) - 1) << 8);
 		DBG("CTS mode is HW\n");
 	} else {
 		audio_cfg.cts_mode = CTS_MODE_SW;
+		audio_cfg.aud_par_busclk = 0;
 		DBG("CTS mode is SW\n");
 	}
 
@@ -302,6 +317,7 @@
 
 		dma_data->dma_addr = (pdata->dma_addr);
 		dma_data->channel = (pdata->channel);
+		dma_data->asp_chan_q = (pdata->dma_chan_q);
 		dma_data->data_type = (pdata->data_type);
 		dma_data->acnt = (pdata->acnt);
 		dma_data->fifo_level = (pdata->fifo_level);
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.c	2014-08-07 11:51:59.442748368 -0600
@@ -23,6 +23,8 @@
 #include <linux/io.h>
 #include <linux/clk.h>
 
+#include <asm/mach-types.h>
+
 #include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -462,6 +464,18 @@
 		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
 
 		mcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG, (0x3f << 26));
+
+		/* TI811x AIC_MCLK <-- McASP2_AHCLKX(Pin out) */
+		switch (dev->clk_input_pin) {
+		case MCASP_AHCLKX_IN:
+			mcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG, AHCLKX);
+			break;
+		case MCASP_AHCLKX_OUT:
+			mcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG, AHCLKX);
+			break;
+		default:
+			return -EINVAL;
+		}
 		break;
 
 	default:
@@ -567,7 +581,7 @@
 					TXSSZ(fmt), TXSSZ(0x0F));
 	mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXROT(rotate),
 							TXROT(7));
-	mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXROT(rotate),
+	mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXROT(0),
 							RXROT(7));
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXMASK_REG, mask);
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXMASK_REG, mask);
@@ -783,8 +797,8 @@
 		break;
 
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		davinci_mcasp_stop(dev, substream->stream);
 		if (dev->clk_active) {
+			davinci_mcasp_stop(dev, substream->stream);
 			clk_disable(dev->clk);
 			dev->clk_active = 0;
 		}
@@ -907,6 +921,7 @@
 	dev->version = pdata->version;
 	dev->txnumevt = pdata->txnumevt;
 	dev->rxnumevt = pdata->rxnumevt;
+	dev->clk_input_pin = pdata->clk_input_pin;
 
 	dma_data = &dev->dma_params[SNDRV_PCM_STREAM_PLAYBACK];
 	dma_data->asp_chan_q = pdata->asp_chan_q;
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.h	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.h	2014-08-07 11:51:59.446748368 -0600
@@ -60,6 +60,14 @@
 	/* McASP FIFO related */
 	u8	txnumevt;
 	u8	rxnumevt;
+
+	/*
+	 * codec clock drive from the AHCLKX out from the SoC
+	 * This need the McASP pin direction configurations
+	 * as out put and the soc pin-mux.This can be used to
+	 * configure the McASP driver PIN_DIR
+	 */
+	int clk_input_pin;
 };
 
 #endif	/* DAVINCI_MCASP_H */
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-pcm.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-pcm.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-pcm.c	2014-08-07 11:51:59.446748368 -0600
@@ -69,7 +69,7 @@
 	.buffer_bytes_max = 128 * 1024,
 	.period_bytes_min = 32,
 	.period_bytes_max = 8 * 1024,
-	.periods_min = 16,
+	.periods_min = 2,
 	.periods_max = 255,
 	.fifo_size = 0,
 };
@@ -91,7 +91,7 @@
 	.buffer_bytes_max = 128 * 1024,
 	.period_bytes_min = 32,
 	.period_bytes_max = 8 * 1024,
-	.periods_min = 16,
+	.periods_min = 2,
 	.periods_max = 255,
 	.fifo_size = 0,
 };
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/soc-core.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/soc-core.c	2014-08-07 11:51:59.482748366 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/soc-core.c	2014-08-07 11:51:59.478748366 -0600
@@ -889,22 +889,45 @@
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret;
 
-	if (codec_dai->driver->ops->trigger) {
-		ret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);
-		if (ret < 0)
-			return ret;
-	}
+	if (cmd == SNDRV_PCM_TRIGGER_START
+		|| cmd == SNDRV_PCM_TRIGGER_RESUME
+		|| cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE) {
 
-	if (platform->driver->ops->trigger) {
-		ret = platform->driver->ops->trigger(substream, cmd);
-		if (ret < 0)
-			return ret;
-	}
+		if (codec_dai->driver->ops->trigger) {
+			ret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);
+			if (ret < 0)
+				return ret;
+		}
+
+		if (platform->driver->ops->trigger) {
+			ret = platform->driver->ops->trigger(substream, cmd);
+			if (ret < 0)
+				return ret;
+		}
+
+		if (cpu_dai->driver->ops->trigger) {
+			ret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);
+			if (ret < 0)
+				return ret;
+		}
+	} else {
+		if (codec_dai->driver->ops->trigger) {
+			ret = codec_dai->driver->ops->trigger(substream, cmd, codec_dai);
+			if (ret < 0)
+				return ret;
+		}
+
+		if (cpu_dai->driver->ops->trigger) {
+			ret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);
+			if (ret < 0)
+				return ret;
+		}
 
-	if (cpu_dai->driver->ops->trigger) {
-		ret = cpu_dai->driver->ops->trigger(substream, cmd, cpu_dai);
-		if (ret < 0)
-			return ret;
+		if (platform->driver->ops->trigger) {
+			ret = platform->driver->ops->trigger(substream, cmd);
+			if (ret < 0)
+				return ret;
+		}
 	}
 	return 0;
 }
